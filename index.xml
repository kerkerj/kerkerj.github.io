<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kerkerj</title>
    <link>http://blog.kerkerj.in/index.xml</link>
    <description>Recent content on kerkerj</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <lastBuildDate>Tue, 11 Oct 2016 11:10:52 +0800</lastBuildDate>
    <atom:link href="http://blog.kerkerj.in/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[tool] diff-so-fancy</title>
      <link>http://blog.kerkerj.in/blog/tool-diff-so-fancy/</link>
      <pubDate>Tue, 11 Oct 2016 11:10:52 +0800</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/tool-diff-so-fancy/</guid>
      <description>&lt;p&gt;現在想到什麼都來 PO 一下 XD&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/so-fancy/diff-so-fancy&#34;&gt;https://github.com/so-fancy/diff-so-fancy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;拿來幫你把 &lt;code&gt;git diff&lt;/code&gt; 變漂亮的東東&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;// install
$ brew install diff-so-fancy

// Setup
$ git config --global core.pager &amp;quot;diff-so-fancy | less --tabs=4 -RFX&amp;quot;

// make it more fancier
$ git config --global color.diff-highlight.oldNormal &amp;quot;red bold&amp;quot;
$ git config --global color.diff-highlight.oldHighlight &amp;quot;red bold 52&amp;quot;
$ git config --global color.diff-highlight.newNormal &amp;quot;green bold&amp;quot;
$ git config --global color.diff-highlight.newHighlight &amp;quot;green bold 22&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>New theme</title>
      <link>http://blog.kerkerj.in/blog/new-theme/</link>
      <pubDate>Sun, 09 Oct 2016 00:47:31 +0800</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/new-theme/</guid>
      <description>&lt;p&gt;結果過了這麼久的一篇文就是把 theme 換掉了 XD&lt;/p&gt;

&lt;p&gt;可能再補個幾篇這一年有紀錄的一些小玩意兒吧 XDD&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://blog.kerkerj.in/about/</link>
      <pubDate>Sat, 08 Oct 2016 18:16:03 +0800</pubDate>
      
      <guid>http://blog.kerkerj.in/about/</guid>
      <description>&lt;p&gt;待補 (咦?)&lt;/p&gt;

&lt;p&gt;Click those icons above to know more about me. :P&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.kerkerj.in/imgs/uface.jpg&#34; alt=&#34;images&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Migrating to Hugo from Octopress</title>
      <link>http://blog.kerkerj.in/blog/migrating-to-hugo-from-octopress/</link>
      <pubDate>Sun, 03 May 2015 02:14:59 +0800</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/migrating-to-hugo-from-octopress/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://gohugo.io&#34;&gt;hugo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;l&gt;&lt;b&gt;hugo - 快速又現代的靜態網站產生器&lt;/b&gt;&lt;/l&gt;&lt;/p&gt;

&lt;p&gt;^^^ 這是 spf13 自己說的&lt;/p&gt;

&lt;p&gt;繼 spf13-vim 後又一個 spf13 出品的好東西 XD&lt;/p&gt;

&lt;p&gt;在靜態網站產生器中最廣為人知的應該就是 &lt;a href=&#34;http://jekyllrb.com/&#34;&gt;&lt;code&gt;Jekyll&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以及基於 &lt;code&gt;Jekyll&lt;/code&gt; 的 &lt;a href=&#34;http://octopress.org/&#34;&gt;&lt;code&gt;Octopress&lt;/code&gt;&lt;/a&gt; 了&lt;/p&gt;

&lt;p&gt;(關於靜態網站產生器，&lt;a href=&#34;http://www.sitepoint.com/6-static-blog-generators-arent-jekyll/&#34;&gt;這篇文章&lt;/a&gt; 介紹了六個除了 &lt;code&gt;Jekyll&lt;/code&gt; 以外的產生器)&lt;/p&gt;

&lt;h2 id=&#34;為什麼要用-hugo&#34;&gt;為什麼要用 &lt;code&gt;hugo&lt;/code&gt;？&lt;/h2&gt;

&lt;p&gt;雖然 &lt;code&gt;Jekyll&lt;/code&gt; / &lt;code&gt;Octopress&lt;/code&gt; 很紅資源多主題也不少&lt;/p&gt;

&lt;p&gt;但是缺點就是要使用它們就必須裝 &lt;code&gt;ruby&lt;/code&gt;、裝 &lt;code&gt;gem&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有在寫 &lt;code&gt;ruby&lt;/code&gt; 的人感覺應該還好&lt;/p&gt;

&lt;p&gt;沒在寫 &lt;code&gt;ruby&lt;/code&gt; 的光想像就覺得應該會被搞死&amp;hellip; XD&lt;/p&gt;

&lt;p&gt;而且覺得文章一多時在編譯的時候好慢&amp;hellip;&lt;/p&gt;

&lt;p&gt;用 &lt;code&gt;hugo&lt;/code&gt; 的好處就是因為他是用 &lt;code&gt;go&lt;/code&gt; 寫的&lt;/p&gt;

&lt;p&gt;執行速度飛快，而且只要下載一個 &lt;code&gt;binary&lt;/code&gt; 檔案後就可以操作了喲~&lt;/p&gt;

&lt;h2 id=&#34;基本-hugo-安裝與操作&#34;&gt;基本 &lt;code&gt;hugo&lt;/code&gt; 安裝與操作&lt;/h2&gt;

&lt;p&gt;首先先安裝 &lt;code&gt;hugo&lt;/code&gt; (我是用 &lt;code&gt;mac&lt;/code&gt; 的 &lt;code&gt;homebrew&lt;/code&gt;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用 &lt;code&gt;hugo&lt;/code&gt; 產生一個新的網站&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new site /path/to/the/site
e.g.
$ hugo new site /Users/kerkerj/my_hugo_blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到剛剛產生的網站目錄底下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/the/site
e.g.
$ cd /Users/kerkerj/my_hugo_blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;產生一些內容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new about.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或是一篇文章&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new post/first-post.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安裝主題&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone --recursive https://github.com/spf13/hugoThemes themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把 &lt;code&gt;hugo&lt;/code&gt; 跑起來!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --theme=hyde-x --buildDrafts --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指令說明:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--theme=hyde-x&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;指的是使用哪一個主題，可以在 &lt;code&gt;themes&lt;/code&gt; 資料夾裡找，並將 &lt;code&gt;hyde&lt;/code&gt; 替換掉就可以換主題，例如換成 &lt;code&gt;greyshade&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;--buildDrafts&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;hugo new post/first-post.md&lt;/code&gt; 預設會是草稿 (在 &lt;code&gt;first-post.md&lt;/code&gt; 裡會有 &lt;code&gt;draft=true&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;如果下 &lt;code&gt;--buildDrafts&lt;/code&gt; 的意思就是會把草稿也 build 出來讓你看到&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;--watch&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;如果在 server 開啟時，編輯文章並儲存的話，server 會幫你根據修改的內容重新產生網頁，&lt;/p&gt;

&lt;p&gt;不需要再下指令重新 build 一次&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;migrating-from-octopress&#34;&gt;Migrating from &lt;code&gt;octopress&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;我自己原本是用 &lt;code&gt;octopress&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;為了不要怕改壞原本的 &lt;code&gt;octopress&lt;/code&gt; 文章&lt;/p&gt;

&lt;p&gt;我把在 &lt;code&gt;octopress&lt;/code&gt; 的文章 (&lt;code&gt;source/_posts&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;全數複製一份到 &lt;code&gt;my_hugo_blog/content/post/&lt;/code&gt; 底下&lt;/p&gt;

&lt;p&gt;接著就試著跑 &lt;code&gt;hugo server&lt;/code&gt; 起來試試看&lt;/p&gt;

&lt;p&gt;當然是炸了一堆 ERROR 出來啦 XD&lt;/p&gt;

&lt;p&gt;以下是我遇到的幾個常見問題&lt;/p&gt;

&lt;h2 id=&#34;meta-data-的-date&#34;&gt;Meta-data 的 Date&lt;/h2&gt;

&lt;p&gt;這是我的錯誤訊息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ERROR: 2015/05/02 Failed to parse date &#39;2010-10-04 18:25&#39; in page post/2010-10-04-freebsd81-famp.md
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先瞭解一下文章的 meta-data 格式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;octopress&lt;/code&gt; 的是 &lt;code&gt;yaml&lt;/code&gt; 格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
title: &amp;quot;Setup wifi on raspberry pi2&amp;quot;
date: 2015-04-22 22:59:11 +0800
comments: true
categories: [raspberry]
keywords: [raspberry, pi, pi2, wifi]
description: 
---
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt; 的則是 &lt;code&gt;toml&lt;/code&gt; 格式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
date = &amp;quot;2015-05-02T02:27:21+08:00&amp;quot;
draft = true
title = &amp;quot;test&amp;quot;

+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在 &lt;code&gt;hugo&lt;/code&gt; 0.13 版開始也可以讀 &lt;code&gt;yaml&lt;/code&gt; 格式了&lt;/p&gt;

&lt;p&gt;(在 config 中可以設定 &lt;code&gt;metaDataFormat: &amp;quot;yaml&amp;quot;&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;不過比較麻煩的是 &lt;code&gt;date&lt;/code&gt; 這個屬性，兩邊長得並不太一樣&lt;/p&gt;

&lt;p&gt;&lt;code&gt;octopress&lt;/code&gt; 比較舊的是長這樣 &lt;code&gt;2010-10-04 18:25&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;新一點 (某一次更新後) 的長這樣 &lt;code&gt;2014-10-02 01:37:44 +0800&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不過不管怎樣，&lt;code&gt;hugo&lt;/code&gt; 都不吃&lt;/p&gt;

&lt;p&gt;因為 &lt;code&gt;hugo&lt;/code&gt; 的長這樣 &lt;code&gt;2015-05-02T02:27:21+08:00&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;囧了&lt;/p&gt;

&lt;p&gt;因此必須將 &lt;code&gt;octopress&lt;/code&gt; 的格式換成 &lt;code&gt;hugo&lt;/code&gt; 的&lt;/p&gt;

&lt;p&gt;接下來下的指令最好先 &lt;code&gt;git commit&lt;/code&gt; 一下後再做 XD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd my_hugo_blog/content/post/ 
$ find . -type f -exec sed -i &amp;quot;&amp;quot; -e &#39;s/date: \([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\).*$/date: \1/g&#39; {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個指令會將原本的 date 格式換成只有 &lt;code&gt;yyyy-mm-dd&lt;/code&gt; 的格式&lt;/p&gt;

&lt;p&gt;例如 &lt;code&gt;2014-10-02 01:37:44 +0800&lt;/code&gt; 換成只有 &lt;code&gt;2014-10-02&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;這樣 &lt;code&gt;hugo&lt;/code&gt; 就看得懂&lt;/p&gt;

&lt;h2 id=&#34;permallink-的問題&#34;&gt;permallink 的問題&lt;/h2&gt;

&lt;p&gt;當日期問題修好後，重開 server&lt;/p&gt;

&lt;p&gt;發現點擊文章標題進單篇文章網頁時會跳 404&lt;/p&gt;

&lt;p&gt;原因是 &lt;code&gt;hugo&lt;/code&gt; 預設產生的連結是&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://yoursite.com/post/2015-04-22-raspberry-pi2-remote-webcam/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而在 &lt;code&gt;octopress&lt;/code&gt; 是根據日期區分&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://yoursite.com/post/2015/04/22/raspberry-pi2-remote-webcam/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;這個問題的解法比較簡單&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;config.toml&lt;/code&gt; 加入這行就行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Permalinks]
	post = &amp;quot;/:year/:month/:day/:filename/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不過因為 &lt;code&gt;octopress&lt;/code&gt; 本身在產生檔案時就已經把日期加入檔名中&lt;/p&gt;

&lt;p&gt;(e.g. &lt;code&gt;2015-04-22-raspberry-pi2-remote-webcam.md&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;因此 &lt;code&gt;octopress&lt;/code&gt; 的文章連結看起來就會很長，例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;http://localhost:1313/2015/04/22/2015-04-22-raspberry-pi2-remote-webcam/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這時候就看要不要把檔名改掉啦&lt;/p&gt;

&lt;p&gt;例如把 &lt;code&gt;2015-04-22-raspberry-pi2-remote-webcam.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;改成 &lt;code&gt;raspberry-pi2-remote-webcam.md&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者可以試著改成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Permalinks]
	post = &amp;quot;/:year/:month/:day/:title/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不過我試了一下，會有機會因為標題有特殊符號或中文&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;e.g.  http://localhost:1313/2014/10/20/swift-d20---basic---%E6%8D%A8%E6%A3%84-storyboard-%E4%BD%BF%E7%94%A8%E7%B4%94%E7%A8%8B%E5%BC%8F%E7%A2%BC-%E7%9A%84%E6%96%B9%E5%BC%8F%E6%92%B0%E5%AF%AB-viewcontroller/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;產生出奇怪的資料夾名稱而導致該文章無法存取&lt;/p&gt;

&lt;p&gt;所以這個方式僅供參考，可以試試 XD&lt;/p&gt;

&lt;p&gt;BTW，我個人在撰寫文章時都沒有用到產生器的樣板語言，因此在轉換時比較沒遇到什麼問題&lt;/p&gt;

&lt;p&gt;上述問題解法的參考來源:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://nathanleclaire.com/blog/2014/12/22/migrating-to-hugo-from-octopress/&#34;&gt;Migrating to Hugo From Octopress&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://deeeet.com/writing/2014/12/25/hugo/&#34;&gt;OctopressからHugoへ移行した&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;設定檔-config-toml-config-yml-config-json&#34;&gt;設定檔 (config.toml, config.yml, config.json)&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt; 預設的是 &lt;code&gt;config.toml&lt;/code&gt;，也支援 &lt;code&gt;yaml&lt;/code&gt; 和 &lt;code&gt;json&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而 &lt;code&gt;hugo&lt;/code&gt; 讀取的順位是照上述順序&lt;/p&gt;

&lt;p&gt;如果是要將網頁讓 &lt;code&gt;GitHub&lt;/code&gt; host 的話，就必須使用 &lt;code&gt;config.yaml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因此我就把 &lt;code&gt;config.toml&lt;/code&gt; 換成 &lt;code&gt;config.yml&lt;/code&gt; 了 (也比較習慣)&lt;/p&gt;

&lt;p&gt;以下是我的 &lt;code&gt;config.yml&lt;/code&gt; 主要的設定&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl:            &amp;quot;http://blog.kerkerj.in/&amp;quot;
languageCode:       &amp;quot;en-us&amp;quot;
title:              &amp;quot;My New Hugo Site&amp;quot;

buildDrafts:        false
config:             &amp;quot;config.yml&amp;quot;
metaDataFormat:     &amp;quot;yaml&amp;quot;

permalinks:
  post:             &amp;quot;/blog/:year/:month/:day/:filename/&amp;quot;

theme:              &amp;quot;purehugo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定 &lt;code&gt;metaDataFormat: &amp;quot;yaml&amp;quot;&lt;/code&gt; 的話&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;hugo new&lt;/code&gt; 的文章 meta-data 都會是 &lt;code&gt;yaml&lt;/code&gt; 格式喔&lt;/p&gt;

&lt;p&gt;要查詢預設的參數在這 &lt;a href=&#34;http://gohugo.io/overview/configuration/&#34;&gt;Configuring Hugo&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;主題佈景-theme&#34;&gt;主題佈景 Theme&lt;/h2&gt;

&lt;p&gt;其實在 &lt;code&gt;hugo&lt;/code&gt; 裡比較讓我覺得麻煩的還是主題的挑選吧&lt;/p&gt;

&lt;p&gt;因為選擇實在不多&lt;/p&gt;

&lt;p&gt;我最喜歡的是在 &lt;code&gt;octopress&lt;/code&gt; 中的 &lt;a href=&#34;https://github.com/shashankmehta/greyshade&#34;&gt;greyshade&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;雖然 &lt;code&gt;spf13/hugoThemes&lt;/code&gt; 的 repo 中有人 porting，但是完成度似乎不高&lt;/p&gt;

&lt;p&gt;改 template 是應該沒什麼難度，照著改就好，不過&amp;hellip;實在沒這麼多時間 Orz&lt;/p&gt;

&lt;p&gt;而且 &lt;code&gt;hugo&lt;/code&gt; 在二月底 release 了 0.13 版，有一部分的主題佈景都不能動了 XD&lt;/p&gt;

&lt;p&gt;這邊列出我試過可以 work 的&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/herring-cove&#34;&gt;herring-cove&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/SenjinDarashiva/hugo-uno&#34;&gt;hugo-uno&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/zyro/hyde-x&#34;&gt;hyde-x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/dplesca/purehugo&#34;&gt;purehugo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/tmaiaroto/hugo-redlounge&#34;&gt;redlounge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/AlexFinn/simple-a&#34;&gt;simple-a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/marloncabrera/tachyons&#34;&gt;tachyons&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/roperzh/tinyce-hugo-theme&#34;&gt;tinyce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/keichi/vienna&#34;&gt;vienna&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;vienna&lt;/code&gt; 的 index list 壞掉了，不過 single page 能動，佈景也還算漂亮&lt;/p&gt;

&lt;p&gt;自己修一下應該就可以&lt;/p&gt;

&lt;p&gt;其實其他不少佈景也都是 index page 不能動，其他都能動&lt;/p&gt;

&lt;p&gt;另外在試的過程中，發現除非 repo 有特別說&lt;/p&gt;

&lt;p&gt;不然 &lt;code&gt;config.yml&lt;/code&gt; 的 &lt;code&gt;disqus&lt;/code&gt; 的 key 都是 &lt;code&gt;disqusShortname&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(因為有個佈景的 key 是 &lt;code&gt;disqus_short_name&lt;/code&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hyde-x&lt;/code&gt; 是最多人 star 的主題佈景，有八種色系可以選擇&lt;/p&gt;

&lt;p&gt;功能也蠻齊全，不想自己搞東搞西的話，建議就直接選這個主題&lt;/p&gt;

&lt;p&gt;(因為我最後 &lt;a href=&#34;https://github.com/dplesca/purehugo&#34;&gt;fork 人家的&lt;/a&gt; theme &lt;a href=&#34;https://github.com/kerkerj/purehugo&#34;&gt;自己改了一堆&lt;/a&gt; (遮臉) )&lt;/p&gt;

&lt;h2 id=&#34;syntax-highlight&#34;&gt;Syntax highlight&lt;/h2&gt;

&lt;p&gt;寫技術筆記的人應該對這個非常執著 XD&lt;/p&gt;

&lt;p&gt;我使用的主題是 &lt;code&gt;purehugo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不過他的 syntax highlight 是預設的常見的模式&lt;/p&gt;

&lt;p&gt;因此我就自己把他抽掉換成 &lt;a href=&#34;https://github.com/isagalaev/highlight.js&#34;&gt;&lt;code&gt;highlight.js&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt; 在 &lt;a href=&#34;http://gohugo.io/extras/highlighting/&#34;&gt;這篇文件&lt;/a&gt; 中有另外說明關於如何自訂 syntax highlight&lt;/p&gt;

&lt;h2 id=&#34;支援-disqus-ga-pagination-seo-robot-txt-favcon&#34;&gt;支援 (disqus, ga, pagination, SEO, robot.txt, favcon)&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;disqus&lt;/code&gt; 要看佈景有無支援，&lt;code&gt;GA&lt;/code&gt; 也是&lt;/p&gt;

&lt;p&gt;不過如果主題沒有的話，也是自己寫一個 partial 插進去就好&lt;/p&gt;

&lt;p&gt;另外 &lt;code&gt;pagination&lt;/code&gt; 也是在最新版 (0.13) 才加入，所以也要看佈景有沒有支援&lt;/p&gt;

&lt;p&gt;不然文章多的就會發現首頁往下捲捲不完&amp;hellip; XD&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SEO&lt;/code&gt; 的部分有人特別寫 partial &lt;a href=&#34;https://github.com/nozzle/hugo-snippets&#34;&gt;nozzle/hugo-snippets&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;自己寫在 theme 的 header.html 當然是最直覺的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;robot.txt&lt;/code&gt;、&lt;code&gt;favcon&lt;/code&gt; 就自己加進 &lt;code&gt;static&lt;/code&gt; 資料夾，再到 theme 裡面修改&lt;/p&gt;

&lt;h2 id=&#34;deploy&#34;&gt;Deploy&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;hugo&lt;/code&gt; 有一篇 &lt;a href=&#34;http://gohugo.io/tutorials/github-pages-blog/&#34;&gt;教學文&lt;/a&gt; 教你如何放在 &lt;code&gt;GitHub&lt;/code&gt; 上&lt;/p&gt;

&lt;p&gt;有兩種方式 (Project page or Personl page)&lt;/p&gt;

&lt;p&gt;不過都需要先在 &lt;code&gt;config.yml&lt;/code&gt; 加入以下資訊&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;---
contentdir: &amp;quot;content&amp;quot;
layoutdir: &amp;quot;layouts&amp;quot;
publishdir: &amp;quot;public&amp;quot;
indexes:
  category: &amp;quot;categories&amp;quot;
baseurl: &amp;quot;http://kerkerj.github.io/ or http://kerkerj.github.io/hugo_gh_blog/&amp;quot;
title: &amp;quot;Hugo Blog Template for GitHub Pages&amp;quot;
canonifyurls: true
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;project-page-e-g-http-your-github-account-github-io-hugo-gh-blog&#34;&gt;Project page: e.g. &lt;a href=&#34;http://your_github_account.github.io/hugo_gh_blog/&#34;&gt;http://your_github_account.github.io/hugo_gh_blog/&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;先處理好本機端 &lt;code&gt;hugo&lt;/code&gt; 的 blog，接著 &lt;code&gt;git init&lt;/code&gt; 並且 &lt;code&gt;commit&lt;/code&gt; 後&lt;/p&gt;

&lt;p&gt;加入 &lt;code&gt;gh-pages&lt;/code&gt; 這個 branch (&lt;a href=&#34;https://help.github.com/articles/creating-project-pages-manually/&#34;&gt;教學&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;接著回到 &lt;code&gt;master&lt;/code&gt;，照著下列步驟&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Fetch the deployment script into the root of your source tree, make it executable.
wget https://github.com/X1011/git-directory-deploy/raw/master/deploy.sh &amp;amp;&amp;amp; chmod +x deploy.sh

# For setting it up to build to a folder other than &amp;quot;dist&amp;quot;, see the options in deploy.sh.
# Build the site to /dist.
hugo -d dist

# Run the deploy.sh script installed above.
./deploy.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以 deploy 到 github project page 了&lt;/p&gt;

&lt;p&gt;存取網址就是 &lt;code&gt;http://your_github_account.github.io/hugo_gh_blog/&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;personal-page-e-g-http-kerkerj-github-io&#34;&gt;Personal page: e.g. &lt;a href=&#34;http://kerkerj.github.io/&#34;&gt;http://kerkerj.github.io/&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;建立兩個 repo，一個拿來放 &lt;code&gt;my_hugo_blog&lt;/code&gt; 本機端的資料&lt;/p&gt;

&lt;p&gt;一個就是 &lt;code&gt;your_github_account.github.io&lt;/code&gt; 這個 repo&lt;/p&gt;

&lt;p&gt;會拿來放 &lt;code&gt;my_hugo_blog/public&lt;/code&gt; 資料夾裡的資料&lt;/p&gt;

&lt;p&gt;所以就必須先在 &lt;code&gt;GitHub&lt;/code&gt; 上有 &lt;code&gt;your_github_account.github.io&lt;/code&gt; 這個 repo&lt;/p&gt;

&lt;p&gt;這邊會比較簡單&lt;/p&gt;

&lt;p&gt;以剛剛的例子的話就會是 &lt;code&gt;my_hugo_blog&lt;/code&gt;，這個資料夾裡放了所有剛剛 &lt;code&gt;hugo&lt;/code&gt; 產生的資料&lt;/p&gt;

&lt;p&gt;先處理 &lt;code&gt;deploy.sh&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;可以直接自己把以下內容存成 &lt;code&gt;deploy.sh&lt;/code&gt;，並 &lt;code&gt;chmod +x deploy.sh&lt;/code&gt; 使其可執行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
# Deploy hugo site to GitHug personal page
 
echo -e &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m&amp;quot;
 
# Build the project. 
hugo # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`
 
# Go To Public folder
cd public
# Add changes to git.
git add -A
 
# Commit changes.
msg=&amp;quot;rebuilding site `date`&amp;quot;
if [ $# -eq 1 ]
  then msg=&amp;quot;$1&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;
 
# Push source and build repos.
git push origin master
 
# Come Back
cd ..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或下載 &lt;code&gt;deploy.sh&lt;/code&gt; (同時使其可執行)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget https://gist.githubusercontent.com/kerkerj/18b18a24af8e8a0ec0ee/raw/654dfb7faaa23db24f707c4d746319e458157d89/deploy.sh &amp;amp;&amp;amp; chmod +x deploy.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有使用 theme，記得修改 &lt;code&gt;deploy.sh&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;把&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;換成&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo -t yourtheme # if using a theme, replace by `hugo -t &amp;lt;yourtheme&amp;gt;`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以現在已經處理好的東西有:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;my_hugo_blog&lt;/code&gt; 資料夾以及可執行的 &lt;code&gt;deploy.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;已經在 &lt;code&gt;GitHub&lt;/code&gt; 上有 &lt;code&gt;your_github_account.github.io&lt;/code&gt; 這個 repo&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;(p.s. 如果有要設定 CNAME 什麼的，就把 CNAME 檔案放 &lt;code&gt;static&lt;/code&gt; 這個資料夾裡)&lt;/p&gt;

&lt;p&gt;接下來，先將 server 跑起來&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --watch -t &amp;lt;yourtheme&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把你想要的網站調整好後，關掉 server 並將 &lt;code&gt;public&lt;/code&gt; 資料夾刪除 (等等會重新在 deploy.sh 中產生)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ rm -rf public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著把 &lt;code&gt;GitHub&lt;/code&gt; 的 repo 加到 &lt;code&gt;public&lt;/code&gt; 裡&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git submodule add git@github.com:&amp;lt;username&amp;gt;/&amp;lt;username&amp;gt;.github.io.git public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後就 deploy 到 github 上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 自動產生 commit message
$ ./deploy.sh 

# 如果要自訂 commit message 的話
$ ./deploy.sh &amp;quot;Your commit message&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是第一次 deploy 到 &lt;code&gt;GitHub&lt;/code&gt; 的話，需要等待大約 15 ~ 20 分鐘&lt;/p&gt;

&lt;p&gt;才會在 &lt;code&gt;GitHub&lt;/code&gt; 上看到你的網站喲&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Raspberry Pi2 remote webcam</title>
      <link>http://blog.kerkerj.in/blog/raspberry-pi2-remote-webcam/</link>
      <pubDate>Wed, 22 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/raspberry-pi2-remote-webcam/</guid>
      <description>&lt;p&gt;如題~&lt;/p&gt;

&lt;p&gt;先假設 pi2 本身的 IP 是 &lt;code&gt;192.168.1.200&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;首先先進去 server 來更新一下~&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再來就裝 &lt;a href=&#34;http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome&#34;&gt;motion&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;他其實是一個 motion detector，不過也可以拿來當作 web cam 用的 streaming server XD&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo apt-get install motion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;編輯設定檔 &lt;code&gt;/etc/motion/motion.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo vi /etc/motion/motion.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;找到以下幾個值，並分別改成下面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;daemon = ON
webcam_localhost = OFF
control_localhost = OFF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;webcam_localhost&lt;/code&gt; 是 streaming 介面&lt;/p&gt;

&lt;p&gt;&lt;code&gt;control_localhost&lt;/code&gt; 是設定介面&lt;/p&gt;

&lt;p&gt;如果要改預設 port，就找 &lt;code&gt;webcam_port&lt;/code&gt;, or &lt;code&gt;control_port&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;最後設定將 service 啟動&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo vi /etc/default/motion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;將 no 改成 yes&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;start_motion_daemon = yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;啟動 service&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ sudo service motion start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;motion 這個 service 預設的 port 是 8080 / 8081 (可以在前述的設定檔更改)&lt;/p&gt;

&lt;p&gt;開啟瀏覽器, 連入 &lt;code&gt;http://192.168.1.200:8080&lt;/code&gt; or &lt;code&gt;http://192.168.1.200:8081&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;這邊會有個小問題，就是連 8080 時會很正常&lt;/p&gt;

&lt;p&gt;但是 8081 時如果是用 chrome，則怎麼都進不去&lt;/p&gt;

&lt;p&gt;後來發現 &lt;a href=&#34;http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2013x09x01x104741&#34;&gt;這篇&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;他說 Chrome 不再支援 raw MJPEG streams 了&lt;/p&gt;

&lt;p&gt;所以就是用其他瀏覽器開吧, 我是用 Safari :D&lt;/p&gt;

&lt;p&gt;記得要和你的 pi2 在同一個 wifi 環境下~&lt;/p&gt;

&lt;p&gt;剩下的還有許多設定可以玩～ 改天再來慢慢玩&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Setup wifi on raspberry pi2</title>
      <link>http://blog.kerkerj.in/blog/setup-wifi-on-raspberry-pi2/</link>
      <pubDate>Wed, 22 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/setup-wifi-on-raspberry-pi2/</guid>
      <description>&lt;p&gt;(這是篇筆記)&lt;/p&gt;

&lt;p&gt;前陣子從前同事那接手了一塊 raspberry pi2 的板子&lt;/p&gt;

&lt;p&gt;想要用 wifi 來連網，於是就買了一個 usb 無線網卡&lt;/p&gt;

&lt;p&gt;型號是:&lt;/p&gt;

&lt;p&gt;TP-LINK TL-WN725N 150MbpsUSB無線網卡 (&lt;a href=&#34;http://24h.pchome.com.tw/prod/DRAF4Z-A75333252&#34;&gt;pchome連結&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;一開始當然還是必須先插網路線，&lt;code&gt;ssh&lt;/code&gt; 進去後&lt;/p&gt;

&lt;p&gt;先檢查 &lt;code&gt;pi2&lt;/code&gt; 的 &lt;code&gt;kernel&lt;/code&gt; 版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ uname -r
3.18.7-v7+ # 這是我的版本
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著根據這個 &lt;a href=&#34;https://github.com/lwfinger/rtl8188eu/&#34;&gt;repo&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;將韌體載下來放到 /lib/firmware 裡&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo wget https://github.com/lwfinger/rtl8188eu/raw/c83976d1dfb4793893158461430261562b3a5bf0/rtl8188eufw.bin -O /lib/firmware/rtlwifi/rtl8188eufw.bin 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再來設定 pi2 的網路&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ifconfig
eth0      Link encap:Ethernet  
lo        Link encap:Local Loopback
wlan0     Link encap:Ethernet 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果網卡有裝成功，應該就會有 &lt;code&gt;wlan0&lt;/code&gt; 或是 &lt;code&gt;wlanX&lt;/code&gt; 之類的 (X 是數字)&lt;/p&gt;

&lt;p&gt;最後就是手動掃描無線網路，並設定連線值囉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo iwlist scan =&amp;gt; 掃描無線網路 AP
wlan0     Scan completed :
          Cell 01 - Address: XX:XX:XX:XX:XX:XX
                    ESSID:&amp;quot;GGININDER&amp;quot;
          Cell 02 - Address: XX:XX:XX:XX:XX:XX
                    ESSID:&amp;quot;TP-LINK_F5566&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;連線的 &lt;code&gt;SSID&lt;/code&gt; 就找 &lt;code&gt;Cell&lt;/code&gt; 裡的 &lt;code&gt;ESSID&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(通常應該會記得自己家的 AP 啦，可以用來確認一下)&lt;/p&gt;

&lt;p&gt;開啟 &lt;code&gt;/etc/network/interfaces&lt;/code&gt; 來寫入連線值&lt;/p&gt;

&lt;p&gt;我的 AP 的加密機制是 WPA/WPA2，所以使用下面的方式連線&lt;/p&gt;

&lt;p&gt;若是其他方式 (e.g. WEP) 可以參考 &lt;a href=&#34;http://inpega.blogspot.tw/2013/09/blog-post_15.html&#34;&gt;這篇&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ vi /etc/network/interfaces
auto lo

iface lo inet loopback
iface eth0 inet dhcp

# 重點是下面這段

# 允許熱插拔 wlan0 這個介面
allow-hotplug wlan0 

# 預設設定為 dhcp
iface default inet dhcp

# 設定 wlan0 這張介面卡為 DHCP 自動取得 IP
iface wlan0 inet dhcp

# 你的 AP 的 SSID
wpa-ssid &amp;quot;GGININDER&amp;quot;

# 你的 AP 的密碼
wpa-psk &amp;quot;password&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;設定好後，重新啟動 wlan0 介面就可以連線囉&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo ifdown wlan0
$ sudo ifup wlan0
$ ifconfig wlan0 # 確認是否取得 IP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;reference:&lt;/p&gt;

&lt;p&gt;raspberry pi forum: &lt;a href=&#34;http://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;amp;t=62371&amp;amp;start=475&#34;&gt;http://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;amp;t=62371&amp;amp;start=475&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;網路設定: &lt;a href=&#34;http://inpega.blogspot.tw/2013/09/blog-post_15.html&#34;&gt;http://inpega.blogspot.tw/2013/09/blog-post_15.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ithome 鐵人賽 - 規劃</title>
      <link>http://blog.kerkerj.in/blog/ithome-%E9%90%B5%E4%BA%BA%E8%B3%BD---%E8%A6%8F%E5%8A%83/</link>
      <pubDate>Sat, 01 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/ithome-%E9%90%B5%E4%BA%BA%E8%B3%BD---%E8%A6%8F%E5%8A%83/</guid>
      <description>&lt;p&gt;半個月前不怕死的報名了 ithome 的&lt;a href=&#34;http://ithelp.ithome.com.tw/ironman7/app/index&#34;&gt;連續三十天不中斷發文鐵人賽&lt;/a&gt;，&lt;/p&gt;

&lt;p&gt;還報名了兩個主題，真的是太誇張了&amp;hellip;&lt;/p&gt;

&lt;p&gt;但是由於 ithome 的編輯器其實排版起來沒有很漂亮，&lt;/p&gt;

&lt;p&gt;因此決定利用這邊先發文，再轉文到 ithome 的方式來處理，&lt;/p&gt;

&lt;p&gt;比較順手一些，順便在這篇文章貼上規劃方向，topic 可能隨時會變，但大方向不變&lt;/p&gt;

&lt;p&gt;第一次寫的主題都幾乎不是自己專精的技術，&lt;/p&gt;

&lt;p&gt;規劃表如下： (Evernote 連結)&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.evernote.com/l/AFFz7an43x1K46hErAgyJdD5K9BuFFMN9Dg&#34;&gt;https://www.evernote.com/l/AFFz7an43x1K46hErAgyJdD5K9BuFFMN9Dg&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;因此若有錯誤也請有看到的大大們多多幫忙指正囉！&lt;/p&gt;

&lt;p&gt;有時候會因為比較忙，可能文章比較精簡一些，還請大家多多包涵 :P&lt;/p&gt;

&lt;p&gt;有任何文章更新也會同步在此篇文章中!&lt;/p&gt;

&lt;p&gt;##RESTful API Service:
Day1  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/02/2014-10-01-api-d1/&#34;&gt;[API-d1] - 定義 1 - 什麼是 REST/RESTful?&lt;/a&gt;&lt;br /&gt;
Day2  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/02/2014-10-02-api-d2/&#34;&gt;[API-d2] - 定義 2 - RESTful 的優點與要求&lt;/a&gt;&lt;br /&gt;
Day3  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/03/2014-10-03-api-d3/&#34;&gt;[API-d3] - 使用時機與實際 API 參考&lt;/a&gt;&lt;br /&gt;
Day4  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/04/2014-10-04-api-d4/&#34;&gt;[API-d4] - 使用技術與工具介紹及原因&lt;/a&gt;&lt;br /&gt;
Day5  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/05/2014-10-05-api-d5/&#34;&gt;[API-d5] - [Server 番外篇] 建立自己的本機虛擬伺服器 1 - Vagrant + VirtualBox 安裝&lt;/a&gt;&lt;br /&gt;
Day6  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/06/2014-10-06-api-d6/&#34;&gt;[API-d6] - [Server 番外篇] 建立自己的本機虛擬伺服器 2 - Ubuntu 基本設定與安裝 Node.js, MongoDB &lt;/a&gt;&lt;br /&gt;
Day7  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/07/2014-10-07-api-d7/&#34;&gt;[API-d7] - [Server 番外篇] 建立自己的本機虛擬伺服器 3 - 打包環境&lt;/a&gt;&lt;br /&gt;
Day8  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/08/2014-10-08-api-d8/&#34;&gt;[API-d8] - Node.js - Hello World!&lt;/a&gt;&lt;br /&gt;
Day9  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/09/2014-10-09-api-d9/&#34;&gt;[API-d9] - NVM 與 NPM 使用&lt;/a&gt;&lt;br /&gt;
Day10 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/10/2014-10-10-api-d10/&#34;&gt;[API-d10] - Express - Hello World!&lt;/a&gt;&lt;br /&gt;
Day11 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/11/2014-10-11-api-d11/&#34;&gt;[API-d11] - MongoDB - Hello World!&lt;/a&gt;&lt;br /&gt;
Day12 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/12/2014-10-12-api-d12/&#34;&gt;[API-d12] - MongoDB - Hello World! (Client-side) &lt;/a&gt;&lt;br /&gt;
Day13 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/13/2014-10-13-api-d13/&#34;&gt;[API-d13] - [Javascript 番外篇] Javascript require/ module/ Module Pattern&lt;/a&gt;&lt;br /&gt;
Day14 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/14/2014-10-14-api-d14/&#34;&gt;[API-d14] - [Javascript 番外篇] Javascript function scopes 和 closures&lt;/a&gt;&lt;br /&gt;
Day15 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/15/2014-10-15-api-d15/&#34;&gt;[API-d15] - [Javascript 番外篇] Javascript callback, event&lt;/a&gt;&lt;br /&gt;
Day16 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/16/2014-10-16-api-d16/&#34;&gt;[API-d16] - 實戰開發 - 設定主題及規劃&lt;/a&gt;&lt;br /&gt;
Day17 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/17/2014-10-17-api-d17/&#34;&gt;[API-d17] - 實戰開發 - 專案結構&lt;/a&gt;&lt;br /&gt;
Day18 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/18/2014-10-18-api-d18/&#34;&gt;[API-d18] - 實戰開發 - 套件模組&lt;/a&gt;&lt;br /&gt;
Day19 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/19/2014-10-19-api-d19/&#34;&gt;[API-d19] - 實戰開發 - index &amp;amp; route &amp;amp; http status code&lt;/a&gt;&lt;br /&gt;
Day20 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/20/2014-10-20-api-d20/&#34;&gt;[API-d20] - 實戰開發 - Routes 2, get params and request data&lt;/a&gt;&lt;br /&gt;
Day21 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/21/2014-10-21-api-d21/&#34;&gt;[API-d21] - 實戰開發 - 新增 TODO task API with mongoose&lt;/a&gt;&lt;br /&gt;
Day22 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/22/2014-10-22-api-d22/&#34;&gt;[API-d22] - 實戰開發 - 讀取 TODO task API with mongoose&lt;/a&gt;&lt;br /&gt;
Day23 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/23/2014-10-23-api-d23/&#34;&gt;[API-d23] - 實戰開發 - 修改 TODO task API with mongoose&lt;/a&gt;&lt;br /&gt;
Day24 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/24/2014-10-24-api-d24/&#34;&gt;[API-d24] - 實戰開發 - 刪除 TODO task API with mongoose&lt;/a&gt;&lt;br /&gt;
Day25 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/25/2014-10-25-api-day25/&#34;&gt;[API-day25] - 實戰開發 - 處理 404 &amp;amp; 500&lt;/a&gt;&lt;br /&gt;
Day26 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/26/2014-10-26-api-d26/&#34;&gt;[API-d26] - 實戰開發 - API-key&lt;/a&gt;&lt;br /&gt;
Day27 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/27/2014-10-27-api-d27/&#34;&gt;[API-d27] - 實戰開發 - log 處理 及 config (db, apikey)&lt;/a&gt;&lt;br /&gt;
Day28 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/28/2014-10-28-api-d28/&#34;&gt;[API-d28] - 實戰開發 - 發佈 - forever&lt;/a&gt;&lt;br /&gt;
Day29 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/29/2014-10-29-api-d29/&#34;&gt;[API-d29] - 實戰開發 - 發佈 - nginx&lt;/a&gt;&lt;br /&gt;
Day30 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/30/2014-10-30-api-d30/&#34;&gt;[API-d30] - 總結&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##Swift:
Day1  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/02/2014-10-02-swift-d1/&#34;&gt;[Swift-d1] - 介紹&lt;/a&gt;&lt;br /&gt;
Day2  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/02/2014-10-02-swift-d2/&#34;&gt;[Swift-d2] - 安裝及 Hello World!&lt;/a&gt;&lt;br /&gt;
Day3  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/03/2014-10-03-swift-d3/&#34;&gt;[Swift-d3] - Playground - 變數與常數, 註解, 基本資料型別&lt;/a&gt;&lt;br /&gt;
Day4  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/04/2014-10-04-swift-d4/&#34;&gt;[Swift-d4] - Playground - Optional, ! and ? &lt;/a&gt;&lt;br /&gt;
Day5  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/05/2014-10-05-swift-d5/&#34;&gt;[Swift-d5] - Playground - Array, Dictionary, Controll Flow&lt;/a&gt;&lt;br /&gt;
Day6  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/06/2014-10-06-swift-d6/&#34;&gt;[Swift-d6] - Playground - function&lt;/a&gt;&lt;br /&gt;
Day7  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/07/2014-10-07-swift-d7/&#34;&gt;[Swift-d7] - Playground - Closures&lt;/a&gt;&lt;br /&gt;
Day8  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/08/2014-10-08-swift-d8/&#34;&gt;[Swift-d8] - Playground - Enumerations&lt;/a&gt;&lt;br /&gt;
Day9  -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/09/2014-10-09-swift-d9/&#34;&gt;[Swift-d9] - Playground - Class, Struct&lt;/a&gt;&lt;br /&gt;
Day10 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/10/2014-10-10-swift-d10/&#34;&gt;[Swift-d10] 延伸閱讀&lt;/a&gt;&lt;br /&gt;
Day11 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/11/2014-10-11-swift-d11/&#34;&gt;[Swift-d11] - Basic - Hello World!&lt;/a&gt;&lt;br /&gt;
Day12 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/12/2014-10-12-swift-d12/&#34;&gt;[Swift-d12] - Basic - 基本元件 (Label, Button, UIColor, 文字輸入框)&lt;/a&gt;&lt;br /&gt;
Day13 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/13/2014-10-13-swift-d13/&#34;&gt;[Swift-d13] - Basic - Navigation View 1 + ViewController&lt;/a&gt;&lt;br /&gt;
Day14 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/14/2014-10-14-swift-d14/&#34;&gt;[Swift-d14] - Basic - Navigation View 2 + ViewController&lt;/a&gt;&lt;br /&gt;
Day15 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/15/2014-10-15-swift-d15/&#34;&gt;[Swift-d15] - Basic - Table View 1 直接給值 datasource, (table view scroll)&lt;/a&gt;&lt;br /&gt;
Day16 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/16/2014-10-16-swift-d16/&#34;&gt;[Swift-d16] - Basic - Table View 2 換頁 (delegate)&lt;/a&gt;&lt;br /&gt;
Day17 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/17/2014-10-17-swift-d17/&#34;&gt;[Swift-d17] - Basic - Navigation View + TableView&lt;/a&gt;&lt;br /&gt;
Day18 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/18/2014-10-18-swift-d18/&#34;&gt;[Swift-d18] - Basic - Customize TableViewCell&lt;/a&gt;&lt;br /&gt;
Day19 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/19/2014-10-19-swift-d19/&#34;&gt;[Swift-d19] - Basic - 橋接第三方 Objc library - Reachability and Bridge.h&lt;/a&gt;&lt;br /&gt;
Day20 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/20/2014-10-20-swift-d20/&#34;&gt;[Swift-d20] - Basic - 捨棄 Storyboard 使用純程式碼 的方式撰寫 ViewController&lt;/a&gt;&lt;br /&gt;
Day21 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/21/2014-10-21-swift-d21/&#34;&gt;[Swift-d21] - 實戰開發 - TODOList - 前置設定&lt;/a&gt;&lt;br /&gt;
Day22 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/22/2014-10-22-swift-d22/&#34;&gt;[Swift-d22] - 實戰開發 - TODOList - Show View 1&lt;/a&gt;&lt;br /&gt;
Day23 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/23/2014-10-23-swift-d23/&#34;&gt;[Swift-d23] - 實戰開發 - TODOList - Show View 2, Delete View&lt;/a&gt;&lt;br /&gt;
Day24 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/24/2014-10-24-swift-d24/&#34;&gt;[Swift-d24] - 實戰開發 - TODOList - Create View&lt;/a&gt;&lt;br /&gt;
Day25 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/25/2014-10-25-swift-day25/&#34;&gt;[Swift-day25] - 實戰開發 - TODOList - Update View&lt;/a&gt;&lt;br /&gt;
Day26 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/26/2014-10-26-swift-d26/&#34;&gt;[Swift-d26] - 實戰開發 - TODOList - API 前置資料準備&lt;/a&gt;&lt;br /&gt;
Day27 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/27/2014-10-27-swift-d27/&#34;&gt;[Swift-d27] - 實戰開發 - TODOList - API 2 讀取清單資料&lt;/a&gt;&lt;br /&gt;
Day28 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/28/2014-10-29-swift-d28/&#34;&gt;[Swift-d28] - 實戰開發 - TODOList - API 3 新增與更新&lt;/a&gt;&lt;br /&gt;
Day29 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/29/2014-10-29-swift-d29/&#34;&gt;[Swift-d29] - 實戰開發 - TODOList - API 4 刪除&lt;/a&gt;&lt;br /&gt;
Day30 -  &lt;a href=&#34;http://kerkerj.github.io/blog/2014/10/30/2014-10-30-swift-d30/&#34;&gt;[Swift-d30] - 總結&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[API-d30] - 總結</title>
      <link>http://blog.kerkerj.in/blog/api-d30---%E7%B8%BD%E7%B5%90/</link>
      <pubDate>Thu, 30 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/api-d30---%E7%B8%BD%E7%B5%90/</guid>
      <description>&lt;p&gt;總結三十天下來的 Restful API service 建置&lt;/p&gt;

&lt;p&gt;其實接觸到的東西很廣泛&lt;/p&gt;

&lt;p&gt;從 server 端到程式端，還有虛擬機器的使用都有沾到邊&lt;/p&gt;

&lt;p&gt;其實不管是哪個領域都是要一點一滴累積起來的&lt;/p&gt;

&lt;p&gt;以這次的開發技術來說，&lt;/p&gt;

&lt;p&gt;vagrant 方便在於我在和別人共享 server 環境時非常方便&lt;/p&gt;

&lt;p&gt;自己在架測試環境時也可以先將乾淨的 web serser 打包起來&lt;/p&gt;

&lt;p&gt;供日後隨時要用時開起來馬上 deploy 就可以使用&lt;/p&gt;

&lt;p&gt;另外加上方便的網路設定，&lt;/p&gt;

&lt;p&gt;在測試時非常方便&lt;/p&gt;

&lt;p&gt;另外則是 nodejs，&lt;/p&gt;

&lt;p&gt;這次會選擇 nodejs 主要也是想進入 javascript 的世界&lt;/p&gt;

&lt;p&gt;nodejs 若作為一個後端程式語言來說，我認為是非常輕量且入門非常簡單&lt;/p&gt;

&lt;p&gt;套一句最近常聽到的話&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript is everywhere&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不管是網頁前後端，nodejs 還可以拿來寫桌面應用、嵌入式系統&lt;/p&gt;

&lt;p&gt;應用領域非常廣泛&lt;/p&gt;

&lt;p&gt;也希望這門語言能夠更標準化，擺脫歷史包袱&lt;/p&gt;

&lt;p&gt;看最近幾年的發展，其實我認為是勢在必行的&lt;/p&gt;

&lt;p&gt;只缺一個領頭羊來帶領大家前往偉大的航道了! XD&lt;/p&gt;

&lt;p&gt;希望三十天的分享能給大家帶來不一樣的感受~&lt;/p&gt;

&lt;p&gt;對了突然想到一件事，這個主題的副標最後一句是想要和 APP 結合&lt;/p&gt;

&lt;p&gt;APP 在隔壁棚啦 XD&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Swift-d30] - 總結</title>
      <link>http://blog.kerkerj.in/blog/swift-d30---%E7%B8%BD%E7%B5%90/</link>
      <pubDate>Thu, 30 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/swift-d30---%E7%B8%BD%E7%B5%90/</guid>
      <description>&lt;p&gt;30 天下來其實中間受到不少人幫忙&lt;/p&gt;

&lt;p&gt;因為第一次寫 iOS 程式，對於 iOS 的基本運作流程還是詢問了不少同事&lt;/p&gt;

&lt;p&gt;包含在隔壁棚用 Cocos2d 寫 2D 遊戲的 Andy&lt;/p&gt;

&lt;p&gt;還有同事 Henry 和 Felix 都給予了很大的幫忙&lt;/p&gt;

&lt;p&gt;最後這隻小 app 其實 code 的品質並沒有很好&lt;/p&gt;

&lt;p&gt;主要還是因為寫來 demo 用的，以及老實講也沒什麼時間寫&amp;hellip;&lt;/p&gt;

&lt;p&gt;報兩個組別真的是很鐵人哪&lt;/p&gt;

&lt;p&gt;還看到隔壁棚一次報三四個主題的大大&lt;/p&gt;

&lt;p&gt;真是太厲害了&lt;/p&gt;

&lt;p&gt;假設明年還會參賽的話，應該還是會以單一技術來鑽研吧!&lt;/p&gt;

&lt;p&gt;Swift 有蠻多特性是 Objective-C 所沒有的&lt;/p&gt;

&lt;p&gt;如果有想在新專案嘗試的話&lt;/p&gt;

&lt;p&gt;最好還是先多看看網路上的比較&lt;/p&gt;

&lt;p&gt;避免踩到雷&lt;/p&gt;

&lt;p&gt;像有一點是我們同事曾經踩到的雷&lt;/p&gt;

&lt;p&gt;就是 NSDictionary V.S. Dictionary&lt;/p&gt;

&lt;p&gt;兩者的速度可以差到 5, 6 倍以上&lt;/p&gt;

&lt;p&gt;網路上搜尋也會發現有人在討論 Swift Dictionary 的效能差異&lt;/p&gt;

&lt;p&gt;若要在新專案使用還是要查詢一下避免掉一些問題&lt;/p&gt;

&lt;p&gt;另外還有就是 Swift on Xcode 的穩定度還是有待加強&amp;hellip;&lt;/p&gt;

&lt;p&gt;總而言之, 30 天結束了，ya!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[API-d29] - 實戰開發 - 發佈 - nginx</title>
      <link>http://blog.kerkerj.in/blog/api-d29---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---%E7%99%BC%E4%BD%88---nginx/</link>
      <pubDate>Wed, 29 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/api-d29---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---%E7%99%BC%E4%BD%88---nginx/</guid>
      <description>&lt;p&gt;接下來這篇就會比較偏 server 設定了！&lt;/p&gt;

&lt;p&gt;nginx 是一套伺服器軟體，和 apache 並駕齊驅&lt;/p&gt;

&lt;p&gt;(其實我覺得 nginx &amp;gt;&amp;gt;&amp;gt; apache XD)&lt;/p&gt;

&lt;p&gt;主要是 nginx 清量快速&lt;/p&gt;

&lt;p&gt;我們要拿他幫 nodejs 處理接收 request 的部分，再將 request 導往 nodejs&lt;/p&gt;

&lt;p&gt;所以感覺就會如下圖:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-18%2013.14.16.png&#34; alt=&#34;image&#34; /&gt;&lt;/p&gt;

&lt;p&gt;可以讓 nginx 當作是 load balancer,&lt;/p&gt;

&lt;p&gt;透過 reverse proxy 的方式轉發 request 給 nodejs, 讓 nginx 承受流量&lt;/p&gt;

&lt;p&gt;這就是我們今天要做的事情，&lt;/p&gt;

&lt;p&gt;所以首先，我們就要先裝 nginx，因此就先進虛擬機吧!&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ sudo apt-get update &amp;amp;&amp;amp; sudo apt-get upgrade -y
$ sudo apt-get install nginx 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣就會安裝一個 nginx 了!&lt;/p&gt;

&lt;p&gt;Nginx 的設定檔都是放在 &lt;code&gt;/etc/nginx/&lt;/code&gt; 底下&lt;/p&gt;

&lt;p&gt;個別網站的設定放在 &lt;code&gt;/etc/nginx/sites-available&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果要讓該網站上線，則會將 &lt;code&gt;/etc/nginx/sites-available&lt;/code&gt; 的設定檔 link 到 &lt;code&gt;/etc/nginx/sites-enable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;因此若想自己新增設定檔的話，慣例是會在 available 新增，然後再 link 到 &lt;code&gt;enable&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果我們進到 &lt;code&gt;/etc/nginx/sites-enable&lt;/code&gt; 的話，裡面應該已經有一個 &lt;code&gt;default&lt;/code&gt; 的設定檔了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo vim /etc/nginx/sites-enable/default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;內容應該是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server {
        listen 80 default_server;
        listen [::]:80 default_server ipv6only=on;

        root /usr/share/nginx/html;
        index index.html index.htm;

        # Make site accessible from http://localhost/
        server_name localhost;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
                # Uncomment to enable naxsi on this location
                # include /etc/nginx/naxsi.rules
        }

        # Only for nginx-naxsi used with nginx-naxsi-ui : process denied requests
        #location /RequestDenied {
        #       proxy_pass http://127.0.0.1:8080;
        #}
        
        ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;將設定檔改成如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream nodejs {
  server 127.0.0.1:3000;
  #server 127.0.0.1:3001;
}

server {
    listen 80;

    server_name localhost;

    location / {
        proxy_pass http://nodejs;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &#39;upgrade&#39;;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解釋一下以下這段:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;upstream nodejs {
  server 127.0.0.1:3000;
  #server 127.0.0.1:3001;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面這段則是 proxy pass 的部分, 會將 &lt;code&gt;/&lt;/code&gt; 的流量導到 nodejs 的 server cluster 裡面，不過因為我們現在只有一台 server 開起來，所以只會被導到 3000 port 的那台機器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location / {
        proxy_pass http://nodejs;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection &#39;upgrade&#39;;
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果 nodejs server 的承載量不夠，可以開好幾檯，只要 port 不一樣即可&lt;/p&gt;

&lt;p&gt;這樣就可以建立一個 nodejs cluster&lt;/p&gt;

&lt;p&gt;再來使用 forever 開啓 nodejs server&lt;/p&gt;

&lt;p&gt;再重新開啟 nginx&lt;/p&gt;

&lt;p&gt;使用 postman 戳戳看 API&lt;/p&gt;

&lt;p&gt;就成功囉~~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Swift-d29] - 實戰開發 - TODOList - API 4 刪除</title>
      <link>http://blog.kerkerj.in/blog/swift-d29---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---todolist---api-4-%E5%88%AA%E9%99%A4/</link>
      <pubDate>Wed, 29 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/swift-d29---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---todolist---api-4-%E5%88%AA%E9%99%A4/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day29&#34;&gt;Github link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;今天要處理刪除&lt;/p&gt;

&lt;p&gt;其實超簡單的&lt;/p&gt;

&lt;p&gt;只是想偷懶一下 XD&lt;/p&gt;

&lt;p&gt;一樣將下列程式碼新增到 RestApi class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func deleteTodoList(completionHandler: ((NSDictionary!, NSError!) -&amp;gt; Void)!, todoId: String) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: NSURL(string: &amp;quot;http://192.168.1.158:3000/user/kerkerj/todos/\(todoId)&amp;quot;)!)
        request.HTTPMethod = &amp;quot;DELETE&amp;quot;
        
        var err: NSError?
        request.addValue(&amp;quot;application/json&amp;quot;, forHTTPHeaderField: &amp;quot;Content-Type&amp;quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &amp;quot;API-Key&amp;quot;)
        
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&amp;gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;amp;error) as NSDictionary
            
            println(json)
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;回到 ViewController 中的 tableView commitEditingStyle 的方法中&lt;/p&gt;

&lt;p&gt;將其更新為:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
        
        api.deleteTodoList({data, err -&amp;gt; Void in
            let alert = UIAlertView()
            alert.title = &amp;quot;Alert&amp;quot;
            alert.addButtonWithTitle(&amp;quot;Ok&amp;quot;)
            
            if (err != nil) {
                alert.message = &amp;quot;Failed to delete: \(err)&amp;quot;
                alert.show()
            } else {
                alert.message = &amp;quot;ok!&amp;quot;
                
                self.fakeData.removeAtIndex(indexPath.row)
                
                dispatch_async(dispatch_get_main_queue(), {
                    // must be &amp;quot;tableView!&amp;quot; not &amp;quot;tableView?&amp;quot;
                    alert.show()
                    self.tableView!.reloadData()
                })
            }
            }, todoId: fakeData[indexPath.row][&amp;quot;_id&amp;quot;]!)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改好程式碼後，執行該程式&lt;/p&gt;

&lt;p&gt;在清單中將 item 往左滑，就可以看到刪除的按鈕了!&lt;/p&gt;

&lt;p&gt;超簡單的啦!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[API-d28] - 實戰開發 - 發佈 - forever</title>
      <link>http://blog.kerkerj.in/blog/api-d28---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---%E7%99%BC%E4%BD%88---forever/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/api-d28---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---%E7%99%BC%E4%BD%88---forever/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day28&#34;&gt;Github 參考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;接下來兩天要講 deploy 的部分&lt;/p&gt;

&lt;p&gt;由於 deploy 的 script 其實非常的麻煩，因此我們就不提 deploy 的 script 了&lt;/p&gt;

&lt;p&gt;我們只專注在 server 上需要什麼東西&lt;/p&gt;

&lt;p&gt;今天要來看看 &lt;code&gt;forever&lt;/code&gt; 這個套件&lt;/p&gt;

&lt;p&gt;這個套件可以幫助 nodejs 的 server 遇上無預警的 server 掛掉時&lt;/p&gt;

&lt;p&gt;會幫你自動重新啟動 nodejs 的 server&lt;/p&gt;

&lt;p&gt;也就是說&lt;/p&gt;

&lt;p&gt;假設說 nodejs 寫的 server 某個 route 有問題，&lt;/p&gt;

&lt;p&gt;送 request 後會因為某些因素造成 server error 造成程式碼 crash 時&lt;/p&gt;

&lt;p&gt;forever 的 monitor 會偵測到，並幫你自動重啟 server&lt;/p&gt;

&lt;p&gt;至少不會造成其他正常存取 server 的使用者遭遇到 server down 的問題&lt;/p&gt;

&lt;p&gt;這個套件可以選擇裝在 global 或是 project&lt;/p&gt;

&lt;p&gt;在這邊我是選擇裝成 global&lt;/p&gt;

&lt;p&gt;進到虛擬機&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ npm install -g forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;p.s. 如果遇到問題，試著跑下面的指令看看?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo chown vagrant:vagrant -R ~/.npm/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來我們就可以使用 &lt;code&gt;forever&lt;/code&gt; 這個指令了!&lt;/p&gt;

&lt;p&gt;原本我們要啟動 server 的話&lt;/p&gt;

&lt;p&gt;是要下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ npm start 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同義於:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ node ./bin/server.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要改用 &lt;code&gt;forever&lt;/code&gt; 的話:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 記得先到專案根目錄
$ forever start bin/server.js
warn:    --minUptime not set. Defaulting to: 1000ms
warn:    --spinSleepTime not set. Your script will exit if it does not stay up for at least 1000ms
info:    Forever processing file: ./bin/server.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後就會被丟到背景執行了&lt;/p&gt;

&lt;p&gt;那要怎麼知道我的 server 有跑起來呢?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ forever list
info:    Forever processes running
data:        uid  command                              script        forever pid   logfile                         uptime
data:    [0] 6qhd /home/vagrant/.nvm/v0.10.32/bin/node bin/server.js 13746   13748 /home/vagrant/.forever/6qhd.log 0:0:0:47.743
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就會列出相關資訊以及 forever 自己的 log file 位置&lt;/p&gt;

&lt;p&gt;要關閉的話:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ forever stop bin/server.js
info:    Forever stopped process:
data:        uid  command                              script        forever pid   logfile                         uptime
[0] 6qhd /home/vagrant/.nvm/v0.10.32/bin/node bin/server.js 13746   14061 /home/vagrant/.forever/6qhd.log 0:0:0:6.595
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bin/server.js&lt;/code&gt; 也可以替換成 forever uid 或 pid&lt;/p&gt;

&lt;p&gt;如果要重開的話&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ forever restart bin/server.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;超簡單!&lt;/p&gt;

&lt;p&gt;這樣就可以不用擔心 server 突然掛掉了&amp;hellip;.嗎?&lt;/p&gt;

&lt;p&gt;錯，還是必須要監控 server 狀態&lt;/p&gt;

&lt;p&gt;畢竟，&lt;code&gt;forever&lt;/code&gt; 也是會有 bug 的&lt;/p&gt;

&lt;p&gt;所以自己的 server 自己顧&lt;/p&gt;

&lt;p&gt;真正應用在 production 環境還是必須要監控的&lt;/p&gt;

&lt;p&gt;今天就分享到這啦!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Swift-d28] - 實戰開發 - TODOList - API 3 新增與更新</title>
      <link>http://blog.kerkerj.in/blog/swift-d28---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---todolist---api-3-%E6%96%B0%E5%A2%9E%E8%88%87%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/swift-d28---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---todolist---api-3-%E6%96%B0%E5%A2%9E%E8%88%87%E6%9B%B4%E6%96%B0/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;day28&#34;&gt;Github link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;昨天做了 get list&lt;/p&gt;

&lt;p&gt;今天就來做 新增和儲存吧!&lt;/p&gt;

&lt;p&gt;可能有人會問說，那讀取一筆 todo 的 API 呢?&lt;/p&gt;

&lt;p&gt;因為在這邊資料量少，所有的東西都可以從最外層的 list 拿到&lt;/p&gt;

&lt;p&gt;所以雖然有換頁的動作，但是節省流量可以不需要實做這件事&lt;/p&gt;

&lt;p&gt;在實際開發中也會如此，case by case，有些情況一次拿完回來處理最好&lt;/p&gt;

&lt;p&gt;不過有些則不是~&lt;/p&gt;

&lt;p&gt;離題了，&lt;/p&gt;

&lt;p&gt;以下是新增 todo 的程式碼:&lt;/p&gt;

&lt;p&gt;先到 RestApi.swift 新增 post function&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;func addTodoList(completionHandler: ((NSDictionary!, NSError!) -&amp;gt; Void)!, content: String) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: self.addTodoUrl!)
        request.HTTPMethod = &amp;quot;POST&amp;quot;
        
        var params = [&amp;quot;content&amp;quot;: content] as Dictionary&amp;lt;String, String&amp;gt;
        
        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;amp;err)
        request.addValue(&amp;quot;application/json&amp;quot;, forHTTPHeaderField: &amp;quot;Content-Type&amp;quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &amp;quot;API-Key&amp;quot;)
        
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&amp;gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;amp;error) as NSDictionary
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再來就是在程式中呼叫這隻 API 囉! 我們會在 UpdateViewController 中做這件事&lt;/p&gt;

&lt;p&gt;因為這隻 controler 處理了 &amp;ldquo;Add&amp;rdquo; 和 &amp;ldquo;Update&amp;rdquo; 兩件事&lt;/p&gt;

&lt;p&gt;在 save() 這個 function 裡面修改成:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 記得 class 中先產生一個 api 物件
var api = RestApi()

func save() {
        if from == &amp;quot;add&amp;quot; {
            api.addTodoList({data, error -&amp;gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&amp;quot;done&amp;quot;)
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == &amp;quot;edit&amp;quot; {
            println(&amp;quot;Save edited data&amp;quot;)
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打開執行就可以新增 todo 了!&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Update&amp;rdquo; 的行為和新增一樣&lt;/p&gt;

&lt;p&gt;先到 RestApi class 加入 update 的方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func updateTodoList(completionHandler: ((NSDictionary!, NSError!) -&amp;gt; Void)!, content: String, todoId: String) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: NSURL(string: &amp;quot;http://192.168.1.158:3000/user/kerkerj/todos/\(todoId)&amp;quot;)!)
        request.HTTPMethod = &amp;quot;PUT&amp;quot;
        
        var params = [&amp;quot;content&amp;quot;: content] as Dictionary&amp;lt;String, String&amp;gt;
        
        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;amp;err)
        request.addValue(&amp;quot;application/json&amp;quot;, forHTTPHeaderField: &amp;quot;Content-Type&amp;quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &amp;quot;API-Key&amp;quot;)
        
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&amp;gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;amp;error) as NSDictionary
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再到剛剛的 UpdateViewController ，把 save() 的另外一個 &amp;ldquo;edit&amp;rdquo; 的區塊改成下面的程式碼&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;else if from == &amp;quot;edit&amp;quot; {
            println(&amp;quot;Save edited data&amp;quot;)
            api.updateTodoList({data, error -&amp;gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&amp;quot;done&amp;quot;)
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })
                
            }, content: self.textField.text, todoId: self.index)
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以整個 save() 會長這樣:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func save() {
        if from == &amp;quot;add&amp;quot; {
            api.addTodoList({data, error -&amp;gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&amp;quot;done&amp;quot;)
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == &amp;quot;edit&amp;quot; {
            println(&amp;quot;Save edited data&amp;quot;)
            api.updateTodoList({data, error -&amp;gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&amp;quot;done&amp;quot;)
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })
                
            }, content: self.textField.text, todoId: self.id
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在這邊要再修改一個之前的 bug Orz&lt;/p&gt;

&lt;p&gt;由於我們要更新的時候，必須要使用到該筆資料的 object id&lt;/p&gt;

&lt;p&gt;我們之前在 view 中傳遞的都是 content，都沒有 id，因此要加進去&lt;/p&gt;

&lt;p&gt;首先要先改的地方是&lt;/p&gt;

&lt;p&gt;ViewController 中的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;showViewController.id = fakeData[indexPath.row][&amp;quot;id&amp;quot;]

// 改成:
showViewController.id = fakeData[indexPath.row][&amp;quot;_id&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因為在 mongodb 中 object id 的名字是 _id&lt;/p&gt;

&lt;p&gt;再來要在 ShowViewController 中加入一個把 id 傳到 UpdateViewController&lt;/p&gt;

&lt;p&gt;在 ShowViewController 中的 editTODO() 加入:&lt;/p&gt;

&lt;p&gt;(因為之前 showView 就已經有拿到 id 了，只是先前的欄位寫錯，加上沒有將 id pass 到 UpdateViewControler 才會發生這種事 XD)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;editViewContronller.id = self.id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;應該只有改這樣，最後執行看看&lt;/p&gt;

&lt;p&gt;就發現可以編輯成功囉!&lt;/p&gt;

&lt;p&gt;快結束啦!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[API-d27] - 實戰開發 - log 處理 及 config (db, apikey)</title>
      <link>http://blog.kerkerj.in/blog/api-d27---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---log-%E8%99%95%E7%90%86-%E5%8F%8A-config-db-apikey/</link>
      <pubDate>Mon, 27 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/api-d27---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---log-%E8%99%95%E7%90%86-%E5%8F%8A-config-db-apikey/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day27&#34;&gt;Github 參考&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##log 處理&lt;/p&gt;

&lt;p&gt;今天要來談談 log 的處理，&lt;/p&gt;

&lt;p&gt;身為一台自走 (?) node.js API server&lt;/p&gt;

&lt;p&gt;也應該要記錄一下 request 的 log 呀！&lt;/p&gt;

&lt;p&gt;不然哪天出問題了都不知道是哪個 request 把 server 搞掛了!&lt;/p&gt;

&lt;p&gt;因此我們就要加入 log 的 middleware&lt;/p&gt;

&lt;p&gt;node.js 的 log 套件也蠻多的, 例如 &lt;code&gt;winston&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不過我們今天要用的是 &lt;code&gt;log4js&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;會選擇他其實也只是因為之前寫 &lt;code&gt;java&lt;/code&gt; 有用過 &lt;code&gt;log4j&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;log4js&lt;/code&gt; 的設定感覺起來比較相似&lt;/p&gt;

&lt;p&gt;所以就使用它了!&lt;/p&gt;

&lt;p&gt;再來我們就安裝一下 &lt;code&gt;log4js&lt;/code&gt; 吧&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;$ npm install log4js -save  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;並在 &lt;code&gt;app.js&lt;/code&gt; 中 require 進去&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var log4js = require(&#39;log4js&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著在 &lt;code&gt;app.js&lt;/code&gt; 的前面區段加入以下程式碼:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;log4js.configure({
    appenders: [
        { type: &#39;console&#39; }, //控制台輸出
        {
            type: &#39;file&#39;, //文件輸出
            filename: &#39;logs/access.log&#39;,
            maxLogSize: 20000000, // 20 MB
            backups: 10,
            category: &#39;normal&#39;
        }
    ],
    replaceConsole: true
});

var logger = log4js.getLogger(&#39;normal&#39;);
logger.setLevel(&#39;INFO&#39;);

app.use(log4js.connectLogger(logger, {level: &#39;auto&#39;, format:&#39;:method :url&#39;}));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其實註解已經可以看出一些端倪了&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;log4js&lt;/code&gt; 可以輸出 log 檔案，並且會按照設定的檔案大小來寫入&lt;/p&gt;

&lt;p&gt;如果達到 20MB 就會換一個新的檔案寫入，原本的還保留著，不過最多只會保留 10 份&lt;/p&gt;

&lt;p&gt;接著就設定 log level, 以及想要 log 的資訊&lt;/p&gt;

&lt;p&gt;詳細資訊就可以再多查詢一下&lt;/p&gt;

&lt;p&gt;此時我們將 server run 起來吧!&lt;/p&gt;

&lt;p&gt;並且對 server 戳幾個 request, 就會發現 log 檔案被建立起來了!&lt;/p&gt;

&lt;p&gt;(該程式碼加在 token 檢查前或檢查後是有差異的，加在 token 檢查後面，token error 的話則不會被記錄到 log 裡面)&lt;/p&gt;

&lt;p&gt;打開 log 檔看看，就會發現有 log 被寫入囉!&lt;/p&gt;

&lt;p&gt;##config (db, apikey)&lt;/p&gt;

&lt;p&gt;有些重要的設定檔其實我們並不希望寫在程式碼裡，這時候 config 的設定很有用&lt;/p&gt;

&lt;p&gt;建立設定檔有很多種方式，比方說直接寫一個 json 檔案，或是 xml 檔案&lt;/p&gt;

&lt;p&gt;今天我們就用最簡單的 js 檔案的方式來建立 config 檔&lt;/p&gt;

&lt;p&gt;我們在 config 資料夾裡新增一個 config.js&lt;/p&gt;

&lt;p&gt;我們以下面的程式碼當作例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module.exports = {
    &amp;quot;base_url&amp;quot;: &amp;quot;http://localhost:3000&amp;quot;,
    &amp;quot;test_token&amp;quot;: &amp;quot;55665566&amp;quot;,
    &amp;quot;db&amp;quot;: {
        &amp;quot;production&amp;quot;: &amp;quot;mongodb://192.168.33.10:27017/TODOs&amp;quot;,
        &amp;quot;development&amp;quot;: &amp;quot;mongodb://192.168.33.10:27017/DEV_TODOs&amp;quot;,
        &amp;quot;test&amp;quot;: &amp;quot;mongodb://192.168.33.10:27017/TEST_TODOs&amp;quot;
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要怎麼使用裡面的內容呢?&lt;/p&gt;

&lt;p&gt;假設我們要將 db 的連結改成用 config 的方式連結的話:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var config = require(&#39;./config/config&#39;);

// Set DB
mongoose.connect(config.db.development);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只要先將 config require 進來，然後就直接使用它就好了!&lt;/p&gt;

&lt;p&gt;這樣就可以幫助我們將一些重要的設定從程式碼中抽離出來了!&lt;/p&gt;

&lt;p&gt;今天就這樣啦!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Swift-d27] - 實戰開發 - TODOList - API 2 讀取清單資料</title>
      <link>http://blog.kerkerj.in/blog/swift-d27---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---todolist---api-2-%E8%AE%80%E5%8F%96%E6%B8%85%E5%96%AE%E8%B3%87%E6%96%99/</link>
      <pubDate>Mon, 27 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/swift-d27---%E5%AF%A6%E6%88%B0%E9%96%8B%E7%99%BC---todolist---api-2-%E8%AE%80%E5%8F%96%E6%B8%85%E5%96%AE%E8%B3%87%E6%96%99/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27&#34;&gt;Github link&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(某一天把兩天份的 commit 在一起了忘了開 branch 了&amp;hellip;)&lt;/p&gt;

&lt;p&gt;接下來就要來寫 api utility 了&lt;/p&gt;

&lt;p&gt;我們先開一個 swift 檔案 &lt;code&gt;RestApi.swift&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-swift&#34;&gt;import Foundation

class RestApi {
	var API_key = &amp;quot;55665566&amp;quot;
	var getListUrl = NSURL(string: &amp;quot;http://192.168.1.158:3000/user/kerkerj/todos&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先做好前置設定，因為 API 有上簡單的小鎖，因此要先寫起來&lt;/p&gt;

&lt;p&gt;還有 request 的網址&lt;/p&gt;

&lt;p&gt;以下是 get list 的範例:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func getTodoList(completionHandler: ((NSArray!, NSError!) -&amp;gt; Void)!) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: self.getListUrl!)
        request.HTTPMethod = &amp;quot;GET&amp;quot;
        request.addValue(&amp;quot;application/json&amp;quot;, forHTTPHeaderField: &amp;quot;Content-Type&amp;quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &amp;quot;API-Key&amp;quot;)
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&amp;gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;amp;error) as NSArray
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我們使用內建的 NSURLSession.sharedSession 以及 NSMutableURLRequest 來建立 request&lt;/p&gt;

&lt;p&gt;裡面就是設定一些 header 以及 API-Key&lt;/p&gt;

&lt;p&gt;另外在資料回來後，return callback&lt;/p&gt;

&lt;p&gt;在這邊有 async，寫隔壁棚的 api 回過頭來看這個感覺很熟悉 XD&lt;/p&gt;

&lt;p&gt;設定好 API 後&lt;/p&gt;

&lt;p&gt;回到顯示 todo 清單的主頁程式碼&lt;/p&gt;

&lt;p&gt;由於我們希望能夠在 view 每次被呼叫時，都可以對 API server 做存取&lt;/p&gt;

&lt;p&gt;因此必須要將 getTodoList 寫在該方法裏&lt;/p&gt;

&lt;p&gt;該方法為 override func viewWillAppear(animated: Bool) {}&lt;/p&gt;

&lt;p&gt;先建立一個 api 物件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var api: RestApi = RestApi()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;將原本的假資料刪除或註解, 不過資料物件名稱就繼續用 fakeData XD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//        fakeData = [
//            [&amp;quot;id&amp;quot;: &amp;quot;1&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;A&amp;quot;],
//            [&amp;quot;id&amp;quot;: &amp;quot;2&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;B&amp;quot;],
//            [&amp;quot;id&amp;quot;: &amp;quot;3&amp;quot;, &amp;quot;content&amp;quot;: &amp;quot;C&amp;quot;],
//        ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著在 ViewController override 一個 viewWillAppear 的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(true)
        
        api.getTodoList({data, error -&amp;gt; Void in
            if error != nil {
                dispatch_async(dispatch_get_main_queue(), {
                    let alert = UIAlertView()
                    alert.title = &amp;quot;Yoooooooooooooooo&amp;quot;
                    alert.message = &amp;quot;Get list faild, maybe check your network: \(error)&amp;quot;
                    alert.addButtonWithTitle(&amp;quot;ok&amp;quot;)
                    alert.delegate = self
                    alert.show()
                    println(error)
                })
            }
            
            if (data != nil) {
                
                var tmpArr = [[String: String]]()
                
                for item in data {
                    var _id = item[&amp;quot;_id&amp;quot;] as String
                    var content = item[&amp;quot;content&amp;quot;] as String
                    var dic = [String: String]()
                    
                    dic[&amp;quot;_id&amp;quot;] = _id
                    dic[&amp;quot;content&amp;quot;] = content
                    
                    tmpArr.append(dic)
                }

                self.arr = tmpArr
                
                println(self.arr)
                
                dispatch_async(dispatch_get_main_queue(), {
                    // must be &amp;quot;tableView!&amp;quot; not &amp;quot;tableView?&amp;quot;
                    self.tableView!.reloadData()
                })
                
            }
        })
        
        dispatch_async(dispatch_get_main_queue(), {
            // must be &amp;quot;tableView!&amp;quot; not &amp;quot;tableView?&amp;quot;
            self.tableView!.reloadData()
        })
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上方法都是 async 的方式&lt;/p&gt;

&lt;p&gt;只要網路錯誤，就會直接跳一個 alert&lt;/p&gt;

&lt;p&gt;若有資料的話就 parse&lt;/p&gt;

&lt;p&gt;一併轉換成原本定義的 [[String: String]] 中&lt;/p&gt;

&lt;p&gt;執行看看吧!&lt;/p&gt;

&lt;p&gt;很明顯每次切回主頁時 api console 都會跳一行 request~&lt;/p&gt;

&lt;p&gt;如果使用 sync 的方式就會卡很久! 而且更新 UI 還會 crash XD&lt;/p&gt;

&lt;p&gt;我覺得這部分是需要好好去做處理的，在這邊的程式碼只是簡單 demo&lt;/p&gt;

&lt;p&gt;並沒有考慮到太多 :P&lt;/p&gt;

&lt;p&gt;明天繼續!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>