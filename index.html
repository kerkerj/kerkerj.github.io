<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://blog.kerkerj.in/">
    <meta property="og:title" content="kerkerj">
    
    <meta property="og:description" content="hugo hugo - 快速又現代的靜態網站產生器 ^^^ 這是 spf13 自己說的 繼 spf13-vim 後又一個 spf13 出品的好東西 XD 在靜態網站產生器中最廣為人知的應該就是 Jekyll 以及基於 Jekyll 的 Octopress 了 (關於靜態網站產生器，這篇文章 介紹了六個除了 Jekyll 以外的產生器) 為什麼要用 hugo？ 雖然 Jekyll / Octopress 很紅資源多主題也不少 但是缺點就是要使用它們就必須裝 ruby、裝 gem 有在寫 ruby 的人感覺應該還好 沒在寫 ruby 的光想像就覺得應該會被搞死&hellip; XD 而且覺得文章一多時在編譯的時候好慢&hellip; 用 hugo 的好處就是因為他是用 go 寫的 執行速度飛快，而且只要下載一個 binary 檔案後就可以操作了喲~ 基本 hugo 安裝與操作 首先先安裝 hugo (我是用 mac 的 homebrew) $ brew install hugo 使用 hugo 產生一個新的網站 $ hugo new site /path/to/the/site e.g.">
    
    
    
    <meta property="og:site_name" content="kerkerj">

    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="kerkerj" />
    <meta name="twitter:title" content="kerkerj &middot; kerkerj">
    <meta name="twitter:description" content="Hi.">

    
    <title>kerkerj &middot; kerkerj</title>

    
    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    
    
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    

    <link rel="stylesheet" href="http://blog.kerkerj.in//css/all.min.css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    
    
      <link rel="stylesheet" href="http://blog.kerkerj.in//css/highlight/railscasts.css">
    

    
    <link href="http://blog.kerkerj.in/favicon.ico" rel="icon">

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://blog.kerkerj.in//index.xml">
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://blog.kerkerj.in/">kerkerj</a></h1>
            <h2 class="brand-tagline"> Hi. </h2>
        </hgroup>

        <nav class="nav">
            
            <ul class="pure-menu-list">
              
              
                <li class="pure-menu-link">
                  <a href="http://blog.kerkerj.in//notes/">Notes</a>
                </li>
              
                <li class="pure-menu-link">
                  <a href="http://blog.kerkerj.in//about/">About</a>
                </li>
              
                <li class="pure-menu-link">
                  <a href="http://blog.kerkerj.in//mac-app-list/">Mac App List</a>
                </li>
              
            </ul>

            
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="http://twitter.com/kerkerj"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="http://github.com/kerkerj "><i class="fa fa-github-alt"></i> Github</a>
                </li>
                
                
                
                <li class="nav-item">
                    <a class="pure-button" href="http://blog.kerkerj.in/index.xml"><i class="fa fa-rss-alt"></i> RSS</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">2015-05-05 02:14</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2015/05/03/migrating-to-hugo-from-octopress/" class="post-title">Migrating to Hugo from Octopress</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-hugo" href="http://blog.kerkerj.in//categories/hugo">hugo</a><a class="post-category post-category-octopress" href="http://blog.kerkerj.in//categories/octopress">octopress</a><a class="post-category post-category-notes" href="http://blog.kerkerj.in//categories/notes">notes</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<p><a href="https://gohugo.io">hugo</a></p>

<p><l><b>hugo - 快速又現代的靜態網站產生器</b></l></p>

<p>^^^ 這是 spf13 自己說的</p>

<p>繼 spf13-vim 後又一個 spf13 出品的好東西 XD</p>

<p>在靜態網站產生器中最廣為人知的應該就是 <a href="http://jekyllrb.com/"><code>Jekyll</code></a></p>

<p>以及基於 <code>Jekyll</code> 的 <a href="http://octopress.org/"><code>Octopress</code></a> 了</p>

<p>(關於靜態網站產生器，<a href="http://www.sitepoint.com/6-static-blog-generators-arent-jekyll/">這篇文章</a> 介紹了六個除了 <code>Jekyll</code> 以外的產生器)</p>

<h2 id="為什麼要用-hugo:869884de6842d04f918ac95a6e75e9a8">為什麼要用 <code>hugo</code>？</h2>

<p>雖然 <code>Jekyll</code> / <code>Octopress</code> 很紅資源多主題也不少</p>

<p>但是缺點就是要使用它們就必須裝 <code>ruby</code>、裝 <code>gem</code></p>

<p>有在寫 <code>ruby</code> 的人感覺應該還好</p>

<p>沒在寫 <code>ruby</code> 的光想像就覺得應該會被搞死&hellip; XD</p>

<p>而且覺得文章一多時在編譯的時候好慢&hellip;</p>

<p>用 <code>hugo</code> 的好處就是因為他是用 <code>go</code> 寫的</p>

<p>執行速度飛快，而且只要下載一個 <code>binary</code> 檔案後就可以操作了喲~</p>

<h2 id="基本-hugo-安裝與操作:869884de6842d04f918ac95a6e75e9a8">基本 <code>hugo</code> 安裝與操作</h2>

<p>首先先安裝 <code>hugo</code> (我是用 <code>mac</code> 的 <code>homebrew</code>)</p>

<pre><code>$ brew install hugo
</code></pre>

<p>使用 <code>hugo</code> 產生一個新的網站</p>

<pre><code>$ hugo new site /path/to/the/site
e.g.
$ hugo new site /Users/kerkerj/my_hugo_blog
</code></pre>

<p>到剛剛產生的網站目錄底下</p>

<pre><code>$ cd /path/to/the/site
e.g.
$ cd /Users/kerkerj/my_hugo_blog
</code></pre>

<p>產生一些內容</p>

<pre><code>$ hugo new about.md
</code></pre>

<p>或是一篇文章</p>

<pre><code>$ hugo new post/first-post.md
</code></pre>

<p>安裝主題</p>

<pre><code>$ git clone --recursive https://github.com/spf13/hugoThemes themes
</code></pre>

<p>把 <code>hugo</code> 跑起來!</p>

<pre><code>$ hugo server --theme=hyde-x --buildDrafts --watch
</code></pre>

<p>指令說明:</p>

<p><code>--theme=hyde-x</code></p>

<blockquote>
<p>指的是使用哪一個主題，可以在 <code>themes</code> 資料夾裡找，並將 <code>hyde</code> 替換掉就可以換主題，例如換成 <code>greyshade</code></p>
</blockquote>

<p><code>--buildDrafts</code></p>

<blockquote>
<p>使用 <code>hugo new post/first-post.md</code> 預設會是草稿 (在 <code>first-post.md</code> 裡會有 <code>draft=true</code>)</p>

<p>如果下 <code>--buildDrafts</code> 的意思就是會把草稿也 build 出來讓你看到</p>
</blockquote>

<p><code>--watch</code></p>

<blockquote>
<p>如果在 server 開啟時，編輯文章並儲存的話，server 會幫你根據修改的內容重新產生網頁，</p>

<p>不需要再下指令重新 build 一次</p>
</blockquote>

<h2 id="migrating-from-octopress:869884de6842d04f918ac95a6e75e9a8">Migrating from <code>octopress</code></h2>

<p>我自己原本是用 <code>octopress</code></p>

<p>為了不要怕改壞原本的 <code>octopress</code> 文章</p>

<p>我把在 <code>octopress</code> 的文章 (<code>source/_posts</code>)</p>

<p>全數複製一份到 <code>my_hugo_blog/content/post/</code> 底下</p>

<p>接著就試著跑 <code>hugo server</code> 起來試試看</p>

<p>當然是炸了一堆 ERROR 出來啦 XD</p>

<p>以下是我遇到的幾個常見問題</p>

<h2 id="meta-data-的-date:869884de6842d04f918ac95a6e75e9a8">Meta-data 的 Date</h2>

<p>這是我的錯誤訊息</p>

<pre><code>ERROR: 2015/05/02 Failed to parse date '2010-10-04 18:25' in page post/2010-10-04-freebsd81-famp.md
...
</code></pre>

<p>首先瞭解一下文章的 meta-data 格式</p>

<p><code>octopress</code> 的是 <code>yaml</code> 格式</p>

<pre><code>---
layout: post
title: &quot;Setup wifi on raspberry pi2&quot;
date: 2015-04-22 22:59:11 +0800
comments: true
categories: [raspberry]
keywords: [raspberry, pi, pi2, wifi]
description: 
---
</code></pre>

<p><code>hugo</code> 的則是 <code>toml</code> 格式</p>

<pre><code>+++
date = &quot;2015-05-02T02:27:21+08:00&quot;
draft = true
title = &quot;test&quot;

+++
</code></pre>

<p>現在 <code>hugo</code> 0.13 版開始也可以讀 <code>yaml</code> 格式了</p>

<p>(在 config 中可以設定 <code>metaDataFormat: &quot;yaml&quot;</code>)</p>

<p>不過比較麻煩的是 <code>date</code> 這個屬性，兩邊長得並不太一樣</p>

<p><code>octopress</code> 比較舊的是長這樣 <code>2010-10-04 18:25</code></p>

<p>新一點 (某一次更新後) 的長這樣 <code>2014-10-02 01:37:44 +0800</code></p>

<p>不過不管怎樣，<code>hugo</code> 都不吃</p>

<p>因為 <code>hugo</code> 的長這樣 <code>2015-05-02T02:27:21+08:00</code></p>

<p>囧了</p>

<p>因此必須將 <code>octopress</code> 的格式換成 <code>hugo</code> 的</p>

<p>接下來下的指令最好先 <code>git commit</code> 一下後再做 XD</p>

<pre><code>$ cd my_hugo_blog/content/post/ 
$ find . -type f -exec sed -i &quot;&quot; -e 's/date: \([0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}\).*$/date: \1/g' {} \;
</code></pre>

<p>這個指令會將原本的 date 格式換成只有 <code>yyyy-mm-dd</code> 的格式</p>

<p>例如 <code>2014-10-02 01:37:44 +0800</code> 換成只有 <code>2014-10-02</code></p>

<p>這樣 <code>hugo</code> 就看得懂</p>

<h2 id="permallink-的問題:869884de6842d04f918ac95a6e75e9a8">permallink 的問題</h2>

<p>當日期問題修好後，重開 server</p>

<p>發現點擊文章標題進單篇文章網頁時會跳 404</p>

<p>原因是 <code>hugo</code> 預設產生的連結是</p>

<p><code>http://yoursite.com/post/2015-04-22-raspberry-pi2-remote-webcam/</code></p>

<p>而在 <code>octopress</code> 是根據日期區分</p>

<p><code>http://yoursite.com/post/2015/04/22/raspberry-pi2-remote-webcam/</code></p>

<p>這個問題的解法比較簡單</p>

<p>在 <code>config.toml</code> 加入這行就行</p>

<pre><code>[Permalinks]
	post = &quot;/:year/:month/:day/:filename/&quot;
</code></pre>

<p>不過因為 <code>octopress</code> 本身在產生檔案時就已經把日期加入檔名中</p>

<p>(e.g. <code>2015-04-22-raspberry-pi2-remote-webcam.md</code>)</p>

<p>因此 <code>octopress</code> 的文章連結看起來就會很長，例如:</p>

<pre><code>http://localhost:1313/2015/04/22/2015-04-22-raspberry-pi2-remote-webcam/
</code></pre>

<p>這時候就看要不要把檔名改掉啦</p>

<p>例如把 <code>2015-04-22-raspberry-pi2-remote-webcam.md</code></p>

<p>改成 <code>raspberry-pi2-remote-webcam.md</code></p>

<p>或者可以試著改成:</p>

<pre><code>[Permalinks]
	post = &quot;/:year/:month/:day/:title/&quot;
</code></pre>

<p>不過我試了一下，會有機會因為標題有特殊符號或中文</p>

<pre><code>e.g.  http://localhost:1313/2014/10/20/swift-d20---basic---%E6%8D%A8%E6%A3%84-storyboard-%E4%BD%BF%E7%94%A8%E7%B4%94%E7%A8%8B%E5%BC%8F%E7%A2%BC-%E7%9A%84%E6%96%B9%E5%BC%8F%E6%92%B0%E5%AF%AB-viewcontroller/
</code></pre>

<p>產生出奇怪的資料夾名稱而導致該文章無法存取</p>

<p>所以這個方式僅供參考，可以試試 XD</p>

<p>BTW，我個人在撰寫文章時都沒有用到產生器的樣板語言，因此在轉換時比較沒遇到什麼問題</p>

<p>上述問題解法的參考來源:</p>

<p><a href="http://nathanleclaire.com/blog/2014/12/22/migrating-to-hugo-from-octopress/">Migrating to Hugo From Octopress</a></p>

<p><a href="http://deeeet.com/writing/2014/12/25/hugo/">OctopressからHugoへ移行した</a></p>

<h2 id="設定檔-config-toml-config-yml-config-json:869884de6842d04f918ac95a6e75e9a8">設定檔 (config.toml, config.yml, config.json)</h2>

<p><code>hugo</code> 預設的是 <code>config.toml</code>，也支援 <code>yaml</code> 和 <code>json</code></p>

<p>而 <code>hugo</code> 讀取的順位是照上述順序</p>

<p>如果是要將網頁讓 <code>GitHub</code> host 的話，就必須使用 <code>config.yaml</code></p>

<p>因此我就把 <code>config.toml</code> 換成 <code>config.yml</code> 了 (也比較習慣)</p>

<p>以下是我的 <code>config.yml</code> 主要的設定</p>

<pre><code>baseurl:            &quot;http://blog.kerkerj.in/&quot;
languageCode:       &quot;en-us&quot;
title:              &quot;My New Hugo Site&quot;

buildDrafts:        false
config:             &quot;config.yml&quot;
metaDataFormat:     &quot;yaml&quot;

permalinks:
  post:             &quot;/blog/:year/:month/:day/:filename/&quot;

theme:              &quot;purehugo&quot;
</code></pre>

<p>設定 <code>metaDataFormat: &quot;yaml&quot;</code> 的話</p>

<p>使用 <code>hugo new</code> 的文章 meta-data 都會是 <code>yaml</code> 格式喔</p>

<p>要查詢預設的參數在這 <a href="http://gohugo.io/overview/configuration/">Configuring Hugo</a></p>

<h2 id="主題佈景-theme:869884de6842d04f918ac95a6e75e9a8">主題佈景 Theme</h2>

<p>其實在 <code>hugo</code> 裡比較讓我覺得麻煩的還是主題的挑選吧</p>

<p>因為選擇實在不多</p>

<p>我最喜歡的是在 <code>octopress</code> 中的 <a href="https://github.com/shashankmehta/greyshade">greyshade</a></p>

<p>雖然 <code>spf13/hugoThemes</code> 的 repo 中有人 porting，但是完成度似乎不高</p>

<p>改 template 是應該沒什麼難度，照著改就好，不過&hellip;實在沒這麼多時間 Orz</p>

<p>而且 <code>hugo</code> 在二月底 release 了 0.13 版，有一部分的主題佈景都不能動了 XD</p>

<p>這邊列出我試過可以 work 的</p>

<ul>
<li><a href="https://github.com/spf13/herring-cove">herring-cove</a></li>
<li><a href="https://github.com/SenjinDarashiva/hugo-uno">hugo-uno</a></li>
<li><a href="https://github.com/zyro/hyde-x">hyde-x</a></li>
<li><a href="https://github.com/dplesca/purehugo">purehugo</a></li>
<li><a href="https://github.com/tmaiaroto/hugo-redlounge">redlounge</a></li>
<li><a href="https://github.com/AlexFinn/simple-a">simple-a</a></li>
<li><a href="https://github.com/marloncabrera/tachyons">tachyons</a></li>
<li><a href="https://github.com/roperzh/tinyce-hugo-theme">tinyce</a></li>
<li><a href="https://github.com/keichi/vienna">vienna</a></li>
</ul>

<p><code>vienna</code> 的 index list 壞掉了，不過 single page 能動，佈景也還算漂亮</p>

<p>自己修一下應該就可以</p>

<p>其實其他不少佈景也都是 index page 不能動，其他都能動</p>

<p>另外在試的過程中，發現除非 repo 有特別說</p>

<p>不然 <code>config.yml</code> 的 <code>disqus</code> 的 key 都是 <code>disqusShortname</code></p>

<p>(因為有個佈景的 key 是 <code>disqus_short_name</code>)</p>

<p><code>hyde-x</code> 是最多人 star 的主題佈景，有八種色系可以選擇</p>

<p>功能也蠻齊全，不想自己搞東搞西的話，建議就直接選這個主題</p>

<p>(因為我最後 <a href="https://github.com/dplesca/purehugo">fork 人家的</a> theme <a href="https://github.com/kerkerj/purehugo">自己改了一堆</a> (遮臉) )</p>

<h2 id="syntax-highlight:869884de6842d04f918ac95a6e75e9a8">Syntax highlight</h2>

<p>寫技術筆記的人應該對這個非常執著 XD</p>

<p>我使用的主題是 <code>purehugo</code></p>

<p>不過他的 syntax highlight 是預設的常見的模式</p>

<p>因此我就自己把他抽掉換成 <a href="https://github.com/isagalaev/highlight.js"><code>highlight.js</code></a></p>

<p><code>hugo</code> 在 <a href="http://gohugo.io/extras/highlighting/">這篇文件</a> 中有另外說明關於如何自訂 syntax highlight</p>

<h2 id="支援-disqus-ga-pagination-seo-robot-txt-favcon:869884de6842d04f918ac95a6e75e9a8">支援 (disqus, ga, pagination, SEO, robot.txt, favcon)</h2>

<p><code>disqus</code> 要看佈景有無支援，<code>GA</code> 也是</p>

<p>不過如果主題沒有的話，也是自己寫一個 partial 插進去就好</p>

<p>另外 <code>pagination</code> 也是在最新版 (0.13) 才加入，所以也要看佈景有沒有支援</p>

<p>不然文章多的就會發現首頁往下捲捲不完&hellip; XD</p>

<p><code>SEO</code> 的部分有人特別寫 partial <a href="https://github.com/nozzle/hugo-snippets">nozzle/hugo-snippets</a></p>

<p>自己寫在 theme 的 header.html 當然是最直覺的</p>

<p><code>robot.txt</code>、<code>favcon</code> 就自己加進 <code>static</code> 資料夾，再到 theme 裡面修改</p>

<h2 id="deploy:869884de6842d04f918ac95a6e75e9a8">Deploy</h2>

<p><code>hugo</code> 有一篇 <a href="http://gohugo.io/tutorials/github-pages-blog/">教學文</a> 教你如何放在 <code>GitHub</code> 上</p>

<p>有兩種方式 (Project page or Personl page)</p>

<p>不過都需要先在 <code>config.yml</code> 加入以下資訊</p>

<pre><code>---
contentdir: &quot;content&quot;
layoutdir: &quot;layouts&quot;
publishdir: &quot;public&quot;
indexes:
  category: &quot;categories&quot;
baseurl: &quot;http://kerkerj.github.io/ or http://kerkerj.github.io/hugo_gh_blog/&quot;
title: &quot;Hugo Blog Template for GitHub Pages&quot;
canonifyurls: true
</code></pre>

<h3 id="project-page-e-g-http-your-github-account-github-io-hugo-gh-blog:869884de6842d04f918ac95a6e75e9a8">Project page: e.g. <a href="http://your_github_account.github.io/hugo_gh_blog/">http://your_github_account.github.io/hugo_gh_blog/</a></h3>

<p>先處理好本機端 <code>hugo</code> 的 blog，接著 <code>git init</code> 並且 <code>commit</code> 後</p>

<p>加入 <code>gh-pages</code> 這個 branch (<a href="https://help.github.com/articles/creating-project-pages-manually/">教學</a>)</p>

<p>接著回到 <code>master</code>，照著下列步驟</p>

<pre><code># Fetch the deployment script into the root of your source tree, make it executable.
wget https://github.com/X1011/git-directory-deploy/raw/master/deploy.sh &amp;&amp; chmod +x deploy.sh

# For setting it up to build to a folder other than &quot;dist&quot;, see the options in deploy.sh.
# Build the site to /dist.
hugo -d dist

# Run the deploy.sh script installed above.
./deploy.sh
</code></pre>

<p>就可以 deploy 到 github project page 了</p>

<p>存取網址就是 <code>http://your_github_account.github.io/hugo_gh_blog/</code></p>

<h3 id="personal-page-e-g-http-kerkerj-github-io:869884de6842d04f918ac95a6e75e9a8">Personal page: e.g. <a href="http://kerkerj.github.io/">http://kerkerj.github.io/</a></h3>

<p>建立兩個 repo，一個拿來放 <code>my_hugo_blog</code> 本機端的資料</p>

<p>一個就是 <code>your_github_account.github.io</code> 這個 repo</p>

<p>會拿來放 <code>my_hugo_blog/public</code> 資料夾裡的資料</p>

<p>所以就必須先在 <code>GitHub</code> 上有 <code>your_github_account.github.io</code> 這個 repo</p>

<p>這邊會比較簡單</p>

<p>以剛剛的例子的話就會是 <code>my_hugo_blog</code>，這個資料夾裡放了所有剛剛 <code>hugo</code> 產生的資料</p>

<p>先處理 <code>deploy.sh</code>:</p>

<p>可以直接自己把以下內容存成 <code>deploy.sh</code>，並 <code>chmod +x deploy.sh</code> 使其可執行</p>

<pre><code>#!/bin/bash
# Deploy hugo site to GitHug personal page
 
echo -e &quot;\033[0;32mDeploying updates to GitHub...\033[0m&quot;
 
# Build the project. 
hugo # if using a theme, replace by `hugo -t &lt;yourtheme&gt;`
 
# Go To Public folder
cd public
# Add changes to git.
git add -A
 
# Commit changes.
msg=&quot;rebuilding site `date`&quot;
if [ $# -eq 1 ]
  then msg=&quot;$1&quot;
fi
git commit -m &quot;$msg&quot;
 
# Push source and build repos.
git push origin master
 
# Come Back
cd ..
</code></pre>

<p>或下載 <code>deploy.sh</code> (同時使其可執行)</p>

<pre><code>wget https://gist.githubusercontent.com/kerkerj/18b18a24af8e8a0ec0ee/raw/654dfb7faaa23db24f707c4d746319e458157d89/deploy.sh &amp;&amp; chmod +x deploy.sh
</code></pre>

<p>如果有使用 theme，記得修改 <code>deploy.sh</code></p>

<p>把</p>

<pre><code>hugo # if using a theme, replace by `hugo -t &lt;yourtheme&gt;`
</code></pre>

<p>換成</p>

<pre><code>hugo -t yourtheme # if using a theme, replace by `hugo -t &lt;yourtheme&gt;`
</code></pre>

<p>所以現在已經處理好的東西有:</p>

<ol>
<li><code>my_hugo_blog</code> 資料夾以及可執行的 <code>deploy.sh</code></li>
<li>已經在 <code>GitHub</code> 上有 <code>your_github_account.github.io</code> 這個 repo</li>
</ol>

<p>(p.s. 如果有要設定 CNAME 什麼的，就把 CNAME 檔案放 <code>static</code> 這個資料夾裡)</p>

<p>接下來，先將 server 跑起來</p>

<pre><code>$ hugo server --watch -t &lt;yourtheme&gt;
</code></pre>

<p>把你想要的網站調整好後，關掉 server 並將 <code>public</code> 資料夾刪除 (等等會重新在 deploy.sh 中產生)</p>

<pre><code>$ rm -rf public
</code></pre>

<p>接著把 <code>GitHub</code> 的 repo 加到 <code>public</code> 裡</p>

<pre><code>$ git submodule add git@github.com:&lt;username&gt;/&lt;username&gt;.github.io.git public
</code></pre>

<p>最後就 deploy 到 github 上</p>

<pre><code># 自動產生 commit message
$ ./deploy.sh 

# 如果要自訂 commit message 的話
$ ./deploy.sh &quot;Your commit message&quot;
</code></pre>

<p>如果是第一次 deploy 到 <code>GitHub</code> 的話，需要等待大約 15 ~ 20 分鐘</p>

<p>才會在 <code>GitHub</code> 上看到你的網站喲</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2015-04-04 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2015/04/22/2015-04-22-raspberry-pi2-remote-webcam/" class="post-title">Raspberry Pi2 remote webcam</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-raspberry" href="http://blog.kerkerj.in//categories/raspberry">raspberry</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>如題~</p>

<p>先假設 pi2 本身的 IP 是 <code>192.168.1.200</code></p>

<p>首先先進去 server 來更新一下~</p>

<pre><code class="language-shell">$ sudo apt-get update &amp;&amp; sudo apt-get upgrade
</code></pre>

<p>再來就裝 <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/WebHome">motion</a></p>

<p>他其實是一個 motion detector，不過也可以拿來當作 web cam 用的 streaming server XD</p>

<pre><code class="language-shell">$ sudo apt-get install motion
</code></pre>

<p>編輯設定檔 <code>/etc/motion/motion.conf</code></p>

<pre><code class="language-shell">$ sudo vi /etc/motion/motion.conf
</code></pre>

<p>找到以下幾個值，並分別改成下面</p>

<pre><code class="language-shell">daemon = ON
webcam_localhost = OFF
control_localhost = OFF
</code></pre>

<p><code>webcam_localhost</code> 是 streaming 介面</p>

<p><code>control_localhost</code> 是設定介面</p>

<p>如果要改預設 port，就找 <code>webcam_port</code>, or <code>control_port</code></p>

<p>最後設定將 service 啟動</p>

<pre><code class="language-shell">$ sudo vi /etc/default/motion
</code></pre>

<p>將 no 改成 yes</p>

<pre><code class="language-shell">start_motion_daemon = yes
</code></pre>

<p>啟動 service</p>

<pre><code class="language-shell">$ sudo service motion start
</code></pre>

<p>motion 這個 service 預設的 port 是 8080 / 8081 (可以在前述的設定檔更改)</p>

<p>開啟瀏覽器, 連入 <code>http://192.168.1.200:8080</code> or <code>http://192.168.1.200:8081</code></p>

<p>這邊會有個小問題，就是連 8080 時會很正常</p>

<p>但是 8081 時如果是用 chrome，則怎麼都進不去</p>

<p>後來發現 <a href="http://www.lavrsen.dk/foswiki/bin/view/Motion/SupportQuestion2013x09x01x104741">這篇</a></p>

<p>他說 Chrome 不再支援 raw MJPEG streams 了</p>

<p>所以就是用其他瀏覽器開吧, 我是用 Safari :D</p>

<p>記得要和你的 pi2 在同一個 wifi 環境下~</p>

<p>剩下的還有許多設定可以玩～ 改天再來慢慢玩</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2015-04-04 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2015/04/22/2015-04-22-setup-wifi-on-raspberry-pi2/" class="post-title">Setup wifi on raspberry pi2</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-raspberry" href="http://blog.kerkerj.in//categories/raspberry">raspberry</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>(這是篇筆記)</p>

<p>前陣子從前同事那接手了一塊 raspberry pi2 的板子</p>

<p>想要用 wifi 來連網，於是就買了一個 usb 無線網卡</p>

<p>型號是:</p>

<p>TP-LINK TL-WN725N 150MbpsUSB無線網卡 (<a href="http://24h.pchome.com.tw/prod/DRAF4Z-A75333252">pchome連結</a>)</p>

<p>一開始當然還是必須先插網路線，<code>ssh</code> 進去後</p>

<p>先檢查 <code>pi2</code> 的 <code>kernel</code> 版本</p>

<pre><code>$ uname -r
3.18.7-v7+ # 這是我的版本
</code></pre>

<p>接著根據這個 <a href="https://github.com/lwfinger/rtl8188eu/">repo</a></p>

<p>將韌體載下來放到 /lib/firmware 裡</p>

<pre><code>$ sudo wget https://github.com/lwfinger/rtl8188eu/raw/c83976d1dfb4793893158461430261562b3a5bf0/rtl8188eufw.bin -O /lib/firmware/rtlwifi/rtl8188eufw.bin 
</code></pre>

<p>再來設定 pi2 的網路</p>

<pre><code>$ ifconfig
eth0      Link encap:Ethernet  
lo        Link encap:Local Loopback
wlan0     Link encap:Ethernet 
</code></pre>

<p>如果網卡有裝成功，應該就會有 <code>wlan0</code> 或是 <code>wlanX</code> 之類的 (X 是數字)</p>

<p>最後就是手動掃描無線網路，並設定連線值囉</p>

<pre><code>$ sudo iwlist scan =&gt; 掃描無線網路 AP
wlan0     Scan completed :
          Cell 01 - Address: XX:XX:XX:XX:XX:XX
                    ESSID:&quot;GGININDER&quot;
          Cell 02 - Address: XX:XX:XX:XX:XX:XX
                    ESSID:&quot;TP-LINK_F5566&quot;
</code></pre>

<p>連線的 <code>SSID</code> 就找 <code>Cell</code> 裡的 <code>ESSID</code></p>

<p>(通常應該會記得自己家的 AP 啦，可以用來確認一下)</p>

<p>開啟 <code>/etc/network/interfaces</code> 來寫入連線值</p>

<p>我的 AP 的加密機制是 WPA/WPA2，所以使用下面的方式連線</p>

<p>若是其他方式 (e.g. WEP) 可以參考 <a href="http://inpega.blogspot.tw/2013/09/blog-post_15.html">這篇</a></p>

<pre><code>$ vi /etc/network/interfaces
auto lo

iface lo inet loopback
iface eth0 inet dhcp

# 重點是下面這段

# 允許熱插拔 wlan0 這個介面
allow-hotplug wlan0 

# 預設設定為 dhcp
iface default inet dhcp

# 設定 wlan0 這張介面卡為 DHCP 自動取得 IP
iface wlan0 inet dhcp

# 你的 AP 的 SSID
wpa-ssid &quot;GGININDER&quot;

# 你的 AP 的密碼
wpa-psk &quot;password&quot;
</code></pre>

<p>設定好後，重新啟動 wlan0 介面就可以連線囉</p>

<pre><code>$ sudo ifdown wlan0
$ sudo ifup wlan0
$ ifconfig wlan0 # 確認是否取得 IP
</code></pre>

<p>reference:</p>

<p>raspberry pi forum: <a href="http://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;t=62371&amp;start=475">http://www.raspberrypi.org/forums/viewtopic.php?f=28&amp;t=62371&amp;start=475</a></p>

<p>網路設定: <a href="http://inpega.blogspot.tw/2013/09/blog-post_15.html">http://inpega.blogspot.tw/2013/09/blog-post_15.html</a></p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-11-11 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2014/11/01/2014-10-02-planning/" class="post-title">ithome 鐵人賽 - 規劃</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-others" href="http://blog.kerkerj.in//categories/others">others</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>半個月前不怕死的報名了 ithome 的<a href="http://ithelp.ithome.com.tw/ironman7/app/index">連續三十天不中斷發文鐵人賽</a>，</p>

<p>還報名了兩個主題，真的是太誇張了&hellip;</p>

<p>但是由於 ithome 的編輯器其實排版起來沒有很漂亮，</p>

<p>因此決定利用這邊先發文，再轉文到 ithome 的方式來處理，</p>

<p>比較順手一些，順便在這篇文章貼上規劃方向，topic 可能隨時會變，但大方向不變</p>

<p>第一次寫的主題都幾乎不是自己專精的技術，</p>

<p>規劃表如下： (Evernote 連結)</p>

<p><a href="https://www.evernote.com/l/AFFz7an43x1K46hErAgyJdD5K9BuFFMN9Dg">https://www.evernote.com/l/AFFz7an43x1K46hErAgyJdD5K9BuFFMN9Dg</a></p>

<p>因此若有錯誤也請有看到的大大們多多幫忙指正囉！</p>

<p>有時候會因為比較忙，可能文章比較精簡一些，還請大家多多包涵 :P</p>

<p>有任何文章更新也會同步在此篇文章中!</p>

<p>##RESTful API Service:
Day1  -  <a href="http://kerkerj.github.io/blog/2014/10/02/2014-10-01-api-d1/">[API-d1] - 定義 1 - 什麼是 REST/RESTful?</a><br />
Day2  -  <a href="http://kerkerj.github.io/blog/2014/10/02/2014-10-02-api-d2/">[API-d2] - 定義 2 - RESTful 的優點與要求</a><br />
Day3  -  <a href="http://kerkerj.github.io/blog/2014/10/03/2014-10-03-api-d3/">[API-d3] - 使用時機與實際 API 參考</a><br />
Day4  -  <a href="http://kerkerj.github.io/blog/2014/10/04/2014-10-04-api-d4/">[API-d4] - 使用技術與工具介紹及原因</a><br />
Day5  -  <a href="http://kerkerj.github.io/blog/2014/10/05/2014-10-05-api-d5/">[API-d5] - [Server 番外篇] 建立自己的本機虛擬伺服器 1 - Vagrant + VirtualBox 安裝</a><br />
Day6  -  <a href="http://kerkerj.github.io/blog/2014/10/06/2014-10-06-api-d6/">[API-d6] - [Server 番外篇] 建立自己的本機虛擬伺服器 2 - Ubuntu 基本設定與安裝 Node.js, MongoDB </a><br />
Day7  -  <a href="http://kerkerj.github.io/blog/2014/10/07/2014-10-07-api-d7/">[API-d7] - [Server 番外篇] 建立自己的本機虛擬伺服器 3 - 打包環境</a><br />
Day8  -  <a href="http://kerkerj.github.io/blog/2014/10/08/2014-10-08-api-d8/">[API-d8] - Node.js - Hello World!</a><br />
Day9  -  <a href="http://kerkerj.github.io/blog/2014/10/09/2014-10-09-api-d9/">[API-d9] - NVM 與 NPM 使用</a><br />
Day10 -  <a href="http://kerkerj.github.io/blog/2014/10/10/2014-10-10-api-d10/">[API-d10] - Express - Hello World!</a><br />
Day11 -  <a href="http://kerkerj.github.io/blog/2014/10/11/2014-10-11-api-d11/">[API-d11] - MongoDB - Hello World!</a><br />
Day12 -  <a href="http://kerkerj.github.io/blog/2014/10/12/2014-10-12-api-d12/">[API-d12] - MongoDB - Hello World! (Client-side) </a><br />
Day13 -  <a href="http://kerkerj.github.io/blog/2014/10/13/2014-10-13-api-d13/">[API-d13] - [Javascript 番外篇] Javascript require/ module/ Module Pattern</a><br />
Day14 -  <a href="http://kerkerj.github.io/blog/2014/10/14/2014-10-14-api-d14/">[API-d14] - [Javascript 番外篇] Javascript function scopes 和 closures</a><br />
Day15 -  <a href="http://kerkerj.github.io/blog/2014/10/15/2014-10-15-api-d15/">[API-d15] - [Javascript 番外篇] Javascript callback, event</a><br />
Day16 -  <a href="http://kerkerj.github.io/blog/2014/10/16/2014-10-16-api-d16/">[API-d16] - 實戰開發 - 設定主題及規劃</a><br />
Day17 -  <a href="http://kerkerj.github.io/blog/2014/10/17/2014-10-17-api-d17/">[API-d17] - 實戰開發 - 專案結構</a><br />
Day18 -  <a href="http://kerkerj.github.io/blog/2014/10/18/2014-10-18-api-d18/">[API-d18] - 實戰開發 - 套件模組</a><br />
Day19 -  <a href="http://kerkerj.github.io/blog/2014/10/19/2014-10-19-api-d19/">[API-d19] - 實戰開發 - index &amp; route &amp; http status code</a><br />
Day20 -  <a href="http://kerkerj.github.io/blog/2014/10/20/2014-10-20-api-d20/">[API-d20] - 實戰開發 - Routes 2, get params and request data</a><br />
Day21 -  <a href="http://kerkerj.github.io/blog/2014/10/21/2014-10-21-api-d21/">[API-d21] - 實戰開發 - 新增 TODO task API with mongoose</a><br />
Day22 -  <a href="http://kerkerj.github.io/blog/2014/10/22/2014-10-22-api-d22/">[API-d22] - 實戰開發 - 讀取 TODO task API with mongoose</a><br />
Day23 -  <a href="http://kerkerj.github.io/blog/2014/10/23/2014-10-23-api-d23/">[API-d23] - 實戰開發 - 修改 TODO task API with mongoose</a><br />
Day24 -  <a href="http://kerkerj.github.io/blog/2014/10/24/2014-10-24-api-d24/">[API-d24] - 實戰開發 - 刪除 TODO task API with mongoose</a><br />
Day25 -  <a href="http://kerkerj.github.io/blog/2014/10/25/2014-10-25-api-day25/">[API-day25] - 實戰開發 - 處理 404 &amp; 500</a><br />
Day26 -  <a href="http://kerkerj.github.io/blog/2014/10/26/2014-10-26-api-d26/">[API-d26] - 實戰開發 - API-key</a><br />
Day27 -  <a href="http://kerkerj.github.io/blog/2014/10/27/2014-10-27-api-d27/">[API-d27] - 實戰開發 - log 處理 及 config (db, apikey)</a><br />
Day28 -  <a href="http://kerkerj.github.io/blog/2014/10/28/2014-10-28-api-d28/">[API-d28] - 實戰開發 - 發佈 - forever</a><br />
Day29 -  <a href="http://kerkerj.github.io/blog/2014/10/29/2014-10-29-api-d29/">[API-d29] - 實戰開發 - 發佈 - nginx</a><br />
Day30 -  <a href="http://kerkerj.github.io/blog/2014/10/30/2014-10-30-api-d30/">[API-d30] - 總結</a></p>

<p>##Swift:
Day1  -  <a href="http://kerkerj.github.io/blog/2014/10/02/2014-10-02-swift-d1/">[Swift-d1] - 介紹</a><br />
Day2  -  <a href="http://kerkerj.github.io/blog/2014/10/02/2014-10-02-swift-d2/">[Swift-d2] - 安裝及 Hello World!</a><br />
Day3  -  <a href="http://kerkerj.github.io/blog/2014/10/03/2014-10-03-swift-d3/">[Swift-d3] - Playground - 變數與常數, 註解, 基本資料型別</a><br />
Day4  -  <a href="http://kerkerj.github.io/blog/2014/10/04/2014-10-04-swift-d4/">[Swift-d4] - Playground - Optional, ! and ? </a><br />
Day5  -  <a href="http://kerkerj.github.io/blog/2014/10/05/2014-10-05-swift-d5/">[Swift-d5] - Playground - Array, Dictionary, Controll Flow</a><br />
Day6  -  <a href="http://kerkerj.github.io/blog/2014/10/06/2014-10-06-swift-d6/">[Swift-d6] - Playground - function</a><br />
Day7  -  <a href="http://kerkerj.github.io/blog/2014/10/07/2014-10-07-swift-d7/">[Swift-d7] - Playground - Closures</a><br />
Day8  -  <a href="http://kerkerj.github.io/blog/2014/10/08/2014-10-08-swift-d8/">[Swift-d8] - Playground - Enumerations</a><br />
Day9  -  <a href="http://kerkerj.github.io/blog/2014/10/09/2014-10-09-swift-d9/">[Swift-d9] - Playground - Class, Struct</a><br />
Day10 -  <a href="http://kerkerj.github.io/blog/2014/10/10/2014-10-10-swift-d10/">[Swift-d10] 延伸閱讀</a><br />
Day11 -  <a href="http://kerkerj.github.io/blog/2014/10/11/2014-10-11-swift-d11/">[Swift-d11] - Basic - Hello World!</a><br />
Day12 -  <a href="http://kerkerj.github.io/blog/2014/10/12/2014-10-12-swift-d12/">[Swift-d12] - Basic - 基本元件 (Label, Button, UIColor, 文字輸入框)</a><br />
Day13 -  <a href="http://kerkerj.github.io/blog/2014/10/13/2014-10-13-swift-d13/">[Swift-d13] - Basic - Navigation View 1 + ViewController</a><br />
Day14 -  <a href="http://kerkerj.github.io/blog/2014/10/14/2014-10-14-swift-d14/">[Swift-d14] - Basic - Navigation View 2 + ViewController</a><br />
Day15 -  <a href="http://kerkerj.github.io/blog/2014/10/15/2014-10-15-swift-d15/">[Swift-d15] - Basic - Table View 1 直接給值 datasource, (table view scroll)</a><br />
Day16 -  <a href="http://kerkerj.github.io/blog/2014/10/16/2014-10-16-swift-d16/">[Swift-d16] - Basic - Table View 2 換頁 (delegate)</a><br />
Day17 -  <a href="http://kerkerj.github.io/blog/2014/10/17/2014-10-17-swift-d17/">[Swift-d17] - Basic - Navigation View + TableView</a><br />
Day18 -  <a href="http://kerkerj.github.io/blog/2014/10/18/2014-10-18-swift-d18/">[Swift-d18] - Basic - Customize TableViewCell</a><br />
Day19 -  <a href="http://kerkerj.github.io/blog/2014/10/19/2014-10-19-swift-d19/">[Swift-d19] - Basic - 橋接第三方 Objc library - Reachability and Bridge.h</a><br />
Day20 -  <a href="http://kerkerj.github.io/blog/2014/10/20/2014-10-20-swift-d20/">[Swift-d20] - Basic - 捨棄 Storyboard 使用純程式碼 的方式撰寫 ViewController</a><br />
Day21 -  <a href="http://kerkerj.github.io/blog/2014/10/21/2014-10-21-swift-d21/">[Swift-d21] - 實戰開發 - TODOList - 前置設定</a><br />
Day22 -  <a href="http://kerkerj.github.io/blog/2014/10/22/2014-10-22-swift-d22/">[Swift-d22] - 實戰開發 - TODOList - Show View 1</a><br />
Day23 -  <a href="http://kerkerj.github.io/blog/2014/10/23/2014-10-23-swift-d23/">[Swift-d23] - 實戰開發 - TODOList - Show View 2, Delete View</a><br />
Day24 -  <a href="http://kerkerj.github.io/blog/2014/10/24/2014-10-24-swift-d24/">[Swift-d24] - 實戰開發 - TODOList - Create View</a><br />
Day25 -  <a href="http://kerkerj.github.io/blog/2014/10/25/2014-10-25-swift-day25/">[Swift-day25] - 實戰開發 - TODOList - Update View</a><br />
Day26 -  <a href="http://kerkerj.github.io/blog/2014/10/26/2014-10-26-swift-d26/">[Swift-d26] - 實戰開發 - TODOList - API 前置資料準備</a><br />
Day27 -  <a href="http://kerkerj.github.io/blog/2014/10/27/2014-10-27-swift-d27/">[Swift-d27] - 實戰開發 - TODOList - API 2 讀取清單資料</a><br />
Day28 -  <a href="http://kerkerj.github.io/blog/2014/10/28/2014-10-29-swift-d28/">[Swift-d28] - 實戰開發 - TODOList - API 3 新增與更新</a><br />
Day29 -  <a href="http://kerkerj.github.io/blog/2014/10/29/2014-10-29-swift-d29/">[Swift-d29] - 實戰開發 - TODOList - API 4 刪除</a><br />
Day30 -  <a href="http://kerkerj.github.io/blog/2014/10/30/2014-10-30-swift-d30/">[Swift-d30] - 總結</a></p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2014/10/30/2014-10-30-swift-d30/" class="post-title">[Swift-d30] - 總結</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://blog.kerkerj.in//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>30 天下來其實中間受到不少人幫忙</p>

<p>因為第一次寫 iOS 程式，對於 iOS 的基本運作流程還是詢問了不少同事</p>

<p>包含在隔壁棚用 Cocos2d 寫 2D 遊戲的 Andy</p>

<p>還有同事 Henry 和 Felix 都給予了很大的幫忙</p>

<p>最後這隻小 app 其實 code 的品質並沒有很好</p>

<p>主要還是因為寫來 demo 用的，以及老實講也沒什麼時間寫&hellip;</p>

<p>報兩個組別真的是很鐵人哪</p>

<p>還看到隔壁棚一次報三四個主題的大大</p>

<p>真是太厲害了</p>

<p>假設明年還會參賽的話，應該還是會以單一技術來鑽研吧!</p>

<p>Swift 有蠻多特性是 Objective-C 所沒有的</p>

<p>如果有想在新專案嘗試的話</p>

<p>最好還是先多看看網路上的比較</p>

<p>避免踩到雷</p>

<p>像有一點是我們同事曾經踩到的雷</p>

<p>就是 NSDictionary V.S. Dictionary</p>

<p>兩者的速度可以差到 5, 6 倍以上</p>

<p>網路上搜尋也會發現有人在討論 Swift Dictionary 的效能差異</p>

<p>若要在新專案使用還是要查詢一下避免掉一些問題</p>

<p>另外還有就是 Swift on Xcode 的穩定度還是有待加強&hellip;</p>

<p>總而言之, 30 天結束了，ya!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2014/10/30/2014-10-30-api-d30/" class="post-title">[API-d30] - 總結</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://blog.kerkerj.in//categories/restful">restful</a><a class="post-category post-category-api" href="http://blog.kerkerj.in//categories/api">api</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>總結三十天下來的 Restful API service 建置</p>

<p>其實接觸到的東西很廣泛</p>

<p>從 server 端到程式端，還有虛擬機器的使用都有沾到邊</p>

<p>其實不管是哪個領域都是要一點一滴累積起來的</p>

<p>以這次的開發技術來說，</p>

<p>vagrant 方便在於我在和別人共享 server 環境時非常方便</p>

<p>自己在架測試環境時也可以先將乾淨的 web serser 打包起來</p>

<p>供日後隨時要用時開起來馬上 deploy 就可以使用</p>

<p>另外加上方便的網路設定，</p>

<p>在測試時非常方便</p>

<p>另外則是 nodejs，</p>

<p>這次會選擇 nodejs 主要也是想進入 javascript 的世界</p>

<p>nodejs 若作為一個後端程式語言來說，我認為是非常輕量且入門非常簡單</p>

<p>套一句最近常聽到的話</p>

<p><code>javascript is everywhere</code></p>

<p>不管是網頁前後端，nodejs 還可以拿來寫桌面應用、嵌入式系統</p>

<p>應用領域非常廣泛</p>

<p>也希望這門語言能夠更標準化，擺脫歷史包袱</p>

<p>看最近幾年的發展，其實我認為是勢在必行的</p>

<p>只缺一個領頭羊來帶領大家前往偉大的航道了! XD</p>

<p>希望三十天的分享能給大家帶來不一樣的感受~</p>

<p>對了突然想到一件事，這個主題的副標最後一句是想要和 APP 結合</p>

<p>APP 在隔壁棚啦 XD</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2014/10/29/2014-10-29-swift-d29/" class="post-title">[Swift-d29] - 實戰開發 - TODOList - API 4 刪除</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://blog.kerkerj.in//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day29">Github link</a></p>

<p>今天要處理刪除</p>

<p>其實超簡單的</p>

<p>只是想偷懶一下 XD</p>

<p>一樣將下列程式碼新增到 RestApi class:</p>

<pre><code class="language-swift">func deleteTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, todoId: String) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: NSURL(string: &quot;http://192.168.1.158:3000/user/kerkerj/todos/\(todoId)&quot;)!)
        request.HTTPMethod = &quot;DELETE&quot;
        
        var err: NSError?
        request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &quot;API-Key&quot;)
        
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary
            
            println(json)
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }

</code></pre>

<p>回到 ViewController 中的 tableView commitEditingStyle 的方法中</p>

<p>將其更新為:</p>

<pre><code>func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
        
        api.deleteTodoList({data, err -&gt; Void in
            let alert = UIAlertView()
            alert.title = &quot;Alert&quot;
            alert.addButtonWithTitle(&quot;Ok&quot;)
            
            if (err != nil) {
                alert.message = &quot;Failed to delete: \(err)&quot;
                alert.show()
            } else {
                alert.message = &quot;ok!&quot;
                
                self.fakeData.removeAtIndex(indexPath.row)
                
                dispatch_async(dispatch_get_main_queue(), {
                    // must be &quot;tableView!&quot; not &quot;tableView?&quot;
                    alert.show()
                    self.tableView!.reloadData()
                })
            }
            }, todoId: fakeData[indexPath.row][&quot;_id&quot;]!)
    }
</code></pre>

<p>改好程式碼後，執行該程式</p>

<p>在清單中將 item 往左滑，就可以看到刪除的按鈕了!</p>

<p>超簡單的啦!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2014/10/29/2014-10-29-api-d29/" class="post-title">[API-d29] - 實戰開發 - 發佈 - nginx</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://blog.kerkerj.in//categories/restful">restful</a><a class="post-category post-category-api" href="http://blog.kerkerj.in//categories/api">api</a><a class="post-category post-category-nginx" href="http://blog.kerkerj.in//categories/nginx">nginx</a><a class="post-category post-category-nodejs" href="http://blog.kerkerj.in//categories/nodejs">nodejs</a><a class="post-category post-category-express" href="http://blog.kerkerj.in//categories/express">express</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>接下來這篇就會比較偏 server 設定了！</p>

<p>nginx 是一套伺服器軟體，和 apache 並駕齊驅</p>

<p>(其實我覺得 nginx &gt;&gt;&gt; apache XD)</p>

<p>主要是 nginx 清量快速</p>

<p>我們要拿他幫 nodejs 處理接收 request 的部分，再將 request 導往 nodejs</p>

<p>所以感覺就會如下圖:</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-18%2013.14.16.png" alt="image" />
</p>

<p>可以讓 nginx 當作是 load balancer,</p>

<p>透過 reverse proxy 的方式轉發 request 給 nodejs, 讓 nginx 承受流量</p>

<p>這就是我們今天要做的事情，</p>

<p>所以首先，我們就要先裝 nginx，因此就先進虛擬機吧!</p>

<pre><code class="language-javascript">$ sudo apt-get update &amp;&amp; sudo apt-get upgrade -y
$ sudo apt-get install nginx 
</code></pre>

<p>這樣就會安裝一個 nginx 了!</p>

<p>Nginx 的設定檔都是放在 <code>/etc/nginx/</code> 底下</p>

<p>個別網站的設定放在 <code>/etc/nginx/sites-available</code></p>

<p>如果要讓該網站上線，則會將 <code>/etc/nginx/sites-available</code> 的設定檔 link 到 <code>/etc/nginx/sites-enable</code></p>

<p>因此若想自己新增設定檔的話，慣例是會在 available 新增，然後再 link 到 <code>enable</code></p>

<p>如果我們進到 <code>/etc/nginx/sites-enable</code> 的話，裡面應該已經有一個 <code>default</code> 的設定檔了</p>

<pre><code>$ sudo vim /etc/nginx/sites-enable/default
</code></pre>

<p>內容應該是:</p>

<pre><code>server {
        listen 80 default_server;
        listen [::]:80 default_server ipv6only=on;

        root /usr/share/nginx/html;
        index index.html index.htm;

        # Make site accessible from http://localhost/
        server_name localhost;

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ =404;
                # Uncomment to enable naxsi on this location
                # include /etc/nginx/naxsi.rules
        }

        # Only for nginx-naxsi used with nginx-naxsi-ui : process denied requests
        #location /RequestDenied {
        #       proxy_pass http://127.0.0.1:8080;
        #}
        
        ...
}
</code></pre>

<p>將設定檔改成如下:</p>

<pre><code>upstream nodejs {
  server 127.0.0.1:3000;
  #server 127.0.0.1:3001;
}

server {
    listen 80;

    server_name localhost;

    location / {
        proxy_pass http://nodejs;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
</code></pre>

<p>解釋一下以下這段:</p>

<pre><code>upstream nodejs {
  server 127.0.0.1:3000;
  #server 127.0.0.1:3001;
}
</code></pre>

<p>下面這段則是 proxy pass 的部分, 會將 <code>/</code> 的流量導到 nodejs 的 server cluster 裡面，不過因為我們現在只有一台 server 開起來，所以只會被導到 3000 port 的那台機器</p>

<pre><code>location / {
        proxy_pass http://nodejs;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
</code></pre>

<p>如果 nodejs server 的承載量不夠，可以開好幾檯，只要 port 不一樣即可</p>

<p>這樣就可以建立一個 nodejs cluster</p>

<p>再來使用 forever 開啓 nodejs server</p>

<p>再重新開啟 nginx</p>

<p>使用 postman 戳戳看 API</p>

<p>就成功囉~~</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2014/10/28/2014-10-28-api-d28/" class="post-title">[API-d28] - 實戰開發 - 發佈 - forever</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://blog.kerkerj.in//categories/restful">restful</a><a class="post-category post-category-api" href="http://blog.kerkerj.in//categories/api">api</a><a class="post-category post-category-nodejs" href="http://blog.kerkerj.in//categories/nodejs">nodejs</a><a class="post-category post-category-express" href="http://blog.kerkerj.in//categories/express">express</a><a class="post-category post-category-forever" href="http://blog.kerkerj.in//categories/forever">forever</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day28">Github 參考</a></p>

<p>接下來兩天要講 deploy 的部分</p>

<p>由於 deploy 的 script 其實非常的麻煩，因此我們就不提 deploy 的 script 了</p>

<p>我們只專注在 server 上需要什麼東西</p>

<p>今天要來看看 <code>forever</code> 這個套件</p>

<p>這個套件可以幫助 nodejs 的 server 遇上無預警的 server 掛掉時</p>

<p>會幫你自動重新啟動 nodejs 的 server</p>

<p>也就是說</p>

<p>假設說 nodejs 寫的 server 某個 route 有問題，</p>

<p>送 request 後會因為某些因素造成 server error 造成程式碼 crash 時</p>

<p>forever 的 monitor 會偵測到，並幫你自動重啟 server</p>

<p>至少不會造成其他正常存取 server 的使用者遭遇到 server down 的問題</p>

<p>這個套件可以選擇裝在 global 或是 project</p>

<p>在這邊我是選擇裝成 global</p>

<p>進到虛擬機</p>

<pre><code class="language-javascript">$ npm install -g forever
</code></pre>

<p>p.s. 如果遇到問題，試著跑下面的指令看看?</p>

<pre><code>$ sudo chown vagrant:vagrant -R ~/.npm/
</code></pre>

<p>接下來我們就可以使用 <code>forever</code> 這個指令了!</p>

<p>原本我們要啟動 server 的話</p>

<p>是要下:</p>

<pre><code>$ npm start 
</code></pre>

<p>同義於:</p>

<pre><code>$ node ./bin/server.js
</code></pre>

<p>如果要改用 <code>forever</code> 的話:</p>

<pre><code>// 記得先到專案根目錄
$ forever start bin/server.js
warn:    --minUptime not set. Defaulting to: 1000ms
warn:    --spinSleepTime not set. Your script will exit if it does not stay up for at least 1000ms
info:    Forever processing file: ./bin/server.js
</code></pre>

<p>然後就會被丟到背景執行了</p>

<p>那要怎麼知道我的 server 有跑起來呢?</p>

<pre><code>$ forever list
info:    Forever processes running
data:        uid  command                              script        forever pid   logfile                         uptime
data:    [0] 6qhd /home/vagrant/.nvm/v0.10.32/bin/node bin/server.js 13746   13748 /home/vagrant/.forever/6qhd.log 0:0:0:47.743
</code></pre>

<p>就會列出相關資訊以及 forever 自己的 log file 位置</p>

<p>要關閉的話:</p>

<pre><code>$ forever stop bin/server.js
info:    Forever stopped process:
data:        uid  command                              script        forever pid   logfile                         uptime
[0] 6qhd /home/vagrant/.nvm/v0.10.32/bin/node bin/server.js 13746   14061 /home/vagrant/.forever/6qhd.log 0:0:0:6.595
</code></pre>

<p><code>bin/server.js</code> 也可以替換成 forever uid 或 pid</p>

<p>如果要重開的話</p>

<pre><code>$ forever restart bin/server.js
</code></pre>

<p>超簡單!</p>

<p>這樣就可以不用擔心 server 突然掛掉了&hellip;.嗎?</p>

<p>錯，還是必須要監控 server 狀態</p>

<p>畢竟，<code>forever</code> 也是會有 bug 的</p>

<p>所以自己的 server 自己顧</p>

<p>真正應用在 production 環境還是必須要監控的</p>

<p>今天就分享到這啦!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://blog.kerkerj.in/blog/2014/10/28/2014-10-28-swift-d28/" class="post-title">[Swift-d28] - 實戰開發 - TODOList - API 3 新增與更新</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://blog.kerkerj.in//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="day28">Github link</a></p>

<p>昨天做了 get list</p>

<p>今天就來做 新增和儲存吧!</p>

<p>可能有人會問說，那讀取一筆 todo 的 API 呢?</p>

<p>因為在這邊資料量少，所有的東西都可以從最外層的 list 拿到</p>

<p>所以雖然有換頁的動作，但是節省流量可以不需要實做這件事</p>

<p>在實際開發中也會如此，case by case，有些情況一次拿完回來處理最好</p>

<p>不過有些則不是~</p>

<p>離題了，</p>

<p>以下是新增 todo 的程式碼:</p>

<p>先到 RestApi.swift 新增 post function</p>

<pre><code class="language-swift">func addTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, content: String) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: self.addTodoUrl!)
        request.HTTPMethod = &quot;POST&quot;
        
        var params = [&quot;content&quot;: content] as Dictionary&lt;String, String&gt;
        
        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;err)
        request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &quot;API-Key&quot;)
        
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }
</code></pre>

<p>再來就是在程式中呼叫這隻 API 囉! 我們會在 UpdateViewController 中做這件事</p>

<p>因為這隻 controler 處理了 &ldquo;Add&rdquo; 和 &ldquo;Update&rdquo; 兩件事</p>

<p>在 save() 這個 function 裡面修改成:</p>

<pre><code>// 記得 class 中先產生一個 api 物件
var api = RestApi()

func save() {
        if from == &quot;add&quot; {
            api.addTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&quot;done&quot;)
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == &quot;edit&quot; {
            println(&quot;Save edited data&quot;)
        }
    }
</code></pre>

<p>打開執行就可以新增 todo 了!</p>

<p>&ldquo;Update&rdquo; 的行為和新增一樣</p>

<p>先到 RestApi class 加入 update 的方法:</p>

<pre><code>func updateTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, content: String, todoId: String) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: NSURL(string: &quot;http://192.168.1.158:3000/user/kerkerj/todos/\(todoId)&quot;)!)
        request.HTTPMethod = &quot;PUT&quot;
        
        var params = [&quot;content&quot;: content] as Dictionary&lt;String, String&gt;
        
        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;err)
        request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &quot;API-Key&quot;)
        
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }
</code></pre>

<p>再到剛剛的 UpdateViewController ，把 save() 的另外一個 &ldquo;edit&rdquo; 的區塊改成下面的程式碼</p>

<pre><code>else if from == &quot;edit&quot; {
            println(&quot;Save edited data&quot;)
            api.updateTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&quot;done&quot;)
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })
                
            }, content: self.textField.text, todoId: self.index)
        }
</code></pre>

<p>所以整個 save() 會長這樣:</p>

<pre><code>func save() {
        if from == &quot;add&quot; {
            api.addTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&quot;done&quot;)
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == &quot;edit&quot; {
            println(&quot;Save edited data&quot;)
            api.updateTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }
                
                dispatch_async(dispatch_get_main_queue(), {
                    println(&quot;done&quot;)
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })
                
            }, content: self.textField.text, todoId: self.id
        }
    }
</code></pre>

<p>在這邊要再修改一個之前的 bug Orz</p>

<p>由於我們要更新的時候，必須要使用到該筆資料的 object id</p>

<p>我們之前在 view 中傳遞的都是 content，都沒有 id，因此要加進去</p>

<p>首先要先改的地方是</p>

<p>ViewController 中的</p>

<pre><code>showViewController.id = fakeData[indexPath.row][&quot;id&quot;]

// 改成:
showViewController.id = fakeData[indexPath.row][&quot;_id&quot;]
</code></pre>

<p>因為在 mongodb 中 object id 的名字是 _id</p>

<p>再來要在 ShowViewController 中加入一個把 id 傳到 UpdateViewController</p>

<p>在 ShowViewController 中的 editTODO() 加入:</p>

<p>(因為之前 showView 就已經有拿到 id 了，只是先前的欄位寫錯，加上沒有將 id pass 到 UpdateViewControler 才會發生這種事 XD)</p>

<pre><code>editViewContronller.id = self.id
</code></pre>

<p>應該只有改這樣，最後執行看看</p>

<p>就發現可以編輯成功囉!</p>

<p>快結束啦!</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 14</span>
    
      <a href="http://blog.kerkerj.in/page/2/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://blog.kerkerj.in//js/all.min.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>

        </div>
    </div>
</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-45583907-2', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
