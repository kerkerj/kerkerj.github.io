<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://kerkerj.github.io/">
    <meta property="og:title" content="kerkerj">
    
    <meta property="og:description" content="hugo hugo - 快速又現代的靜態網站產生器 ^^^ 這是 spf13 自己說的 繼 spf13-vim 後又一個 spf13 出品的好東西 XD 在靜態網站產生器中最廣為人知的應該就是 Jekyll 以及基於 Jekyll 的 Octopress 了 (關於靜態網站產生器，這篇文章 介紹了六個除了 Jekyll 以外的產生器) 為什麼要用 hugo？ 雖然 Jekyll / Octopress 很紅資源多主題也不少 但是缺點就是要使用它們就必須裝 ruby、裝 gem 有在寫 ruby 的人感覺應該還好 沒在寫 ruby 的光想像就覺得應該會被搞死&hellip; XD 而且覺得文章一多時在編譯的時候好慢&hellip; 用 hugo 的好處就是因為他是用 go 寫的 執行速度飛快，而且只要下載一個 binary 檔案後就可以操作了喲~ 基本 hugo 安裝與操作 首先先安裝 hugo (我是用 mac 的 homebrew) $ brew install hugo 使用 hugo 產生一個新的網站 $ hugo new site /path/to/the/site e.g.">
    
    
    
    <meta property="og:site_name" content="kerkerj">

    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="kerkerj" />
    <meta name="twitter:title" content="kerkerj &middot; kerkerj">
    <meta name="twitter:description" content="Hi.">

    
    <title>kerkerj &middot; kerkerj</title>

    
    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    
    
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    

    <link rel="stylesheet" href="http://kerkerj.github.io//css/all.min.css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    
    
      <link rel="stylesheet" href="http://kerkerj.github.io//css/highlight/railscasts.css">
    

    
    <link href="http://kerkerj.github.io/favicon.ico" rel="icon">

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://kerkerj.github.io//index.xml">
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://kerkerj.github.io/">kerkerj</a></h1>
            <h2 class="brand-tagline"> Hi. </h2>
        </hgroup>

        <nav class="nav">
            
            <ul class="pure-menu-list">
              
              
                <li class="pure-menu-link">
                  <a href="http://kerkerj.github.io//notes/">Notes</a>
                </li>
              
                <li class="pure-menu-link">
                  <a href="http://kerkerj.github.io//about/">About</a>
                </li>
              
                <li class="pure-menu-link">
                  <a href="http://kerkerj.github.io//mac-app-list/">Mac App List</a>
                </li>
              
            </ul>

            
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="http://twitter.com/kerkerj"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="http://github.com/kerkerj "><i class="fa fa-github-alt"></i> Github</a>
                </li>
                
                
                
                <li class="nav-item">
                    <a class="pure-button" href="http://kerkerj.github.io/index.xml"><i class="fa fa-rss-alt"></i> RSS</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/08/2014-10-08-api-d8/" class="post-title">[API-d8] - Node.js - Hello World!</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a><a class="post-category post-category-nodejs" href="http://kerkerj.github.io//categories/nodejs">nodejs</a><a class="post-category post-category-node" href="http://kerkerj.github.io//categories/node">node</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="node-js-hello-world:e95c172dc9aeb9ea8e227904633c9cb4">Node.js - Hello World!</h1>

<p>一樣先開虛擬機哦~</p>

<p>並且開啟終端機連進 server 裡面~</p>

<p>以下是 <a href="http://nodejs.org/">Node.js</a> 官方網站的 web server 程式範例，我稍作小修改：</p>

<pre><code class="language-javascript">var http = require('http');

http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(1337, '0.0.0.0');

console.log('Server running at http://0.0.0.0:1337/');
</code></pre>

<p>我們先在虛擬機的資料夾建立一個子資料夾 &lsquo;HelloWorld&rsquo;</p>

<p>在 HelloWorld 資料夾裡面建立一個 app.js</p>

<p>內容如上，存檔。</p>

<p>使用終端機進入 server :</p>

<pre><code>$ vagrant ssh
$ cd /vagrant/HelloWorld
$ node app.js
</code></pre>

<p>到瀏覽器輸入 <a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a></p>

<p>(或者是你的 Vagrantfile 裡面設定的 private IP)</p>

<p>即可看到 Hello World 了！</p>

<p>要關掉 Server 也非常簡單，回到下指令的地方，按下 ctrl + c 即可中斷程式</p>

<h2 id="分析:e95c172dc9aeb9ea8e227904633c9cb4">分析</h2>

<p>簡單分析一下此段程式：</p>

<pre><code class="language-javascript">var http = require('http');
</code></pre>

<p>將 http 這個模組引入，並指定給物件 http</p>

<pre><code class="language-javascript">http.createServer(
	...
).listen(1337, '0.0.0.0');
</code></pre>

<p>先略過中間的 function 不看，<br />
這段 code 的用意即是讓呼叫 http 物件中的 createServer 的方法，
.listen() 則是設定該 server 要跑在哪個 port、hostname</p>

<pre><code class="language-javascript">function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}
</code></pre>

<p>上面的 code 則是原本在 .createServer() 裡的，
我們可以看一下 Node.js 的 API doc <a href="http://nodejs.org/api/http.html#http_http_createserver_requestlistener">關於此方法的部分</a></p>

<p>.createServer() 要帶入的東西其實是一個 requestListener，<br />
也就是當 Server 跑起來時，我們開啟瀏覽器，輸入 127.0.0.1:1337 時，<br />
Node.js Server 要回丟的東西，因此觀察一下此 listener:</p>

<pre><code class="language-javascript">function (req, res) {
	...
}
</code></pre>

<p>function 中帶入參數的是 req, res，意即 request, response，<br />
request 即是 server 接收到 client 端的訊息，<br />
response 則是 server 要回丟給 client 的訊息，<br />
由於在此範例中，我們只是要回丟給 client 端一個 hello world 的訊息，
因此，我們不處理 client 送給 server 的 request，
我們只需處理要回丟給 client 的訊息，</p>

<pre><code class="language-javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World\n');
</code></pre>

<p>寫網頁的開發者應該對一些關鍵字例如 Content-type, text/plain 不陌生，<br />
第一行代表回傳給使用者的訊息中，HTTP HEAD 的設定是 http status code 200,
並且 Content-type 設定為 text/plain</p>

<pre><code class="language-javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
</code></pre>

<p>那麼，以下這行 code 的意思即是，此次要回送給使用者的訊息到這裡結束，以 &ldquo;Hello World&rdquo; 作結尾</p>

<pre><code class="language-javascript">res.end('Hello World\n');
</code></pre>

<p>因此整段 code 看下來，就是一個非常簡單的 http server，</p>

<p><a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a> 總是會回傳 Hello World</p>

<p>今天就完成了我們的 Hello World 了!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/07/2014-10-07-api-d7/" class="post-title">[API-d7] - [Server 番外篇] 建立自己的本機虛擬伺服器 3 - 打包環境</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>昨天我們已經把一個全新乾淨的環境架起來了</p>

<p>這時候我們不希望因為日後的操作導致 Server 環境髒掉，又要重灌</p>

<p>因此我們今天就來練習一下如何使用 vagrant 打包環境!</p>

<p>##Vagrant 打包</p>

<p>一樣先進入虛擬機資料夾，先確保虛擬機沒有在運作:</p>

<pre><code>$ vagrant status
Current machine states:

default                   poweroff (virtualbox)

The VM is powered off. To restart the VM, simply run `vagrant up`
</code></pre>

<p>如果是 poweroff 的話，就可以進行接下來的動作，如果是其他狀態的話，就先下關機指令囉</p>

<pre><code>$ vagrant package
==&gt; default: Clearing any previously set forwarded ports...
==&gt; default: Exporting VM...
==&gt; default: Compressing package to: /Users/.../ithome/package.box
</code></pre>

<p>vagrant 就會在虛擬機器資料夾底下建立一個 package.box</p>

<p>這個檔案就是整個伺服器環境的檔案了!</p>

<p>假設今天想要讓團隊成員使用，只要他們都有 VirtualBox + Vagrant 的話，</p>

<p>就可以依循下面的指令步驟將你所做的 box 匯入並使用：</p>

<p>首先我們可以先看看原本所使用的 box 清單:</p>

<pre><code>$ vagrant box list
ubuntu/trusty64                          (virtualbox, 14.04)
</code></pre>

<p>是 <code>ubuntu/trusty64</code> 沒錯！</p>

<p>那麼我們現在想要加入剛剛所製作的 box ，並重新命名：</p>

<pre><code>$ vagrant box add my_box package.box
==&gt; box: Adding box 'my_box' (v0) for provider:
    box: Downloading: file:///Users/.../ithome/package.box
==&gt; box: Successfully added box 'my_box' (v0) for 'virtualbox'!
</code></pre>

<p>此時再看看 box 清單:</p>

<pre><code>$ vagrant box list
ubuntu/trusty64                          (virtualbox, 14.04)
my_box                                   (virtualbox, 0)
</code></pre>

<p>就會多一個了!</p>

<p><code>vagrant box add my_box package.box</code></p>

<p>這個指令的意思是將 <code>package.box</code> 加入 box 清單，並以 my_box 命名</p>

<p><code>package.box</code> 可以是本機路徑，也可以是網址，</p>

<p>如果要分享給團隊成員使用，就可以使用 url 分享，其他人就可以下指令來下載 box 並加入 box list</p>

<p>例如:</p>

<pre><code>$ vagrant box add my_box http://my_dropbox.com/package.box
</code></pre>

<p>接著其他人就可以建立自己的虛擬機資料夾，並且到該資料夾中下指令就可以初始化虛擬機器了，例如：</p>

<pre><code>$ mkdir ~/my_machine/
$ cd ~/my_machine/
$ vagrant init my_box 
</code></pre>

<p>超方便的啦～</p>

<p>如果想要從 box list 中刪除不需要的 box，下此指令即可：</p>

<pre><code>$ vagrant box remove my_box
Are you sure you want to remove this box? [y/N] y
</code></pre>

<p>上面只會刪除 box 清單，</p>

<p>如果要刪除虛擬機器資料夾，以及虛擬機器的所有檔案的話，先到虛擬機器資料夾，然後下此指令：</p>

<pre><code>$ vagrant destroy
    default: Are you sure you want to destroy the 'default' VM? [y/N] y
</code></pre>

<p>虛擬機就會被移除，再來只要將該資料夾砍掉即可～ 就恢復成乾乾淨淨的了~</p>

<p>是不是很方便勒~~</p>

<p>接下來我們就會開始先寫寫 Node.js 的 Hello World 囉~</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/07/2014-10-07-swift-d7/" class="post-title">[Swift-d7] - Playground - Closures</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>閉包表達式語法：</p>

<pre><code class="language-swift">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<p>舉個例子:</p>

<pre><code>func multiple(value: Int, multiple: Int -&gt; Int) -&gt; Int {
    return multiple(value)
}

multiple(3, { (value) -&gt; Int in
    value * 3
})
</code></pre>

<p>在 <code>multiple</code> function 中需要傳入一個 <code>function</code></p>

<p>在這邊我們並沒有另外定義，而是直接使用閉包的方式傳入一個 <code>function</code></p>

<p>這個閉包就符合了上面的定義</p>

<p>##根據上下文判斷型別 (Inferring type from context)</p>

<p>承上一個例子，我們可以寫得更簡潔一點</p>

<pre><code>multiple(3, { value in
    value * 3
})
</code></pre>

<p>這是因為 Swift 會根據兩邊的定義來判斷型別，因此可以寫得更簡潔一些</p>

<p>###參數名稱縮寫, 運算子函式</p>

<p>直接看例子</p>

<pre><code>func biggerThan0(value: Int, isBigger: Int -&gt; Bool) -&gt; Bool {
    return isBigger(value)
}

biggerThan0(-1,
    { $0 &gt; 0 }
)
</code></pre>

<p>###尾隨閉包 (trailing closures)</p>

<p>通常如果閉包太長的話，可以把閉包接在括號後面：</p>

<pre><code>func someFunc(closure: () -&gt; ()) {
	// main
}

someFunc({
	// closure main
})

somFunc() {
	// closure main
}
</code></pre>

<p>以上面的例子做例子:</p>

<pre><code>func biggerThan0(value: Int, isBigger: Int -&gt; Bool) -&gt; Bool {
    return isBigger(value)
}

biggerThan0(-1) { $0 &gt; 0 }
</code></pre>

<p>如果是不需要參數的話，甚至可以把 () 省略掉</p>

<p>這邊直接參考一下別人的例子，是使用 array map 方法</p>

<p>下面要做的事情是</p>

<p>將 [16,58,510] 轉成 [&ldquo;OneSix&rdquo;, &ldquo;FiveEight&rdquo;, &ldquo;FiveOneZero&rdquo;]</p>

<pre><code>let digitNames = [
    0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;,   3: &quot;Three&quot;, 4: &quot;Four&quot;,
    5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;
]

let numbers = [16, 58, 510]

let strings = numbers.map {
    (var number) -&gt; String in
    var output = &quot;&quot;
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
</code></pre>

<p>這個例子中，array 的 map 會用後面接的閉包，接連的處理陣列裡面的元素</p>

<p>所以最後 strings 的陣列就是處理過後的陣列</p>

<p>而處理的方法則是將 Int 的每個位數分別轉換成 String 連接起來再回傳</p>

<p>很方便的方法!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/06/2014-10-06-api-d6/" class="post-title">[API-d6] - [Server 番外篇] 建立自己的本機虛擬伺服器 2 - Ubuntu 基本設定與安裝 Node.js, MongoDB</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        

<h1 id="server-番外篇-建立自己的本機虛擬伺服器-2-ubuntu-基本設定與安裝-node-js-mongodb:86f691637d0cc1a9e2829cee005f2907">[Server 番外篇] 建立自己的本機虛擬伺服器 2 - Ubuntu 基本設定與安裝 Node.js, MongoDB</h1>

<p>嗨又到了 Server 時間了!</p>

<p>接下來我們都會做一些指令操作，</p>

<p>如果進一步有興趣的可以 Google 鳥哥的私房菜，</p>

<p>完整的 Linux 操作教學，淺顯易懂，想學習操作 linux OS 的話必看！</p>

<p>今天我們要稍稍整理一下昨天剛安裝完的 Ubuntu 作業系統，以及安裝一些我們需要用到的東西</p>

<p>首先我們的第一步就是先開啟終端機，到昨天放 Vagrantfile 的資料夾:</p>

<pre><code>$ cd ~/ithome/
</code></pre>

<p>開啟 Ubuntu</p>

<pre><code>$ vagrant up
</code></pre>

<p>順帶一提，有時候開機時可能會卡在一個地方：</p>

<pre><code>default: Warning: Connection timeout. Retrying...
default: Warning: Connection timeout. Retrying...
default: Warning: Connection timeout. Retrying...
</code></pre>

<p>這個就稍微等一下吧~ 如果電腦性能比較差的話可能會卡比較久，不過應該不至於會卡超過 10 分鐘</p>

<p>如果卡超過十分鐘可能要強制中斷，並且尋找解決辦法了～</p>

<p>開機完成後就登入吧!</p>

<pre><code>$ vagrant ssh
...
vagrant@vagrant-ubuntu-trusty-64:~$
</code></pre>

<p>##Ubuntu 套件, 設定時區</p>

<p>今天就要來幫 Ubuntu 安裝一些東西，</p>

<p>首先先產生 locale file for zh_TW</p>

<pre><code>$ sudo locale-gen zh_TW.UTF-8
</code></pre>

<p>更新檔案清單並安裝更新, 移除更新後不需要的套件:</p>

<pre><code>$ sudo apt-get update &amp;&amp; sudo apt-get -y upgrade
$ sudo apt-get -y autoremove
</code></pre>

<p>再來是安裝一些常用的套件 如 git, curl, vim 等等:</p>

<pre><code>$ sudo apt-get -y install build-essential vim git-core curl autoconf libssl-dev
</code></pre>

<p>設定時區, 照著指令選就好了~</p>

<pre><code>$ sudo dpkg-reconfigure tzdata
...

// 選擇完畢後, 輸入 date 指令來查詢伺服器時間
$ date
Sat Oct  6 20:47:03 CST 2014
</code></pre>

<p>##Node.js 安裝</p>

<p>我們使用了 ppa 以安裝最新的 Node.js 版本:</p>

<pre><code>// 加入 ppa
$ sudo add-apt-repository ppa:chris-lea/node.js
 Evented I/O for V8 javascript. Node's goal is to provide an easy way to build scalable network programs
 More info: https://launchpad.net/~chris-lea/+archive/ubuntu/node.js
Press [ENTER] to continue or ctrl-c to cancel adding it
(要再按一下 enter)

// 因為加入新的檔案清單來源了，所以重新更新 ubuntu 的檔案清單
$ sudo apt-get update

// 安裝 nodejs
$ sudo apt-get -y install nodejs
</code></pre>

<p>這樣就完成安裝了!</p>

<p>確認一下版本是否安裝成功:</p>

<pre><code>$ node -v 
v0.10.32 

$ npm -v 
1.4.28
</code></pre>

<p>ya! 這樣 Ubuntu 就有 node.js 了!</p>

<p>##MongoDB</p>

<p>再來就是要安裝 MongoDB 了!</p>

<p>我們參考 MongoDB <a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/">官方網站的文件</a></p>

<pre><code>//加入 apt-key
$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10


// 新增一個來源清單，並將 mongodb 的來源寫進該來源清單
$ echo 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' | sudo tee /etc/apt/sources.list.d/mongodb.list

// 重新更新來源清單
$ sudo apt-get update

// 安裝 mongodb
$ sudo apt-get install -y mongodb-org
</code></pre>

<p>安裝完成後 Mongo db 就會跑起來了，從以下指令可以得知</p>

<pre><code>$ ps aux | grep mongo
</code></pre>

<p>順便確認一下版本:</p>

<pre><code>$ mongod --version
db version v2.6.4
2014-10-04T06:31:01.553+0000 git version: 3a830be0eb92d772aa855ebb711ac91d658ee910

$ mongo --version
MongoDB shell version: 2.6.4
</code></pre>

<p>MongoDB 除了安裝了 DB 本身，還提供了指令提供操作，稱之為 MongoDB Shell，</p>

<p>方便我們使用 Shell 進去 DB 裡面做 DB 操作</p>

<p>以下是 mongodb service 的指令:</p>

<pre><code>// 開啟 mongodb
$ sudo service mongod start

// 關閉 mongodb
$ sudo service mongod stop

// 重啟 mongodb
$ sudo service mongod restart
</code></pre>

<p>好啦~ 今天就先到這，記得把虛擬機器關起來~</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/06/2014-10-06-swift-d6/" class="post-title">[Swift-d6] - Playground - function</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>#Playground - function</p>

<p>來看看 Swift 各種 function 的寫法吧!</p>

<p>Swift 使用 <code>func</code> 當作宣告的保留字</p>

<p>GOLANG 的 fu&hellip;. XD</p>

<p>寫 Swift 的 function 會很開心</p>

<p>##基本的</p>

<pre><code class="language-swift">func say() {
	println(&quot;Hello!&quot;)
}
</code></pre>

<p>##有一個回傳值的</p>

<pre><code class="language-swift">func say() -&gt; String {
	return &quot;Hello!&quot;
}
</code></pre>

<p>##有多個回傳值的!!! (就是回傳 Tuple)</p>

<pre><code class="language-swift">func say() -&gt; (String, Int) {
	let greeting = &quot;hello&quot;
	let times = 5
	return (greeting, times)
}

say()
</code></pre>

<p>##有參數的</p>

<pre><code class="language-swift">func say(g: String) {
	println(g)
}

say(&quot;Hello&quot;)
</code></pre>

<p>多個參數</p>

<pre><code class="language-swift">func say(g: String, times: Int) {
	for index in 1...times {
		println(g)
	}
}

say(&quot;Hello&quot;, 3)
</code></pre>

<p>##有參數的進階版</p>

<pre><code class="language-swift">func say(greetings g: String) {
	println(g)
}

say(&quot;Hello&quot;, 3)
</code></pre>

<p>此時如果同樣使用 <code>say(&quot;hello&quot;)</code> 會出錯</p>

<p>因為我們剛剛宣告了外部參數名稱</p>

<p>因此需要:</p>

<pre><code class="language-swift">say(greetings: &quot;hello&quot;)
</code></pre>

<p>這種寫法在必須代入許多參數時，非常好用，會讓程式可讀性變高</p>

<p>另外，方便起見，也可以加上 <code>#</code>，表示外部參數名稱與 func 內部名稱是一樣的</p>

<pre><code class="language-swift">func say(greetings g: String, #times: Int) {
    for index in 1...times {
        println(g)
    }
}
say(greetings: &quot;Hello&quot;, times: 3)
</code></pre>

<p>可以看到第一種寫法和第二種寫法是一樣的功用~</p>

<p>##給參數預設值</p>

<pre><code class="language-swift">func say(greetings g: String = &quot;hello&quot;) {
	println(g)
}

say()
</code></pre>

<p>如果呼叫 <code>say()</code> 而沒有給定參數時，會直接使用預設值</p>

<p>##常數參數與變數參數</p>

<p>簡單看一下以下的程式碼</p>

<pre><code class="language-swift">func say(greetings: String = &quot;hello&quot;) {
    greetings = &quot;\(greetings), welcome!&quot;
    println(greetings)
}

let greetings = &quot;Hello!&quot;
say(greetings: greetings)
</code></pre>

<p>我們定義了一個常數，代入 say() 裡面，</p>

<p>但是 say function 裡面必須改變代入的值，於是這個時候 Xcode 就會該了</p>

<p>那要怎麼辦呢?</p>

<p>修改成:</p>

<pre><code class="language-swift">func say(var greetings: String = &quot;hello&quot;) {
    greetings = &quot;\(greetings), welcome!&quot;
    println(greetings)
}

let greetings = &quot;Hello!&quot;
say(greetings: greetings)
</code></pre>

<p>多加一個 <code>var</code> 宣告，就會 copy 一份傳入，就可以更改值了!</p>

<p>一樣是非常有用的語法!</p>

<p>##輸入輸出函數</p>

<p>直接看例子</p>

<pre><code class="language-swift">func swapInt(inout a: Int, inout b: Int) {
    let tmpA = a
    a = b
    b = tmpA
}

var a = 1
var b = 2

swap(&amp;a, &amp;b)

println(a)
println(b)
</code></pre>

<p>酷吧</p>

<p>##function types 函式型別</p>

<p>直接看例子</p>

<pre><code class="language-swift">func addTwoInt(a: Int, b: Int) -&gt; Int {
    return a + b
}

func mTwoInt(a: Int, b: Int) -&gt; Int {
    return a * b
}

func printHello() {
    println(&quot;Hello World&quot;)
}

var mathFunction: (Int, Int) -&gt; Int = addTwoInt

println(&quot;result: \(mathFunction(2, 3))&quot;)
</code></pre>

<p>前面宣告了三個 function ，</p>

<p>而</p>

<pre><code class="language-swift">var mathFunction: (Int, Int) -&gt; Int = addTwoInt
</code></pre>

<p>後面的這句的意思是:</p>

<p>我們定義了一個變數叫做 <code>mathFunction</code>，</p>

<p>他的型別是「一個 (Int, Int) 的參數，並且回傳 Int」的 function，</p>

<p>簡單說就是 mathFunction 的型別是一個 Function</p>

<p>並指向 addTwoInt 這個 function</p>

<p>所以上面的例子中，<code>mathFunction</code> 代入的 <code>(2, 3)</code> 會丟給 addTwoInt，</p>

<p>並且最後回傳 Int</p>

<p>有 javascript 的味道:</p>

<pre><code class="language-javascript">var test = function(a, b) {
  return a + b;
};

var add = test;

console.log(&quot;result = &quot; + add(2, 3));
</code></pre>

<p>##function as parameter types</p>

<p>函式也可以拿來當做參數傳入函式中，</p>

<p>接續上面的例子，加入：</p>

<pre><code>func printResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int )  {
    println(&quot;Result: \(mathFunction(a, b))&quot;)
}
printResult(mathFunction, 2, 3)
</code></pre>

<p>##function as return type</p>

<p>函式也可以拿來當做回傳值</p>

<p>就是在原本的回傳符號 <code>-&gt;</code> 後面代入函式型別</p>

<p>這邊直接借別人的例子來參考吧</p>

<pre><code>// 定義兩個 function 
func stepForward(input: Int) -&gt; Int {
    return input + 1
}
func stepBackward(input: Int) -&gt; Int {
    return input - 1
}

// 再定義一個 function ，透過布林值導往上面不同的 function
func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    return backwards ? stepBackward : stepForward
}

var currentValue = 3

// 將 chooseStepFunction 指給 moveNearerToZero
// 所以 moveNearerToZero 現在是一個 function 了!
let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)

println(&quot;Counting to zero:&quot;)
// Counting to zero:
while currentValue != 0 {
    println(&quot;\(currentValue)... &quot;)
    currentValue = moveNearerToZero(currentValue)
}
println(&quot;zero!&quot;)
</code></pre>

<p>##Nested Function</p>

<p>就是 funciton 中的 function，變數有分 global、local 變數，function 也有</p>

<p>以上面的例子來改寫:</p>

<pre><code>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    return backwards ? stepBackward : stepForward
}
</code></pre>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/05/2014-10-05-api-d5/" class="post-title">[API-d5] - [Server 番外篇] 建立自己的本機虛擬伺服器 1 - Vagrant &#43; VirtualBox 安裝</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>VirtualBox 是一套虛擬軟體，可以方便幫助我們在現有的作業系統上</p>

<p>模擬另一個作業系統 (如 linux, Ubuntu, CentOS&hellip;)</p>

<p>在虛擬機器裡面所以的一切變動，都不會影響到現有的作業系統，</p>

<p>非常適合拿來做測試使用</p>

<p>由於現在大部份的 Service 除了架設在 Windows Server 外，最大宗的就是 *nix distribution 了</p>

<p>因此這在這個系列文中，也是一定要教大家如何建立起虛擬測試機器，</p>

<p>來模擬真實 Server 環境中，如何架設自己撰寫的 API Service</p>

<p>##VirtualBox</p>

<p>到 <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> 官方網站下載合適的安裝檔案吧!</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-04%2012.56.26.png" alt="p1" />
</p>

<p>安裝完成就可以了!</p>

<p>因為我們接下來會使用 Vagrant 這套 commaond line tool 來對 VirtualBox 進行操作</p>

<p>因此只要安裝完 VirtualBox 後就可以不用管他了 XD</p>

<p>##Vagrant</p>

<p><a href="https://www.vagrantup.com/">Vagrant</a></p>

<p>它可以幫助我們快速的建立一個輕量、可重複使用、並且可以打包起來帶著走的環境</p>

<p>透過編輯一個設定檔，就可以簡單設定該虛擬系統的 *nix 基本設定，如 共享資料夾、網路存取等等，</p>

<p>不需要透過 VirtualBox</p>

<p>通常這套軟體可以應用在團隊開發上：</p>

<p>以網頁開發來說，如果大家的測試環境與版本都不太一樣，例如 apache 或 php 版本不同</p>

<p>有時候會造成團隊溝通的負擔，因此透過 Vagrant 將 server 環境重新建立一套虛擬機器，</p>

<p>並且透過 Vagrant 打包，就可以丟給其他人使用，這樣一來大家的環境都一樣，</p>

<p>就可以避免這個問題，</p>

<p>而且還有一點，Server 的安裝是很累人的，同樣的事情基本上都不會想做第二遍，</p>

<p>因此打包一個乾淨的環境後備份，弄髒了可以隨時快速再把備份拿出來用，非常方便！</p>

<p>###安裝:</p>

<p>到 <a href="https://www.vagrantup.com/downloads">下載頁面</a> 尋找適合自己的下載並且安裝</p>

<p>安裝完後應該就可以在終端機中使用 vagrant 這個指令了!</p>

<pre><code>$ vagrant -v
Vagrant 1.6.5
</code></pre>

<p>目前最新的版本應該是 1.6.5</p>

<p>###建立自己的虛擬機器</p>

<p>首先在自己想要建立虛擬機器的地方先開一個資料夾</p>

<pre><code>$ mkdir ~/ithome/ 
</code></pre>

<p>切換到該資料夾</p>

<pre><code>$ cd ~/ithome
</code></pre>

<p>使用 vagrant 初始化這個資料夾，並且指定我們要使用 Ubuntu 14.04 版本</p>

<pre><code>$ vagrant init ubuntu/trusty64
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.
</code></pre>

<p>如果想要使用別種 *nix 版本可以到這裡找 - <a href="https://vagrantcloud.com/discover/featured">VagrantCloud</a></p>

<p>下完 <code>vagrant init ubuntu/trusty64</code> 指令後，指令告訴你有一個檔案叫做 <code>Vagrantfile</code> 被建立在這個資料夾裡了，</p>

<p>可以使用 <code>vagrant up</code> 來開啟虛擬機器</p>

<p>不過我們先不要下開機指令，我們先來看看 <code>Vagrantfile</code> 的內容，我直接把比較重要的設定說明寫在註解裡面了：</p>

<pre><code>  ...
  
  // 此行是說明要使用哪一個 box ，會到自己的系統裡面尋找，如果沒有的話就會下載一個
  // 由於我們剛剛是使用 VagrantCloud 找的版本，因此 vagrant 會去找 
  config.vm.box = &quot;ubuntu/trusty64&quot;

  // 這個是設定網路
  // 預設是 NAT，也就是如果我們在虛擬機器裝了網頁伺服器，
  // 必須使用 port forwarding 的方式來讀到虛擬機器裡面的網頁 
  #config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080

  // Important! 
  // 承上，或者我們可以使用一個 private network ip，我們把它開啟註解吧~
  // 這樣我們開啟虛擬機器時，他的 IP 就會是 192.168.33.10
  config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;

  // 開啟註解的話，就是直接使用 bridge 的方式，如果是使用分享器的話
  // 虛擬機會到分享器要一個 IP 
  # config.vm.network &quot;public_network&quot;
  
  // 這個是設定共享資料夾
  // 預設是放 Vagrantfile 的那個資料夾
  // 在這個資料夾放檔案的話，在虛擬機器裡的 '/vagrant/' 資料夾是可以看到的!!
  // 如果有想要指定到特殊的資料夾，再編輯此行並開啟註解即可
  # config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;

end
</code></pre>

<p>再來就讓它開機吧!</p>

<pre><code>$ vagrant up 
</code></pre>

<p>如果沒有下載過 ubuntu 系統的話，會先幫你下載，所以需要等待一些時間</p>

<p>若看到終端機說系統已經建立完成，</p>

<p>就可以連線進去了!</p>

<pre><code>$ vagrant ssh
.....
vagrant@vagrant-ubuntu-trusty-64:~$ 
</code></pre>

<p>就會發現終端機的 prompt 已經不一樣了，變成 ubuntu-trusty-64 ，表示我們已經進入虛擬機器裡面了</p>

<p>由於今天的內容只會先到這，關於 Ubuntu 的設定是明天，所以記得離開虛擬機器並且幫他關機 XDD</p>

<pre><code>// 如果剛剛有進入虛擬機器的話，輸入 exit 離開
$ exit
</code></pre>

<p>再下關機指令:</p>

<pre><code>$ vagrant halt 
</code></pre>

<p>虛擬機器就被關起來了!</p>

<p>順帶一提</p>

<p>如果在虛擬機器開機時，需要更改 Vagrantfile 的設定，</p>

<p>改完後虛擬機器必須要重新開啟才會讀到新的設定</p>

<pre><code>$ vagrant reload
</code></pre>

<p>下回待續!!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/05/2014-10-05-swift-d5/" class="post-title">[Swift-d5] - Playground - Array, Dictionary, Controll Flow</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>##Array</p>

<p>###宣告</p>

<pre><code class="language-swift">// var VARIABLE_NAME: [TYPE] = .....

var fruits: [String] = [&quot;apple&quot;, &quot;banana&quot;]
var nums: [Int] = [1, 2]

// 或是讓 Swift 自行判斷類型:
var fruits = [&quot;apple&quot;, &quot;banana&quot;]
var nums = [1, 2]

// 初始化:
var cars = [String]()
</code></pre>

<p>ps. Beta 版時的寫法是 <code>var fruits: String[]</code></p>

<p>現在已經變成了 <code>var fruits: [String]</code></p>

<p>###操作</p>

<pre><code>// 判斷該陣列是否有值，回傳 true 或 false
fruits.isEmpty 

// 增加元素
fruits.append(&quot;watermelon&quot;)
fruits += [&quot;lemon&quot;]

// 取值 
fruits[0]
fruits[0...2]

// 刪除值 - 將 apple 移除，banana 會自動補上
fruits.removeAtIndex(0)
fruits[0]

// 兩個陣列合併 (必須相同類別 e.g. String)
fruits + cars

// 陣列元素數量
fruits.count
</code></pre>

<p>##Dictionary</p>

<p>###宣告</p>

<p>由於 Dictionary 是 key/value 為一組 (pair)，</p>

<p>因此宣告時必須宣告 key 和 value 分別是哪種型別</p>

<pre><code>var httpStatus: Dictionary&lt;Int, String&gt; = Dictionary&lt;Int, String&gt;()

var httpStatus: Dictionary&lt;Int, String&gt; = [200: &quot;Success&quot;, 404: &quot;Not found&quot;]
</code></pre>

<p>###操作</p>

<pre><code>// 一樣有 isEmpty 方法
httpStatus.isEmpty

// 取值
httpStatus[200] // = &quot;Success&quot;

// 加入值
httpStatus[500] = &quot;Internal Server Error&quot;

// 修改值
httpStatus[200] = &quot;True&quot;
httpStatus.updateValue(&quot;internal server error&quot;, forKey: 500)

// 刪除值
httpStatus.removeValueForKey(200)

// 字典元素數量
httpStatus.count

</code></pre>

<p>##Controll Flow</p>

<p>###For loop</p>

<pre><code>for fruit in fruits {
	println(fruit)
}

for var index = 0; index &lt; fruits.count; ++index {
	println(fruits[index])
}
</code></pre>

<p>###While</p>

<pre><code>var index = 0
while index &lt; fruits.count {
    println(fruits[index])
    index++
}
</code></pre>

<p>###Do-while</p>

<pre><code>var index = 0
do {
	println(fruits[index])
	index++ 
} while (index &lt; fruits.count)
</code></pre>

<p>###If</p>

<pre><code>var index = 5566

if index = 5566 {
	println(&quot;5566 不能亡&quot;)
}

if index = 5566 {
	println(&quot;5566 不能亡&quot;)
} else {
	println(&quot;You are not 5566&quot;)
}

if index = 5566 {
	println(&quot;5566 不能亡&quot;)
} else if index &lt; 5566 {
	println(&quot;You are less than 5566&quot;)
} else {
	println(&quot;You are bigger than 5566&quot;)
}
</code></pre>

<p>###Switch</p>

<pre><code>var index = 0

switch index {
case 0, 1, 2
	println(&quot;small&quot;)
case 8, 9, 11 
	println(&quot;big&quot;)
default:
	println(&quot;others&quot;)
}
</code></pre>

<p>引入 Tuple</p>

<pre><code>let httpStatus = (200, &quot;Success&quot;)

switch httpStatus {
case (let statusCode, &quot;Error&quot;):
    println(&quot;(\(statusCode)) is Error&quot;)
case (200, let msg):
    println(&quot;(\(msg))'s statusCode is 200&quot;)
}
</code></pre>

<p>##Switch - break, continue, fallthrough</p>

<p>###Continue</p>

<p>continue 會使該次的 loop 停止，並繼續執行下一個 loop</p>

<p>continue 不存在於單一的 switch, 只會在 loop 裡的 switch 語句時才能使用</p>

<pre><code>var fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;lemon&quot;, &quot;waterlemon&quot;, &quot;orange&quot;]
for fruit in fruits {
    println(&quot;Start&quot;)

    switch fruit {
    case &quot;banana&quot;:
        continue
    default:
        println(fruit)
    }
    
    println(&quot;End&quot;)
}
</code></pre>

<p>Start 和 End 理論上都要被印五次，</p>

<p>但是加入了 continue 後，banana case 當次 loop 的 End 就沒有被執行了</p>

<p>###Break</p>

<p>通常是用在不想處理某個 case 或，特別想要處理時 (?) 反之嘛 XD</p>

<p>當使用了 break，會立即中斷 switch 程式碼的執行，並且跳到 switch 區塊程式碼結束的大括號後 (}) 的第一行程式</p>

<p>暫時想不到什麼好例子&hellip;.</p>

<p>先借別人的例子來用吧:</p>

<pre><code>let numberSymbol: Character = &quot;三&quot;  // 簡體中文裡的數字 3
var possibleIntegerValue: Int?
switch numberSymbol {
case &quot;1&quot;, &quot;١&quot;, &quot;一&quot;, &quot;๑&quot;:
    possibleIntegerValue = 1
case &quot;2&quot;, &quot;٢&quot;, &quot;二&quot;, &quot;๒&quot;:
    possibleIntegerValue = 2
case &quot;3&quot;, &quot;٣&quot;, &quot;三&quot;, &quot;๓&quot;:
    possibleIntegerValue = 3
case &quot;4&quot;, &quot;٤&quot;, &quot;四&quot;, &quot;๔&quot;:
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    println(&quot;The integer value of \(numberSymbol) is \(integerValue).&quot;)
} else {
    println(&quot;An integer value could not be found for \(numberSymbol).&quot;)
}
// 輸出 &quot;The integer value of 三 is 3.
</code></pre>

<p>###Fallthrough</p>

<p>在 Swift 中，掃到第一個符合的 case 後，就會中斷 switch 的執行了，避免掉入一些 case 處理的錯誤</p>

<p>而 fallthrough, 很有趣, 宣告後，會讓 switch 繼續掃下一個 case</p>

<pre><code>let num = 5
var description = &quot;\(num) is&quot;
switch num {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += &quot; a prime, also&quot;
    fallthrough
case 5: 
    println(&quot;I'm here&quot;)
default:
    description += &quot; an integer.&quot;
}
println(description)
// I'm here
// 5 is a prime, also an integer.
</code></pre>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/04/2014-10-04-api-d4/" class="post-title">[API-d4] - 使用技術與工具介紹及原因</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>#使用技術與工具介紹及原因</p>

<p>終於要開始進入正題了！</p>

<p>在了解 REST/RESTful 後，</p>

<p>就要從無到有 - 從 Server 到 API endpoint 都由自己打造</p>

<p>今天會先來說明接下來會使用到哪些工具及技術</p>

<p>由於筆者使用 Mac ，因此若是有其他平台的使用者可能需要自行找教學</p>

<p>##Server - Ubuntu with Vagrant + VitrualBox</p>

<p>接下來幾天會先從這個部分開始提起</p>

<p>我們會使用 VirtualBox + Vagrant 的方式來建立自己的虛擬環境</p>

<p>避免一些讀者可能對 Server command line 不熟</p>

<p>這個部分是大家可以跳過的部分，但是我還是會從無到有架起來</p>

<p>##Backend Language - Node.js</p>

<p>後端語言使用了 Node.js，其實本來有考慮使用 Golang，</p>

<p>但顧及自己的時間&hellip; 還是使用 Node.js，方便快速</p>

<p>這幾年是 Javascript 的時代，</p>

<p>優勝美地似乎也可以支援使用 Javascript 撰寫 <a href="https://github.com/tylergaw/js-osx-app-examples">Automation Tool</a></p>

<p>從前端打到後端甚至到 DB 都可以使用到 Javascript ，</p>

<p>是該來看看 Javascript 的語法特性了 :D</p>

<p>而且 Node.js Event-driven 的特性，可以利用少少的資源提供高效能的服務</p>

<p>同時搭配易用性及社群活躍度，這是我選擇 Node.js 而非選擇 Golang 的原因</p>

<p>##Framework - Express</p>

<p>我使用了 Node.js 的 web framework - Express</p>

<p>Node.js 之於 Express 可以把它想像成是 Ruby 之於 Sinatra</p>

<p>我使用 Express 方便處理 Route</p>

<p>並且這套 framework 算是 Node.js 裡最具代表性的 framework</p>

<p>學起來也還不錯</p>

<p>##Database - MongoDB</p>

<p>DB 為了追求簡單快速，我使用了 MongoDB</p>

<p>從 API 到 DB 無縫接軌，簡單的操作模式以及 Schema-free 的特性</p>

<p>應該會讓這整件事情變得更簡單</p>

<p>##Test client - PostMan (chrome extension)</p>

<p>由於 API 是純粹後端 service，我們使用 Express 並不會使用到樣板語言，</p>

<p>也就是我們並不會撰寫 View (HTML, CSS 等等的語法)</p>

<p>因此除了寫測試外，我們就可以使用這套 Chrome Extension 來對 API 做存取!</p>

<hr />

<p>結束! 接下來幾天會教大家建立自己的虛擬機哦~~</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/04/2014-10-04-swift-d4/" class="post-title">[Swift-d4] - Playground - Optional, ! and ? </a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>#Playground - Optional, ! and ?</p>

<p>今天要來探討 Optional 型別，我認為這塊是初學 Swift 常遇到的問題<br />
大家搞不懂 &ldquo;!&rdquo; &ldquo;?&rdquo; 到底在幹什麼，所以今天就來了解一下</p>

<p>在 Swift 中，所有的資料型別都不能賦予 nil<br />
也就是以下這件事是不成立的：</p>

<pre><code class="language-Swift">var x: String = &quot;test&quot;
x = nil
</code></pre>

<p>所以在 Swift 底下，就要使用 Optional 來處理值可能不存在的情況<br />
當一個變數 x 被宣告成 Optional 型別時，該變數就會有兩個情況：</p>

<pre><code>1. 有值，等於 x
2. 沒有值

</code></pre>

<p>要宣告一個變數可能為 nil 時的方式是使用問號 &lsquo;?&lsquo;：</p>

<pre><code>// 此時 x = &quot;yaya&quot;
var x: String? = &quot;yaya&quot;

// 此時 x 沒有值
x = nil
</code></pre>

<p>拿以下程式在 Playground 執行看看：</p>

<pre><code>var str: String = &quot;&quot;
println(str)
str = &quot;yaya&quot;
println(str)

var str2: String?
println(str2)
str2 = &quot;yaya&quot;
println(str2)
</code></pre>

<p>可以看一下 Playground 右邊的輸出框，觀察兩個 string 的差異<br />
當 str2 被賦予 Optional 型別後，<br />
str2  已經不是單純的 String 型別了，</p>

<p>那如何強制以 String 型別拿到 str2 的資料呢?
試著在 str2 後面加上驚嘆號，並觀察右方輸出結果:</p>

<pre><code>println(str2!)
</code></pre>

<p>請注意！若要強制取值，一定要確保此 Optional 型別中一定有值，
否則將會導致執行錯誤，以下是錯誤範例：</p>

<pre><code>var str2: String? = &quot;yaya&quot;
println(str2)
str2 = nil
println(str2!)
</code></pre>

<p>程式將會在第四行返回錯誤，因此使用驚嘆號強制取值前請先確保 Optional 裡有值。</p>

<p>在 Objective-C 中，nil 是指向一個不存在物件的指標；
而 Swift 中，nil 是一種非常明確地值 － 他就是代表「不存在」。</p>

<p>在 Playground 中多試試看囉~~</p>

<p>ps. Swift 的 ? 和 Ruby 的 ? 是完全不同意思的XD</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/03/2014-10-03-api-d3/" class="post-title">[API-d3] - 使用時機與實際 API 參考</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-RESTful" href="http://kerkerj.github.io//categories/restful">RESTful</a><a class="post-category post-category-API" href="http://kerkerj.github.io//categories/api">API</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>#使用時機與實際 API 參考<br />
什麼時候需要打造 RESTful API?<br />
看看別人的 RESTful API (Instagram/Twitter)</p>

<p>什麼時候需要打造 RESTful API?<br />
我認為當有數組資源要被多種不同平台使用時，就需要打造 RESTful API<br />
例如，有 Android/ iOS / Web 要對同一 table 做存取時，<br />
假設有個 MySQL DB，各個平台都使用各自的 mysql-driver 來直接操作 DB<br />
假設有個 A 專案建立了一套書籍管理系統，資料庫裡記錄了大大小小的書籍，<br />
而有個新的 B 專案需要使用到書籍的資料，此時 DB 操作的程式碼只能再寫一遍，<br />
且各個平台重新撰寫，似乎是不大靠譜。</p>

<p>撰寫 RESTful API 的好處之一即是 RESTful 使用 HTTP 協定，<br />
各個平台皆支援，不需要太複雜的程式，只需要使用各個平台的 http-client，<br />
各個平台也不需要了解 DB 操作語法，只需要知道 json, xml 習慣的資料格式，<br />
且開發 API 還能夠對各個資源輕易地上 cache 增進反應速度，<br />
開發 RESTful API 好處多多，哪天想 Open API 也就不需要再多作處理了～</p>

<p>接著讓我們來看看兩個有名網站的 API 吧！</p>

<p>Instagram: <a href="http://instagram.com/developer/api-console/">http://instagram.com/developer/api-console/</a><br />
Twitter: <a href="https://dev.twitter.com/rest/tools/console">https://dev.twitter.com/rest/tools/console</a></p>

<p>很顯然的，我比較喜歡 Instagram 的 API 資源定義與命名方式 :P</p>

<p>下一篇會介紹我接下來會用到的工具箱，暖身結束，要正式開始了!<br />
(不好意思前面嘴炮一點 XD)</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
      <a href="http://kerkerj.github.io/page/5/" class="post-list-pagination-item pure-button post-list-pagination-item-prev">
        <i class="fa fa-angle-double-left"></i>&nbsp;Newer
      </a>
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 6 of 14</span>
    
      <a href="http://kerkerj.github.io/page/7/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://kerkerj.github.io//js/all.min.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>

        </div>
    </div>
</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-45583907-2', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
