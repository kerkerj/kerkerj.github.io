<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
    
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://kerkerj.github.io/">
    <meta property="og:title" content="kerkerj">
    
    <meta property="og:description" content="hugo hugo - 快速又現代的靜態網站產生器 ^^^ 這是 spf13 自己說的 繼 spf13-vim 後又一個 spf13 出品的好東西 XD 在靜態網站產生器中最廣為人知的應該就是 Jekyll 以及基於 Jekyll 的 Octopress 了 (關於靜態網站產生器，這篇文章 介紹了六個除了 Jekyll 以外的產生器) 為什麼要用 hugo？ 雖然 Jekyll / Octopress 很紅資源多主題也不少 但是缺點就是要使用它們就必須裝 ruby、裝 gem 有在寫 ruby 的人感覺應該還好 沒在寫 ruby 的光想像就覺得應該會被搞死&hellip; XD 而且覺得文章一多時在編譯的時候好慢&hellip; 用 hugo 的好處就是因為他是用 go 寫的 執行速度飛快，而且只要下載一個 binary 檔案後就可以操作了喲~ 基本 hugo 安裝與操作 首先先安裝 hugo (我是用 mac 的 homebrew) $ brew install hugo 使用 hugo 產生一個新的網站 $ hugo new site /path/to/the/site e.g.">
    
    
    
    <meta property="og:site_name" content="kerkerj">

    
    <meta name="twitter:card" content="summary">
    <meta name="twitter:site" content="kerkerj" />
    <meta name="twitter:title" content="kerkerj &middot; kerkerj">
    <meta name="twitter:description" content="Hi.">

    
    <title>kerkerj &middot; kerkerj</title>

    
    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    
    
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">
    

    <link rel="stylesheet" href="http://kerkerj.github.io//css/all.min.css">
    <link href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet">

    
    
      <link rel="stylesheet" href="http://kerkerj.github.io//css/highlight/railscasts.css">
    

    
    <link href="http://kerkerj.github.io/favicon.ico" rel="icon">

    
    <link rel="alternate" type="application/rss+xml" title="RSS" href="http://kerkerj.github.io//index.xml">
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="http://kerkerj.github.io/">kerkerj</a></h1>
            <h2 class="brand-tagline"> Hi. </h2>
        </hgroup>

        <nav class="nav">
            
            <ul class="pure-menu-list">
              
              
                <li class="pure-menu-link">
                  <a href="http://kerkerj.github.io//notes/">Notes</a>
                </li>
              
                <li class="pure-menu-link">
                  <a href="http://kerkerj.github.io//about/">About</a>
                </li>
              
                <li class="pure-menu-link">
                  <a href="http://kerkerj.github.io//mac-app-list/">Mac App List</a>
                </li>
              
            </ul>

            
            <ul class="nav-list">
                
                <li class="nav-item">
                    <a class="pure-button" href="http://twitter.com/kerkerj"><i class="fa fa-twitter"></i> Twitter</a>
                </li>
                
                
                <li class="nav-item">
                    <a class="pure-button" href="http://github.com/kerkerj "><i class="fa fa-github-alt"></i> Github</a>
                </li>
                
                
                
                <li class="nav-item">
                    <a class="pure-button" href="http://kerkerj.github.io/index.xml"><i class="fa fa-rss-alt"></i> RSS</a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/27/2014-10-27-swift-d27/" class="post-title">[Swift-d27] - 實戰開發 - TODOList - API 2 讀取清單資料</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27">Github link</a></p>

<p>(某一天把兩天份的 commit 在一起了忘了開 branch 了&hellip;)</p>

<p>接下來就要來寫 api utility 了</p>

<p>我們先開一個 swift 檔案 <code>RestApi.swift</code></p>

<pre><code class="language-swift">import Foundation

class RestApi {
	var API_key = &quot;55665566&quot;
	var getListUrl = NSURL(string: &quot;http://192.168.1.158:3000/user/kerkerj/todos&quot;)
}
</code></pre>

<p>先做好前置設定，因為 API 有上簡單的小鎖，因此要先寫起來</p>

<p>還有 request 的網址</p>

<p>以下是 get list 的範例:</p>

<pre><code>func getTodoList(completionHandler: ((NSArray!, NSError!) -&gt; Void)!) {
        var session = NSURLSession.sharedSession()
        
        var request = NSMutableURLRequest(URL: self.getListUrl!)
        request.HTTPMethod = &quot;GET&quot;
        request.addValue(&quot;application/json&quot;, forHTTPHeaderField: &quot;Content-Type&quot;)
        request.addValue(self.API_key, forHTTPHeaderField: &quot;API-Key&quot;)
        
        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }
            
            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSArray
            
            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })
        
        task.resume()
    }
</code></pre>

<p>我們使用內建的 NSURLSession.sharedSession 以及 NSMutableURLRequest 來建立 request</p>

<p>裡面就是設定一些 header 以及 API-Key</p>

<p>另外在資料回來後，return callback</p>

<p>在這邊有 async，寫隔壁棚的 api 回過頭來看這個感覺很熟悉 XD</p>

<p>設定好 API 後</p>

<p>回到顯示 todo 清單的主頁程式碼</p>

<p>由於我們希望能夠在 view 每次被呼叫時，都可以對 API server 做存取</p>

<p>因此必須要將 getTodoList 寫在該方法裏</p>

<p>該方法為 override func viewWillAppear(animated: Bool) {}</p>

<p>先建立一個 api 物件</p>

<pre><code>var api: RestApi = RestApi()
</code></pre>

<p>將原本的假資料刪除或註解, 不過資料物件名稱就繼續用 fakeData XD</p>

<pre><code>//        fakeData = [
//            [&quot;id&quot;: &quot;1&quot;, &quot;content&quot;: &quot;A&quot;],
//            [&quot;id&quot;: &quot;2&quot;, &quot;content&quot;: &quot;B&quot;],
//            [&quot;id&quot;: &quot;3&quot;, &quot;content&quot;: &quot;C&quot;],
//        ]
</code></pre>

<p>接著在 ViewController override 一個 viewWillAppear 的方法</p>

<pre><code>override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(true)
        
        api.getTodoList({data, error -&gt; Void in
            if error != nil {
                dispatch_async(dispatch_get_main_queue(), {
                    let alert = UIAlertView()
                    alert.title = &quot;Yoooooooooooooooo&quot;
                    alert.message = &quot;Get list faild, maybe check your network: \(error)&quot;
                    alert.addButtonWithTitle(&quot;ok&quot;)
                    alert.delegate = self
                    alert.show()
                    println(error)
                })
            }
            
            if (data != nil) {
                
                var tmpArr = [[String: String]]()
                
                for item in data {
                    var _id = item[&quot;_id&quot;] as String
                    var content = item[&quot;content&quot;] as String
                    var dic = [String: String]()
                    
                    dic[&quot;_id&quot;] = _id
                    dic[&quot;content&quot;] = content
                    
                    tmpArr.append(dic)
                }

                self.arr = tmpArr
                
                println(self.arr)
                
                dispatch_async(dispatch_get_main_queue(), {
                    // must be &quot;tableView!&quot; not &quot;tableView?&quot;
                    self.tableView!.reloadData()
                })
                
            }
        })
        
        dispatch_async(dispatch_get_main_queue(), {
            // must be &quot;tableView!&quot; not &quot;tableView?&quot;
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>以上方法都是 async 的方式</p>

<p>只要網路錯誤，就會直接跳一個 alert</p>

<p>若有資料的話就 parse</p>

<p>一併轉換成原本定義的 [[String: String]] 中</p>

<p>執行看看吧!</p>

<p>很明顯每次切回主頁時 api console 都會跳一行 request~</p>

<p>如果使用 sync 的方式就會卡很久! 而且更新 UI 還會 crash XD</p>

<p>我覺得這部分是需要好好去做處理的，在這邊的程式碼只是簡單 demo</p>

<p>並沒有考慮到太多 :P</p>

<p>明天繼續!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/27/2014-10-27-api-d27/" class="post-title">[API-d27] - 實戰開發 - log 處理 及 config (db, apikey)</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a><a class="post-category post-category-nodejs" href="http://kerkerj.github.io//categories/nodejs">nodejs</a><a class="post-category post-category-express" href="http://kerkerj.github.io//categories/express">express</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day27">Github 參考</a></p>

<p>##log 處理</p>

<p>今天要來談談 log 的處理，</p>

<p>身為一台自走 (?) node.js API server</p>

<p>也應該要記錄一下 request 的 log 呀！</p>

<p>不然哪天出問題了都不知道是哪個 request 把 server 搞掛了!</p>

<p>因此我們就要加入 log 的 middleware</p>

<p>node.js 的 log 套件也蠻多的, 例如 <code>winston</code></p>

<p>不過我們今天要用的是 <code>log4js</code></p>

<p>會選擇他其實也只是因為之前寫 <code>java</code> 有用過 <code>log4j</code></p>

<p><code>log4js</code> 的設定感覺起來比較相似</p>

<p>所以就使用它了!</p>

<p>再來我們就安裝一下 <code>log4js</code> 吧</p>

<pre><code class="language-javascript">$ npm install log4js -save  
</code></pre>

<p>並在 <code>app.js</code> 中 require 進去</p>

<pre><code>var log4js = require('log4js');
</code></pre>

<p>接著在 <code>app.js</code> 的前面區段加入以下程式碼:</p>

<pre><code>log4js.configure({
    appenders: [
        { type: 'console' }, //控制台輸出
        {
            type: 'file', //文件輸出
            filename: 'logs/access.log',
            maxLogSize: 20000000, // 20 MB
            backups: 10,
            category: 'normal'
        }
    ],
    replaceConsole: true
});

var logger = log4js.getLogger('normal');
logger.setLevel('INFO');

app.use(log4js.connectLogger(logger, {level: 'auto', format:':method :url'}));
</code></pre>

<p>其實註解已經可以看出一些端倪了</p>

<p>使用 <code>log4js</code> 可以輸出 log 檔案，並且會按照設定的檔案大小來寫入</p>

<p>如果達到 20MB 就會換一個新的檔案寫入，原本的還保留著，不過最多只會保留 10 份</p>

<p>接著就設定 log level, 以及想要 log 的資訊</p>

<p>詳細資訊就可以再多查詢一下</p>

<p>此時我們將 server run 起來吧!</p>

<p>並且對 server 戳幾個 request, 就會發現 log 檔案被建立起來了!</p>

<p>(該程式碼加在 token 檢查前或檢查後是有差異的，加在 token 檢查後面，token error 的話則不會被記錄到 log 裡面)</p>

<p>打開 log 檔看看，就會發現有 log 被寫入囉!</p>

<p>##config (db, apikey)</p>

<p>有些重要的設定檔其實我們並不希望寫在程式碼裡，這時候 config 的設定很有用</p>

<p>建立設定檔有很多種方式，比方說直接寫一個 json 檔案，或是 xml 檔案</p>

<p>今天我們就用最簡單的 js 檔案的方式來建立 config 檔</p>

<p>我們在 config 資料夾裡新增一個 config.js</p>

<p>我們以下面的程式碼當作例子:</p>

<pre><code>module.exports = {
    &quot;base_url&quot;: &quot;http://localhost:3000&quot;,
    &quot;test_token&quot;: &quot;55665566&quot;,
    &quot;db&quot;: {
        &quot;production&quot;: &quot;mongodb://192.168.33.10:27017/TODOs&quot;,
        &quot;development&quot;: &quot;mongodb://192.168.33.10:27017/DEV_TODOs&quot;,
        &quot;test&quot;: &quot;mongodb://192.168.33.10:27017/TEST_TODOs&quot;
    }
};
</code></pre>

<p>要怎麼使用裡面的內容呢?</p>

<p>假設我們要將 db 的連結改成用 config 的方式連結的話:</p>

<pre><code>var config = require('./config/config');

// Set DB
mongoose.connect(config.db.development);
</code></pre>

<p>只要先將 config require 進來，然後就直接使用它就好了!</p>

<p>這樣就可以幫助我們將一些重要的設定從程式碼中抽離出來了!</p>

<p>今天就這樣啦!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/26/2014-10-26-api-d26/" class="post-title">[API-d26] - 實戰開發 - API-key</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a><a class="post-category post-category-nodejs" href="http://kerkerj.github.io//categories/nodejs">nodejs</a><a class="post-category post-category-express" href="http://kerkerj.github.io//categories/express">express</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day26">Github 參考</a></p>

<p>假設今天我們的 API 上線了，可能就會面臨到一些問題，</p>

<p>例如說，任何人都可以存取我們的 API</p>

<p>當然我們不希望任何人都可以存取，</p>

<p>因此我們必須加一點驗證機制在裡面，</p>

<p>其中一種做法是使用 Oauth token</p>

<p>在拿 API 資料前，先向 Oauth server 要一個 token</p>

<p>Oauth Server 認可身份後即會核發一個 token 給 client 端</p>

<p>該 token 具有時效性，6 mins ~ 30 min 不等，看怎麼實作</p>

<p>接著 client 端就拿該組 token 以及 API url 對 resources server 丟 request</p>

<p>其實我們現在在做的 API server 就是一個 resources server</p>

<p>因為我們提供資源</p>

<p>而 resources server 就會先認 token，</p>

<p>確保該 token 的時效性以及正確性，以及該 token 可存取的資源範圍</p>

<p>確認無誤後再回送正確的資料</p>

<p>不過在這邊我們並沒有要實作 Oauth Server</p>

<p>單純以一個 resources server 而言，只要認 token 是否正確</p>

<p>因此我們在這邊用 API-Key 實作即可，簡單的服務只要不被猜到就好</p>

<p>程式碼如下，記得加在 router 前面</p>

<p>app.js:</p>

<pre><code class="language-javascript">// Set Header Check
app.use( function(req, res, next) {
    var api_key = req.get('API-Key');

    if (api_key != &quot;55665566&quot;) {
        res.status(401).send({ error: &quot;Unauthorized&quot;});
    }
    else {
        next();
    }
});
</code></pre>

<p>一樣是 middleware 的概念</p>

<p>不過是會預先作處理</p>

<p>我們接收到 request 後，分析它的 header 中是否有 <code>API-Key</code> 這個欄位</p>

<p>若有的話，確認他的值是否為 <code>55665566</code></p>

<p>若不是的話，回傳 401 Unauthorized</p>

<p>若正確則繼續走下一個 middleware</p>

<p>這樣就可以做一道簡單的防線了</p>

<p>若加了這道防線</p>

<p>在使用 POSTMAN 做 request 時，必須加入自定 header</p>

<p>沒加入的話:</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%204.11.59.png" alt="image" />
</p>

<p>有加入的話:</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%204.12.18.png" alt="image" />
</p>

<p>是不是很簡單呢!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/26/2014-10-26-swift-d26/" class="post-title">[Swift-d26] - 實戰開發 - TODOList - API 前置資料準備</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p>接下來是要串 <a href="http://ithelp.ithome.com.tw/ironman7/app/profile/20091343/dev">隔壁棚的 API</a> XD</p>

<p>從前幾天的 APP 組成</p>

<p>我們所需要的資料大概會是以下幾種:</p>

<ul>
<li>GET todo list</li>
</ul>

<pre><code class="language-swift">GET http://192.168.1.158:3000/user/kerkerj/todos

return:
[
    {
        &quot;_id&quot;: &quot;54441f64d84f1ea412db855c&quot;,
        &quot;updated_at&quot;: &quot;2014-10-19T20:30:28.797Z&quot;,
        &quot;created_at&quot;: &quot;2014-10-19T20:30:28.797Z&quot;,
        &quot;content&quot;: &quot;task11syy&quot;,
        &quot;user_id&quot;: &quot;kerkerj&quot;,
        &quot;__v&quot;: 0
    },
    {
        &quot;_id&quot;: &quot;54441f6fd84f1ea412db855e&quot;,
        &quot;updated_at&quot;: &quot;2014-10-19T20:30:39.957Z&quot;,
        &quot;created_at&quot;: &quot;2014-10-19T20:30:39.957Z&quot;,
        &quot;content&quot;: &quot;task13&quot;,
        &quot;user_id&quot;: &quot;kerkerj&quot;,
        &quot;__v&quot;: 0
    }
]
</code></pre>

<ul>
<li>Get a todo task</li>
</ul>

<pre><code>GET http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return:
{
        &quot;_id&quot;: &quot;54441f64d84f1ea412db855c&quot;,
        &quot;updated_at&quot;: &quot;2014-10-19T20:30:28.797Z&quot;,
        &quot;created_at&quot;: &quot;2014-10-19T20:30:28.797Z&quot;,
        &quot;content&quot;: &quot;task11syy&quot;,
        &quot;user_id&quot;: &quot;kerkerj&quot;,
        &quot;__v&quot;: 0
}
</code></pre>

<ul>
<li>Add a todo task</li>
</ul>

<pre><code>POST http://192.168.1.158:3000/user/kerkerj/todos/
data: {&quot;content&quot;: &quot;your data&quot;}

return: the data you sent
</code></pre>

<ul>
<li>Update a todo task</li>
</ul>

<pre><code>PUT http://192.168.1.158:3000/user/kerkerj/todos/
data: {&quot;content&quot;: &quot;your data&quot;}

return: the data you sent
</code></pre>

<ul>
<li>Delete a todo task</li>
</ul>

<pre><code>DELETE http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return 
{&quot;success&quot;: &quot;true&quot;}
</code></pre>

<p>從以上資料可以知道</p>

<p>最重要的欄位就是 _id, user_id, content</p>

<p>user_id 我們在 app 中就直接寫死了</p>

<p>所以最重要的就是 content 及 _id</p>

<p>今天先允許我偷懶一下，明天就要開始寫 api utility 給 swift 用</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/25/2014-10-25-api-day25/" class="post-title">[API-day25] - 實戰開發 - 處理 404 &amp; 500</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a><a class="post-category post-category-nodejs" href="http://kerkerj.github.io//categories/nodejs">nodejs</a><a class="post-category post-category-express" href="http://kerkerj.github.io//categories/express">express</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day25">Github 參考</a></p>

<p>不知道大家在用 POSTMAN 對前幾天寫的 API 丟 request 有沒有遇過類似下面的情況:</p>

<pre><code class="language-javascript">Cannot GET /user/kerkerj/todoss
</code></pre>

<p>通常是丟錯網址時會出現的，或是 code 沒寫好會出現 500 error</p>

<p>這些情況是有辦法接到的，今天我們希望能夠接到後，將 message 轉成 json 格式吐回給 client</p>

<p>因此程式碼如下</p>

<p>app.js</p>

<pre><code class="language-javascript">// catch 404 and forward to error handler
app.use(function(req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    res.status(404).jsonp({error: &quot;Not Found&quot;});
    next();
});

// catch 500
app.use(function(err, req, res, next) {
            res.status(err.status || 500).json({error: err.message});
});
</code></pre>

<p>基本上這兩段 code 的意思就是加入了兩個 middleware</p>

<p>如果進來的 request 是屬於 404 or 500 就會回傳 json 格式</p>

<p>並且依錯誤碼不同而回傳不同的訊息</p>

<p>試著將 server 跑起來</p>

<p>亂丟 request 看看</p>

<p>原本應該會是</p>

<pre><code>Cannot GET /user/kerkerj/todoss
</code></pre>

<p>就會變成了 json</p>

<pre><code>{
    &quot;error&quot;: &quot;Not Found&quot;
}
</code></pre>

<p>這樣一來, client 程式也就能夠統一接收 json 回傳，而不會因為莫名的字串導致解析錯誤而 crash 了!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/25/2014-10-25-swift-day25/" class="post-title">[Swift-day25] - 實戰開發 - TODOList - Update View</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27">Github link</a></p>

<p>(忘了是放在哪個 branch 了 Orz)</p>

<p>接下來就要進到最後一個 Update View 了!</p>

<p>什麼時候會進到 Update View 呢？</p>

<p>是在顯示單筆 TODO 的時候的右上方按鈕:</p>

<p><img src="http://goo.gl/tNOyRs" alt="image" />
</p>

<p>我們今天只會實作 view 的部分, fakeData 就不實作了</p>

<p>因為接下來就要直接接 API 啦</p>

<p>也不需要更新 fakeData 了 :P</p>

<p>要加入 Edit 這個按鈕</p>

<p>要到 ShowViewController, 加入 UIBarButtonItem</p>

<p>並且讓其吃到一個方法，可以讓 Navigation 往下一個 View 前進:</p>

<pre><code class="language-swift">var id: String!

override func viewDidLoad() {
        super.viewDidLoad()
        
        indexLabel.text = &quot;\(index)&quot;
        contentLabel.text = content
        
        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: &quot;Edit&quot;, style: UIBarButtonItemStyle.Bordered, target: self, action: Selector(&quot;editTodo&quot;))
    }
</code></pre>

<p>p.s. 先前忘記加了 id, 現在補回來 XD</p>

<p>先新增一個 Edit 按鈕後</p>

<p>並實作 editTodo</p>

<pre><code>func editTodo() {
        var editViewContronller = UpdateViewController(nibName: &quot;UpdateViewController&quot;, bundle: nil)
        editViewContronller.from = &quot;edit&quot;
        editViewContronller.content = content
        editViewContronller.index = index
        
        self.navigationController?.pushViewController(editViewContronller, animated: true)
    }
</code></pre>

<p>由於要先指定資料</p>

<p>因此再到 UpdateViewController 中再加入兩個參數</p>

<pre><code>    var index: Int!
    var content: String!
</code></pre>

<p>最後在 UpdateController 的 viewDidLoad 中, 加入 add or edit 的判斷</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()
        
        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: &quot;Save&quot;, style: UIBarButtonItemStyle.Done, target: self, action: Selector(&quot;save&quot;))
			
		  if self.from == &quot;edit&quot; {
            self.textField.text = content
        }
        
    }
</code></pre>

<p>這時候先前設定的 &ldquo;from&rdquo; 參數就很有用了~</p>

<p>就可以根據是從 add 的 view 來的或者是 edit 的 view 來的</p>

<p>以便判定要不要 append 舊資料上去</p>

<p>此外，也因為如此</p>

<p>所以 UpdateViewController 的 save 方法也要判斷</p>

<pre><code>        if from == &quot;add&quot; {
            delegate.addData(&quot;g6&quot;, content: self.textField.text)
            self.navigationController?.popToRootViewControllerAnimated(true)
        } else if from == &quot;edit&quot; {
            println(&quot;Save edited data&quot;)
        }
</code></pre>

<p>不過因為今天我們不做資料更新</p>

<p>因此流程面大致上到此告一個段落</p>

<p>接下來就要串 API 了!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/24/2014-10-24-api-d24/" class="post-title">[API-d24] - 實戰開發 - 刪除 TODO task API with mongoose</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a><a class="post-category post-category-nodejs" href="http://kerkerj.github.io//categories/nodejs">nodejs</a><a class="post-category post-category-express" href="http://kerkerj.github.io//categories/express">express</a><a class="post-category post-category-mongoose" href="http://kerkerj.github.io//categories/mongoose">mongoose</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day24">Github 參考</a></p>

<p>還記得昨天說要偷懶一下嗎 XD</p>

<p>因為刪除真的很簡單!</p>

<p>我們前面走過了新增、修改、讀取了</p>

<p>刪除？哪有什麼困難的呢! XD</p>

<p>直接看 code 吧!</p>

<p>routes/users.js:</p>

<pre><code class="language-javascript">// Delete a todo task
router.delete('/:user_id/todos/:todo_id', function(req, res) {
    var user_id = req.params.user_id;
    var todo_id = req.params.todo_id;

    TODO.remove(
        { _id: todo_id, user_id: user_id },
        function (err) {
            if (err) {
                res.status(400).json(
                    { error: &quot;delete data error&quot;}
                );
            } else {
                res.status(201).json(
                    { success: &quot;true&quot; }
                );
            }
        }
    );
});
</code></pre>

<p>非常的簡單!</p>

<p>先抓到 user_id, todo_id 後</p>

<p>使用 .remove 的方法，下 WHERE 條件，並在 callback 作處理</p>

<p>就完成了!</p>

<p>試試看吧!</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%203.39.09.png" alt="image" />
</p>

<p>是不是非常的簡單呢！</p>

<p>我們已經完成 CRUD API 操作了！</p>

<p>接下來幾天會稍作一些細節上的處理!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/24/2014-10-24-swift-d24/" class="post-title">[Swift-d24] - 實戰開發 - TODOList - Create View</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day24">Github link</a></p>

<p>今天要來建立 &ldquo;新增資料&rdquo; 的頁面</p>

<p>不過這個頁面我們也會拿來給 &ldquo;更新資料&rdquo; 的頁面使用</p>

<p>原因其實很簡單</p>

<p>兩邊要建立或編輯的資料是一樣的</p>

<p>差別只在於，當今天是編輯資料的 view call 該頁面時，</p>

<p>該頁面除了顯示編輯框外，編輯框內的文字也會預先 load 好舊的資料了</p>

<p>除此之外兩個 view 的排版一模一樣</p>

<p>所以在這邊我們就只建立一個 UpdateViewController 就可以了</p>

<p>那我們一樣建立一組 UpdateViewController.swift + UpdateViewController.xib</p>

<p>也一樣為元件建立關聯</p>

<p><img src="http://goo.gl/4AO4G0" alt="image" />
</p>

<p>回到主頁</p>

<p>我們幫 Add 新增一個按鈕吧</p>

<p>在 viewDidLoad 中</p>

<pre><code class="language-swift">self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: &quot;Add&quot;, style: UIBarButtonItemStyle.Done, target: self, action: Selector(&quot;pushToAddTODO&quot;))
</code></pre>

<p>設定 Navigation 的右邊鍵的功能</p>

<p>並且根據 pushToAddTODO 的方法做事情</p>

<p>因此繼續下去將 pushToAddTODO 方法做一下</p>

<pre><code>	func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: &quot;UpdateViewController&quot;, bundle: nil)
        addViewController.from = &quot;add&quot;
        
        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>這樣寫完後就可以執行看看了!</p>

<p>剩下的任務就是將資料寫進 fakeData 不過考慮到之後我們是使用 API</p>

<p>因此就先不特別作 ShowViewController 的資料傳遞</p>

<p>再來就做 create view 裡面的 save 按鈕!</p>

<p>接著就要到 UpdateViewController</p>

<p>幫 NavigationController 再多加一個右邊按鈕 &ldquo;Save&rdquo;</p>

<pre><code>import UIKit

class UpdateViewController: UIViewController {

    var from: String!
    @IBOutlet var textField: UITextField!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: &quot;Save&quot;, style: UIBarButtonItemStyle.Done, target: self, action: Selector(&quot;save&quot;))
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }
    
    func save() {
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
}
</code></pre>

<p>整個程式碼都不難, 只有簡單處理 push/pop 的問題而已!</p>

<p>如果我們要加上對 ViewController 的 fakeData 做存取的話，請看以下：</p>

<p>由於需要資料傳遞，因此就必須寫 protocol</p>

<p>protocol 可簡單可複雜，今天會寫非常簡單版!</p>

<p>首先先新建一個 swift 檔案, 名為 TodoProtocol.swift</p>

<p>內容如下:</p>

<pre><code>protocol UpdateTODOlistDelegate {
    func addData(id: String, content: String)
}
</code></pre>

<p>接著到 UpdateViewController 中新建一個變數 屬於 UpdateTODOlistDelegate protocol:</p>

<pre><code>var delegate: UpdateTODOlistDelegate!
</code></pre>

<p>並且設定 save 後的行為，會呼叫 protocol 中的</p>

<p><code>addData(id: String, content: String)</code></p>

<p>將欲新增的 id, content 都丟給該方法</p>

<pre><code>func save() {
		//	&quot;id&quot; 在這邊是直接給死的
        delegate.addData(&quot;67&quot;, content: self.textField.text!)
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
</code></pre>

<p>接著只要在主頁的程式碼中時做 protocol, 設定接到參數後的動作</p>

<p>就可以在接到參數後，將資料寫入 fakeData 了!</p>

<p>回到主頁的程式碼，class 必須先繼承 protocol，再實作</p>

<p>設定繼承後, 實作 addData, 將接到的資料寫入 fakeData:</p>

<pre><code>func addData(id: String, content: String) {
        self.fakeData.append([&quot;id&quot;: id, &quot;content&quot;: content])
        
        dispatch_async(dispatch_get_main_queue(), {
            // must be &quot;tableView!&quot; not &quot;tableView?&quot;
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>記得將 addViewController 的 delegate 設定成 self</p>

<pre><code>func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: &quot;UpdateViewController&quot;, bundle: nil)
        addViewController.from = &quot;add&quot;
        addViewController.delegate = self
        
        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>執行起來就可以增加資料到 fakeData 了!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/23/2014-10-23-swift-d23/" class="post-title">[Swift-d23] - 實戰開發 - TODOList - Show View 2, Delete View</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-swift" href="http://kerkerj.github.io//categories/swift">swift</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day23">Github link</a></p>

<p>延續昨天，接下來要做換頁</p>

<p>因此我們必須先新建立一個 ShowViewController, 以及他的 xib</p>

<p>接著我們在 xib 拉幾個元件: 兩個 label, 一個用來顯示目前的 index, 另一個則是顯示內容</p>

<p>拉好後，將這兩個元件設定連結到 ShowViewController.swift</p>

<p><img src="http://goo.gl/XPjBik" alt="image" />
</p>

<p>另外多在 ShowViewController 中放兩個變數</p>

<pre><code>var index: Int!
var content: String!
</code></pre>

<p>回到 ViewController, 到 tableView didSelectRowAtIndexPath 中</p>

<p>因為 didSelectRowAtIndexPath 的意思就是當 cell 被選取時要做什麼事情</p>

<p>因此當 cell 被選取時，我們就要讓他跳到下一頁，並且是使用 ShowViewController 來顯示資料</p>

<p>因此修改此方法:</p>

<pre><code>	func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        var showViewController = ShowViewController(nibName: &quot;ShowViewController&quot;, bundle: nil)
        showViewController.index = indexPath.row
        showViewController.content = fakeData[indexPath.row][&quot;content&quot;]
        
        // 回復非選取狀態
        tableView.deselectRowAtIndexPath(indexPath, animated: true)
        self.navigationController?.pushViewController(showViewController, animated: true)
    }
</code></pre>

<p>最後在 ShowViewController 中的 viewDidLoad 加入:</p>

<pre><code>        indexLabel.text = &quot;\(index)&quot;
        contentLabel.text = content
</code></pre>

<p>這樣一來在 ShowViewController 被建立時，顯示的 label 就會將上一個 view 設定的 index, content 的值顯示出來了</p>

<p>執行看看!</p>

<p><img src="http://goo.gl/Uib0IA" alt="image" />
</p>

<p>這樣 Show 的部分就完成了!</p>

<p>接著我們回到主頁</p>

<p>要來建立將 cell 向左滑可以刪除的事件，這是 iOS 內建的事件，</p>

<p>因此建立方法也很簡單:</p>

<p>一樣是覆寫 tableView 的方法</p>

<p>要讓 tableView 可以編輯 row - canEditRowAtIndexPath</p>

<pre><code>	func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
        return true
    }
</code></pre>

<p>按下確認刪除後的行為 - 我們在這邊實際上是刪除 fakeData 的值</p>

<p>所以只要 App 重開後就又會回到三筆資料了</p>

<pre><code>	func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {

        self.fakeData.removeAtIndex(indexPath.row)
        
        dispatch_async(dispatch_get_main_queue(), {
            // must be &quot;tableView!&quot; not &quot;tableView?&quot;
            self.tableView!.reloadData()
        })

        let alert = UIAlertView()
        alert.title = &quot;Alert&quot;
        alert.message = &quot;Deleted!&quot;
        alert.addButtonWithTitle(&quot;Ok&quot;)
        alert.show()
    }
</code></pre>

<p>這樣我們就有顯示單筆以及顯示多筆還有刪除可以用了!</p>

                    </div>
                </section>
                
                <h1 class="content-subhead">2014-10-10 00:00</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="http://kerkerj.github.io/blog/2014/10/23/2014-10-23-api-d23/" class="post-title">[API-d23] - 實戰開發 - 修改 TODO task API with mongoose</a>

                        <p class="post-meta">
                            
                            
                                under
                                
                                <a class="post-category post-category-restful" href="http://kerkerj.github.io//categories/restful">restful</a><a class="post-category post-category-api" href="http://kerkerj.github.io//categories/api">api</a><a class="post-category post-category-nodejs" href="http://kerkerj.github.io//categories/nodejs">nodejs</a><a class="post-category post-category-express" href="http://kerkerj.github.io//categories/express">express</a>
                            
                        </p>
                    </header>

                    <div class="post-description">
                        <p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day23">Github 參考</a></p>

<p>接上篇，我們已經可以拿到 todo list 了</p>

<p>也可以拿到特定的 todo task</p>

<p>再來我們就可以編輯特定的 todo task 了對吧?</p>

<p>不囉唆直接進入程式碼</p>

<p>routes/users.js</p>

<pre><code class="language-javascript">// Update a todo task
router.put('/:user_id/todos/:todo_id', function(req, res) {
    var user_id = req.params.user_id;
    var todo_id = req.params.todo_id;
    var data = req.body;

    TODO.update(
        { _id: todo_id, user_id: user_id },
        { $set: { content: data.content } },
        function (err, num, raw, results) {
            if (err) {
                res.status(400).json(
                    { error: &quot;update data error&quot; }
                );
            } else {
                TODO.find({ _id: todo_id, user_id: user_id }, function (err, results) {
                    res.status(201).json(
                        results[0]
                    );
                });
            }
        }
    );
});
</code></pre>

<p>這次拿資料要拿三組: user_id, todo_id, 以及 data from req.body</p>

<pre><code>var user_id = req.params.user_id;
var todo_id = req.params.todo_id;
var data = req.body;
</code></pre>

<p>body 的資料很簡單，就是欲修改的 content 的資料:</p>

<pre><code>{ &quot;content&quot;: &quot;想修改的資料&quot; }
</code></pre>

<p>再來，除了是使用 .update 方法以及同樣要下 WHERE 參數外， .update 方法還多了一個參數:</p>

<pre><code>{ _id: todo_id, user_id: user_id },
{ $set: { content: data.content } },
</code></pre>

<p>$set 的意思等同於 SQL 語法中的 SET</p>

<p>如果沒有加 $set 變成下面這樣:</p>

<pre><code>{ _id: todo_id, user_id: user_id },
{ content: data.content } ,
</code></pre>

<p>整個資料就會被洗掉，變成只有 <code>{ content: data.content }</code></p>

<p>因此有沒有加 $set 差很多哦</p>

<p>後面一樣是 callback 的處理</p>

<p>都寫好後，實際開 POSTMAN 試試看吧!</p>

<p>記得要使用 <code>PUT</code> 來丟 request</p>

<p>例子如下，我把原本的 buy milk 改成 buy milk and banana</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%203.31.57.png" alt="image" />
</p>

<p>這樣離完成 API 就不遠啦!</p>

<p>明天就稍微休息一下吧 XD</p>

                    </div>
                </section>
                
            </div>
            
<div class="pagination">
  <nav role="pagination" class="post-list-pagination">
      
      <a href="http://kerkerj.github.io/" class="post-list-pagination-item pure-button post-list-pagination-item-prev">
        <i class="fa fa-angle-double-left"></i>&nbsp;Newer
      </a>
      
    <span class="post-list-pagination-item post-list-pagination-item-current">Page 2 of 14</span>
    
      <a href="http://kerkerj.github.io/page/3/" class="post-list-pagination-item pure-button post-list-pagination-item-next">
        Older&nbsp;<i class="fa fa-angle-double-right"></i>
      </a>
    
  </nav>
</div>


            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="http://hugo.spf13.com/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src="http://kerkerj.github.io//js/all.min.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>

        </div>
    </div>
</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-45583907-2', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
