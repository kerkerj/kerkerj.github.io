<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kerkerj</title>
    <link>http://blog.kerkerj.in/categories/javascript/index.xml</link>
    <description>Recent content on kerkerj</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.</copyright>
    <atom:link href="http://blog.kerkerj.in/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[API-d15] - [Javascript 番外篇] Javascript callback, event</title>
      <link>http://blog.kerkerj.in/blog/api-d15---javascript-%E7%95%AA%E5%A4%96%E7%AF%87-javascript-callback-event/</link>
      <pubDate>Wed, 15 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/api-d15---javascript-%E7%95%AA%E5%A4%96%E7%AF%87-javascript-callback-event/</guid>
      <description>&lt;p&gt;這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正&lt;/p&gt;

&lt;p&gt;javascript 有個特性：event&lt;/p&gt;

&lt;p&gt;意思就是說，javascript 中，所有的事情都是由事件驅動的&lt;/p&gt;

&lt;p&gt;如果說有寫過 web 前端的話，&lt;/p&gt;

&lt;p&gt;其實呼叫 button.click function 時&lt;/p&gt;

&lt;p&gt;並不會馬上執行 click 裡面的動作&lt;/p&gt;

&lt;p&gt;而是加了一個 click 的 listener&lt;/p&gt;

&lt;p&gt;等到 button 被 click 後，才會執行 click 裡面的程式碼&lt;/p&gt;

&lt;p&gt;所以寫習慣一般 procedure 的程式會有點不太習慣&lt;/p&gt;

&lt;p&gt;舉個 procedure 的例子，下面有五件事想要做：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一般的程式會是照順序執行&lt;/p&gt;

&lt;p&gt;也就是 煮飯完 -&amp;gt; 接電話 -&amp;gt; 吃麵 -&amp;gt; 丟垃圾&lt;/p&gt;

&lt;p&gt;總執行時間 = 23 分鐘&lt;/p&gt;

&lt;p&gt;但是如果把這段 code 丟給 javascript 執行的話&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就變成同時做煮飯，接電話，吃麵，丟垃圾了！&lt;/p&gt;

&lt;p&gt;為了要預防這件事，有些事情還是有順序性的，&lt;/p&gt;

&lt;p&gt;因此就要使用到 javascript callback 的特性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;煮飯(function() {
	吃飯(function() {
		接電話(function() {
			丟垃圾();
		});
	});
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;意思就是煮飯完吃飯，吃完飯接電話，接完電話丟垃圾&lt;/p&gt;

&lt;p&gt;以下有一個範例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function wash() {
    setTimeout(function() {
        console.log(&amp;quot;wash&amp;quot;);
    }, 1000);
}

function eat() {
    setTimeout(function() {
        console.log(&amp;quot;eat&amp;quot;);
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log(&amp;quot;running&amp;quot;);
    }, 3000);
}

function doHouseWork() {
    wash();
    eat();
    running();
}

doHouseWork();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;做家事執行了三件事，wash, eat, 和 running&lt;/p&gt;

&lt;p&gt;其中每件事都設定不同的完成時間&lt;/p&gt;

&lt;p&gt;以 procedure 的程式執行方式來看，在這邊用 ruby 舉例:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;def wash
  sleep 1
  puts &amp;quot;wash&amp;quot;
end 

def eat
  sleep 5
  puts &amp;quot;eat&amp;quot;
end 

def running 
  sleep 3
  puts &amp;quot;running&amp;quot;
end 

def doHouseWork 
  wash
  eat
  running
end 

doHouseWork
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;是會 wash 1 秒後，接著 eat 5 秒，再 running 3 秒&lt;/p&gt;

&lt;p&gt;所以總共是 9 秒&lt;/p&gt;

&lt;p&gt;output 的順序會是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wash // 1 秒
eat // 5 秒
running // 3 秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在 javascript 中，output 的順序卻是:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wash // 1 秒
running // 3 秒
eat // 5 秒
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以總長度是 5 秒&lt;/p&gt;

&lt;p&gt;那今天假設想要讓 javascript 有順序性時該怎麼辦?&lt;/p&gt;

&lt;p&gt;拿上面的例子作修改的話:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function wash(callback) {
    setTimeout(function() {
        console.log(&amp;quot;wash&amp;quot;);
        callback.call();
    }, 1000);
}

function eat(callback) {
    setTimeout(function() {
        console.log(&amp;quot;eat&amp;quot;);
        callback.call();
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log(&amp;quot;running&amp;quot;);
    }, 3000);
}

function doHouseWork(callback) {
    console.log(&amp;quot;doing house work&amp;quot;);
    callback.call();
}

doHouseWork(function(){
    wash(function() {
        eat(function() {
            running();
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很不錯的特性，但是也要特別對於這種特性作處理&lt;/p&gt;

&lt;p&gt;有個 lib 很好用，&lt;code&gt;async.js&lt;/code&gt; &lt;a href=&#34;https://github.com/caolan/async&#34;&gt;來源&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下回待續!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[API-d14] - [Javascript 番外篇] Javascript function scopes 和 closures</title>
      <link>http://blog.kerkerj.in/blog/api-d14---javascript-%E7%95%AA%E5%A4%96%E7%AF%87-javascript-function-scopes-%E5%92%8C-closures/</link>
      <pubDate>Tue, 14 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/api-d14---javascript-%E7%95%AA%E5%A4%96%E7%AF%87-javascript-function-scopes-%E5%92%8C-closures/</guid>
      <description>&lt;p&gt;這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正&lt;/p&gt;

&lt;p&gt;##Scope&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function hi() {
    var greetings = &amp;quot;hi&amp;quot;;

    console.log(&amp;quot;Say: &amp;quot; + greetings);

    function sayYa(newInput) {
        greetings = newInput;
        console.log(&amp;quot;Say: &amp;quot; + greetings);
    }

    function sayCool(newInput) {
        var cool = newInput;
        console.log(&amp;quot;Say: &amp;quot; + cool);
    }

    sayYa(&amp;quot;Yo&amp;quot;);
    sayCool(&amp;quot;Cool&amp;quot;);

    console.log(&amp;quot;Say: &amp;quot; + greetings);
}

hi();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很簡單的概念&lt;/p&gt;

&lt;p&gt;greetins 在 sayYa 方法中被覆寫掉了&lt;/p&gt;

&lt;p&gt;如果要定義 local 變數必須在 function 裏用 var 定義&lt;/p&gt;

&lt;p&gt;例如 sayCool function&lt;/p&gt;

&lt;p&gt;##Closure&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function person(){
    var name = &#39;default&#39;;

    return {
        greetings: function() {
            console.log( name );
        },
        changeName: function(newInput) {
            name = newInput;
        }
    };
}

var me = new person();
me.greetings();
me.changeName(&amp;quot;kerkerj&amp;quot;);
me.greetings();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Self-Executing Anonymous Functions&lt;/p&gt;

&lt;p&gt;使用這種方式通常是避免和其他 js 檔案造成變數混淆&lt;/p&gt;

&lt;p&gt;或是初始化&lt;/p&gt;

&lt;p&gt;裡面的變數和 function 只被限制在這個範圍內&lt;/p&gt;

&lt;p&gt;例子:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var hi = &#39;Hello&#39;;

    function sayHi(name){
        return hi + &#39; &#39; + name;
    }

    global.greetings = sayHi
})(global);

console.log(global.greetings(&amp;quot;kerkerj&amp;quot;));
console.log(hi); // &amp;lt;- 這會失敗
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必須將 sayHi 指給 global 的某一個變數, 才有辦法使用它&lt;/p&gt;

&lt;p&gt;在 node.js 中 global 是全域變數，在瀏覽器中是 window~&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[API-d13] - [Javascript 番外篇] Javascript require/ module/ Module Pattern</title>
      <link>http://blog.kerkerj.in/blog/api-d13---javascript-%E7%95%AA%E5%A4%96%E7%AF%87-javascript-require/-module/-module-pattern/</link>
      <pubDate>Mon, 13 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>http://blog.kerkerj.in/blog/api-d13---javascript-%E7%95%AA%E5%A4%96%E7%AF%87-javascript-require/-module/-module-pattern/</guid>
      <description>&lt;p&gt;接下來幾天會探討 node.js 的特性，由於比較少在寫 js ，因此有錯請指正&lt;/p&gt;

&lt;p&gt;在 node.js 裏，要讀取外部模組都是透過 require 和 exports 來做溝通&lt;/p&gt;

&lt;p&gt;以下列出這次最簡單 module 的例子&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;//hello.js
console.log(&#39;Hello World&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;// app.js
require(&#39;./hello.js&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##Module 也是有 Pattern 的&lt;/p&gt;

&lt;p&gt;第一種: Global (Not so good)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// foo.js
foo = function() {
	console.log(&amp;quot;foo!&amp;quot;);
}

// app.js
require(&#39;./foo.js&#39;);
foo();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二種: export an anonymous function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// foo.js
module.exports = function() {
	console.log(&amp;quot;foo! YA&amp;quot;);
};

// app.js
var test = require(&amp;quot;./foo.js&amp;quot;);
test();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三種： export a named function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bar.js
exports.bar = function() {
	console.log(&amp;quot;bar&amp;quot;);
}

// app.js
var bar = require(&#39;./bar.js&#39;).bar;
bar();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第四種: exports an anoymous object&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bar4.js
var Bar4 = function() {};

Bar4.prototype.say = function() {
    console.log(&#39;bar4&#39;);
};

module.exports = new Bar4();

// app.js 
var b = require(&#39;./bar4.js&#39;);
b.say();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第五種: export a named object&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// bar5.js
var Bar5 = function() {};

Bar5.prototype.say = function() {
    console.log(&amp;quot;bar5&amp;quot;);
};

exports.Bar5 = new Bar5();

// app.js
var b = require(&#39;./bar5.js&#39;).Bar5;
b.say();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第六種: export an anonymous prototype&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// cool.js
var Cool = function() {};

Cool.prototype.say = function() {
    console.log(&#39;Cool!&#39;);
};

module.exports = Cool;

// app.js
var Cool = require(&#39;./cool.js&#39;);
var coo = new Cool();
coo.say();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第七種: export a named prototype&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ang.js
var Ang = function () {};

Ang.prototype.say = function () {
    console.log(&#39;Ang!&#39;);
};

exports.Ang = Ang;

// app.js
var Ang = require(&#39;./ang.js&#39;).Ang;
var wer = new Ang();
wer.say();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##exports v.s. module.exports&lt;/p&gt;

&lt;p&gt;exports 是 module.exports 的輔助方法&lt;/p&gt;

&lt;p&gt;以下有個例子會執行錯誤:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ya.js
module.exports = &amp;quot;YA&amp;quot;;
exports.name = function() {
    console.log(&#39;My name is kerkerj&#39;);
};

// app.js
var ya = require(&#39;./ya.js&#39;);
ya.name(); TypeError: Cannot call method &#39;name&#39; of undefined
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 ya.js 中 module.exports 有屬性了&lt;/p&gt;

&lt;p&gt;因此下面的 export.name 就沒有被加入了&lt;/p&gt;

&lt;p&gt;如果 module.exports 沒有任何屬性被加入的話，&lt;/p&gt;

&lt;p&gt;exports 若有屬性了，則會交給 module.exports&lt;/p&gt;

&lt;p&gt;反之就是剛剛的情況，moduel.exports 已經有屬性了，因此 export.name 就沒有作用了&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.hacksparrow.com/node-js-exports-vs-module-exports.html&#34;&gt;延伸閱讀&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;##Module as class&lt;/p&gt;

&lt;p&gt;直接看例子吧 XD&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// user.js
module.exports = function(name, age) {
    this.name = name;
    this.age = age;
    this.about = function() {
        console.log(this.name +&#39; is &#39;+ this.age +&#39; years old&#39;);
    };
};

// app.js
var User = require(&#39;./user.js&#39;);
var kerkerj = new User(&#39;kerkerj&#39;, 18);
kerkerj.about(); 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>