---
title: "[Swift-d7] - Playground - Closures"
description: "閉包表達式語法： swift { (parameters) -> returnType in statements } 舉個例子: func multiple(value: Int, multiple: Int -> Int) -> Int { return multiple(value) }..."
date: 2014-10-07
categories: ['Swift']
tags: ['鐵人賽']
---


閉包表達式語法：

```swift
{ (parameters) -> returnType in
    statements
}
```

舉個例子:

```
func multiple(value: Int, multiple: Int -> Int) -> Int {
    return multiple(value)
}

multiple(3, { (value) -> Int in
    value * 3
})
```

在 `multiple` function 中需要傳入一個 `function`

在這邊我們並沒有另外定義，而是直接使用閉包的方式傳入一個 `function`

這個閉包就符合了上面的定義


## 根據上下文判斷型別 (Inferring type from context)

承上一個例子，我們可以寫得更簡潔一點

```
multiple(3, { value in
    value * 3
})
```

這是因為 Swift 會根據兩邊的定義來判斷型別，因此可以寫得更簡潔一些

### 參數名稱縮寫, 運算子函式

直接看例子

```
func biggerThan0(value: Int, isBigger: Int -> Bool) -> Bool {
    return isBigger(value)
}

biggerThan0(-1,
    { $0 > 0 }
)
```

### 尾隨閉包 (trailing closures)

通常如果閉包太長的話，可以把閉包接在括號後面：

```
func someFunc(closure: () -> ()) {
	// main
}

someFunc({
	// closure main
})

somFunc() {
	// closure main
}
```

以上面的例子做例子:

```
func biggerThan0(value: Int, isBigger: Int -> Bool) -> Bool {
    return isBigger(value)
}

biggerThan0(-1) { $0 > 0 }
```

如果是不需要參數的話，甚至可以把 () 省略掉

這邊直接參考一下別人的例子，是使用 array map 方法

下面要做的事情是

將 [16,58,510] 轉成 ["OneSix", "FiveEight", "FiveOneZero"]

```
let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]

let numbers = [16, 58, 510]

let strings = numbers.map {
    (var number) -> String in
    var output = ""
    while number > 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
```

這個例子中，array 的 map 會用後面接的閉包，接連的處理陣列裡面的元素

所以最後 strings 的陣列就是處理過後的陣列

而處理的方法則是將 Int 的每個位數分別轉換成 String 連接起來再回傳

很方便的方法!

