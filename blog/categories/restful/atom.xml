<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Restful | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/restful/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-20T18:50:22+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d20] - 實戰開發 - Routes 2, Get Params and Request Data]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/20/api-d20/"/>
    <updated>2014-10-20T18:46:12+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/20/api-d20</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day20">Github 參考</a></p>

<p>接著我們要根據我們開之前寫好的 <a href="http://docs.todolist7.apiary.io/">文件</a> 來開發:</p>

<p>要有下列 routes</p>

<pre><code class="javascript">TODOs
GET /user/{user_id}/todos/
POST /user/{user_id}/todos/
GET /user/{user_id}/todos/{id}
PUT /user/{user_id}/todos/{id}
DELETE /user/{user_id}/todos/{id}
</code></pre>

<p>這樣的需求其實可以用 namespace 實作，不過我們偷懶一點，直接指向 /user 就好</p>

<p>所以在 app.js 加入</p>

<pre><code>var users = require('./routes/users');
app.use('/user', users);
</code></pre>

<p>所以會變這樣:</p>

<pre><code>var express = require('express');
var app = express();

// Set routers
var index = require('./routes/index');
var users = require('./routes/users');

app.use('/', index);
app.use('/user', users);

module.exports = app;
</code></pre>

<p>不過看起來我們缺少 routes/users.js，所以我們也來新增一個</p>

<p>routes/users.js 內容如下</p>

<pre><code>'use strict';

var express = require('express');
var router = express.Router();

router.get('/', function(req, res) {

});

router.post('/', function(req, res) {

});

router.get('/', function(req, res) {

});

router.put('/', function(req, res) {

});

router.delete('/', function(req, res) {

});

module.exports = router;
</code></pre>

<p>好像有那麼一點符合我們要的 routes 了</p>

<p>我們在把每個詳細的 uri 加入</p>

<p>在這邊要注意</p>

<p>因為我們在 app.js 中把 uers.js 加入了 (&lsquo;/users&rsquo;, users)</p>

<p>這個 route</p>

<p>因此在 users.js 中設定的所有 route 都是接在 <code>/users/</code> 後面的</p>

<p>要注意哦</p>

<p>修改後的檔案:</p>

<pre><code>'use strict';

var express = require('express');
var router = express.Router();

// Get todo list
router.get('/:user_id/todos', function(req, res) {
    res.status(200).json( {success: "GET lists"} );
});

// Create a todo task
router.post('/:user_id/todos', function(req, res) {
    res.status(200).json( {success: "POST"} );
});

// Get a todo task
router.get('/:user_id/todos/:todo_id', function(req, res) {
    res.status(200).json( {success: "GET 1 task"} );
});

// Update a todo task
router.put('/:user_id/todos/:todo_id', function(req, res) {
    res.status(200).json( {success: "PUT"} );
});

// Delete a todo task
router.delete('/:user_id/todos/:todo_id', function(req, res) {
    res.status(200).json( {success: "DELETE"} );
});

module.exports = router;```
</code></pre>

<p>將 server 重啟，試著對這些網址丟丟看</p>

<p>這時候使用瀏覽器應該就沒辦法丟 GET 以外的要求了對吧?</p>

<p>此時 chrome extension - POSTMAN 就該上場啦！</p>

<p>打開 POSTMAN 就可以送以下的 request 囉!</p>

<pre><code>GET http://localhost:3000/user/kerkerj/todos  
POST http://localhost:3000/user/kerkerj/todos  
GET http://localhost:3000/user/kerkerj/todos/1  
PUT http://localhost:3000/user/kerkerj/todos/1  
DELETE http://localhost:3000/user/kerkerj/todos/1  
</code></pre>

<p>因為剛剛程式裡面都只讓他回傳 success，因此還沒有太大的作用，</p>

<p>不過已經有感覺了對吧!! XD</p>

<h2>Get params from url</h2>

<p>我們現在先針對以下這段程式碼作進一步的改寫:</p>

<pre><code>// Get a todo task
router.get('/:user_id/todos/:todo_id', function(req, res) {
    res.status(200).json( 
        { 
            success: "GET 1 task", 
            user: req.params.user_id,
            todo_id: req.params.todo_id
        } );
});
</code></pre>

<p>存檔並打開 server，存取 <a href="http://localhost:3000/user/test/todos/1">http://localhost:3000/user/test/todos/1</a></p>

<p>就可以看到回傳值是:</p>

<pre><code>{
    "success": "GET 1 task",
    "user": "kerkerj",
    "todo_id": "1"
}
</code></pre>

<p>所以又學到一招了!</p>

<p>先設定想要抓哪一段網址，例如:</p>

<p><code>/:user_id/todos/:todo_id</code></p>

<p>前面有加冒號的就是這段網址是要被抓成一個參數</p>

<p>而冒號後面接的就是之後在下面要使用到的名字</p>

<p>要接網址的參數的拿法 - req.params.{???}</p>

<p>例如:</p>

<p>req.params.user_id</p>

<p>req.params.todo_id</p>

<p>拿到了網址的參數，就可以對資料庫做進一步的查詢</p>

<h2>Get request data</h2>

<p>那要怎麼拿到 request 的 data 呢?</p>

<p>他並不存在于網址列上啊?</p>

<p>這時候就要加入 <code>body-parser</code> 了!</p>

<p>他會在接收到 request 時，幫我們做過處理後，再傳到每個 request 該去的 router 裏</p>

<p>在 app.js 中加入</p>

<pre><code>// 最上面
var bodyParser = require('body-parser');

// 加在 router 前面，切記!!
app.use( bodyParser.json() );
app.use( bodyParser.urlencoded({ extended: true }) );

app.use('/', index);
app.use('/user', users);
</code></pre>

<p>接著在 users.js 中的 POST 區塊中加入兩行:</p>

<pre><code>// Create a todo task
router.post('/:user_id/todos', function(req, res) {
    var data = req.body;

    res.status(200).json( {success: data } );
});
</code></pre>

<p>開啓 server, 用下圖的方式對 server 做 request:</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-09%2023.00.10.png" alt="image" /></p>

<p>記得要加入 header -</p>

<p>Content-Type - application/json</p>

<p>Data 要選擇 raw data - 使用自己寫的 json 格式</p>

<p>就可以看到下面的回傳格式了!</p>

<p>透過拿到 url params 以及 request data</p>

<p>我們就可以使用這些資料來對資料庫做存取了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d18] - 實戰開發 - 套件模組]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/18/api-d18/"/>
    <updated>2014-10-18T18:28:19+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/18/api-d18</id>
    <content type="html"><![CDATA[<h2>會使用到的套件:</h2>

<pre><code>主體:
express - web framework
body-parser - parse request body

測試相關:
mocha - test framework
mocha-mongoose - 用來和 mocha 和 mongoose 中間做介接的套件
superagent - 拿它來丟 http request
validator - 用來驗證某個物件是否為某個型別
expect.js - 類似 BDD 的語法，用來寫測試的
debug - debug package

DB 相關:
mongoose - mongodb orm
mongodb - mongodb native driver

開發相關:
nodemon - detect file change and restart server

生產環境相關:
log4js - 記錄 request log
</code></pre>

<p>這是我的 package.json, 可以複製到專案目錄，然後下 <code>npm install</code></p>

<pre><code>{
  "name": "TODOAPI",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "start": "node ./bin/server.js env=development",
    "test": "./node_modules/mocha/bin/mocha",
    "test-detail": "./node_modules/mocha/bin/mocha --reporter list",
    "stop": "pkill -lf server.js"
  },
  "author": "kerkerj",
  "license": "ISC",
  "dependencies": {
    "body-parser": "^1.9.0",
    "debug": "^2.0.0",
    "expect.js": "^0.3.1",
    "express": "^4.9.5",
    "log4js": "^0.6.21",
    "mocha": "^1.21.4",
    "mocha-mongoose": "^1.0.1",
    "mongodb": "^1.4.19",
    "mongoose": "^3.8.17",
    "superagent": "^0.20.0",
    "validator": "^3.19.1"
  }
}
</code></pre>

<h2>安裝套件，及全域套件 mocha</h2>

<pre><code>// in project folder
$ npm install express body-parser mocha mocha-mongoose superagent validator expect.js debug mongoose mongodb log4js -save 
$ npm install -g nodemon
</code></pre>

<h2>各個套件簡單設定</h2>

<p>接下來會針對一些套件作說明，但是由於可能有些人不懂整個專案的運作，因此下面看看就好，之後實作上有問題可以再回來看。</p>

<h2>Nodemon 的作用</h2>

<p>範例:</p>

<pre><code>$ nodemon ./bin/server.js
...
</code></pre>

<p>就可以放著不管它了~ 只要檔案有變動，就會自動重開 server</p>

<h2>使用 logger - log4js</h2>

<p>設定 logger - log4js, 並將 log 寫入到 logs/access.log 裏</p>

<pre><code>// Set logger
var log4js = require('log4js');
log4js.configure({
    appenders: [
        { type: 'console' }, //控制台輸出
        {
            type: 'file', //文件輸出
            filename: 'logs/access.log',
            maxLogSize: 20000000, // 20 MB
            backups: 10,
            category: 'normal'
        }
    ],
    replaceConsole: true
});

var logger = log4js.getLogger('normal');
logger.setLevel('INFO');

app.use(log4js.connectLogger(logger, {level: 'auto', format:':method :url'}));
</code></pre>

<p><a href="http://blog.fens.me/nodejs-log4js/">node log4s</a></p>

<h2>使用 body-parser 處理 request 的資料</h2>

<p>加入 middleware</p>

<pre><code>app.use( bodyParser.json() );
app.use( bodyParser.urlencoded({ extended: true }) );
</code></pre>

<p>需要加入 { extended: true/false }, 否則會 warning:</p>

<p>body-parser deprecated undefined extended: provide extended</p>

<p>如果要接收 json request</p>

<p>client 端在 Header 中必須先設定 &ldquo;Content-type: applciation/json&rdquo;</p>

<p>才能夠在 router 中使用 <code>req.body</code> 拿到 json 值</p>

<h2>測試套件</h2>

<pre><code>mocha - 專案
expect.js - 專案
superagent - 專案
</code></pre>

<p>測試流程 -</p>

<p>先跑 server 起來，透過自動化程式自動丟 request 給 server，測試結束</p>

<pre><code>$ npm start
$ mocha
$ npm stop
</code></pre>

<p>所以必須先在 package.json 中設定好 script</p>

<pre><code>{
    (...)
    "scripts": {
      "start": "node ./bin/server.js",
      "test": "mocha",
      "stop": "pkill -lf server.js"
  },
  (...)
}
</code></pre>

<p>由於我將啟動 server 的 script 放在 bin 資料夾裡，因此</p>

<p><code>npm start</code> 的 script 就會執行:</p>

<pre><code>node ./bin/server.js
</code></pre>

<p><code>npm stop</code> 的話，用到了 *nix 的指令，會先到 process list 中找到和 server.js 有關的 process，然後 kill process (<code>pkill</code>)</p>

<pre><code>pkill -lf server.js
</code></pre>

<p>跑測試的話，直接下 <code>mocha</code>，在這邊我們也丟一個 script 指定給 <code>npm test</code></p>

<p>下 <code>npm test</code> 就是等同於下 <code>mocha</code></p>

<p>上面只是大致上講解一下每個套件如何用，接下來我們會以實際的例子來說明</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d17] - 實戰開發 - 專案結構]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/17/api-d17/"/>
    <updated>2014-10-17T21:17:00+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/17/api-d17</id>
    <content type="html"><![CDATA[<p>首先我們就在虛擬機的資料夾底下，建立一個專案資料夾吧!</p>

<p>今天會來簡單切割一下我們的專案目錄</p>

<h2>建立新專案目錄:</h2>

<pre><code>$ cd /vagrant/
$ mkdir TODOAPI
$ cd TODOAPI
$ npm init
// 輸入專案資訊
$ 
</code></pre>

<h2>建立專案結構</h2>

<pre><code>/
| - bin/
| - routes/
| - model/
| - node_modules/
| - logs/
| - config/
| - test/
| - app.js
| - package.json
</code></pre>

<p>分別講解一下各個 folder 的工作:</p>

<h3><code>bin</code></h3>

<p>筆者會在 <code>bin</code> 資料夾底下放一個 <code>server.js</code></p>

<p>這個 <code>server.js</code> 就是會專門用來啟動一個 <code>app.js</code> instance</p>

<h3><code>routes</code></h3>

<p>基本上如果了解 MVC 架構的話，<code>routes</code> 就是 <code>controller</code> 的意思，其實如果讀者本身夠了解的話，這個資料夾也可以改成 <code>controller</code> 也 ok，應該說，其實資料夾怎麼放都是看個人隨意即可，只是若是要模組化的話，筆者會這樣來處理一個專案結構。</p>

<h3><code>model</code></h3>

<p>拿來放資料庫 schema 以及相關的資料庫操作的資料夾</p>

<h3><code>node_modules</code></h3>

<p>這其實是之後安裝的模組會放在這個資料夾裡，在這邊可以先不用建立沒關係</p>

<h3><code>logs</code></h3>

<p>由於我們是建立一個 restful service，因此 log 的記錄也是很重要的，我們把 log 放在這個資料夾裡</p>

<h3><code>configs</code></h3>

<p>我們在這個資料夾裡放置一些專案設定，例如 db 設定或者是 log 的設定等等</p>

<h3><code>test</code></h3>

<p>撰寫測試程式的資料夾~</p>

<h3><code>app.js</code></h3>

<p>程式的進入點，可以想像成 index.php~</p>

<h3><code>package.json</code></h3>

<p>專案的資訊以及相關模組的資訊都會被放在這裡!</p>

<hr />

<p>其實關於專案結構有許多不同的討論，<code>express</code> 也有一個專案自動產生器，不過如果對結構內容不了解而使用產生器的話，很容易變成只知表面不知內部運作，因此我們還是一步一步來，先定義好我們專案的需求結構</p>

<p>另外，因為我們是建立 restful API service，在此並沒有用到 html 頁面，也因此就沒有 <code>view</code> 或 <code>public</code> 這兩個資料夾囉~</p>

<p>延伸閱讀:</p>

<p>我們可以透過觀摩別人的專案來參考他們的專案架構:</p>

<p><a href="http://scotch.io/tutorials/javascript/node-and-angular-to-do-app-application-organization-and-structure">Node and Angular To-Do App: Application Organization and Structure</a></p>

<p><a href="http://stackoverflow.com/questions/18789864/node-js-express-global-modules-best-practices-for-application-structure">node.js &amp; express - global modules &amp; best practices for application structure</a></p>

<p>在 Github 上的討論，非常值得一看: <a href="https://gist.github.com/lancejpollard/1398757">Github discussion</a></p>

<p>後來覺得也可以模仿 rails 的分法:</p>

<pre><code>/
| - app/
| - ----controllers/
| - ----models/
| - ----views/
| - ----helpers/
| - node_modules/
| - logs/
| - libs/
| - public/
| - config/
| - test/
| - server.js
| - package.json
</code></pre>

<p>都 OK!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d16] - 實戰開發 - 設定主題及規劃]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/16/api-d16/"/>
    <updated>2014-10-16T18:39:40+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/16/api-d16</id>
    <content type="html"><![CDATA[<p>接下來我們想要做到的是一個 TODO list 的 RESTful API</p>

<p>並且會先使用 <a href="http://apiary.io/">apiary.io</a> 做規劃</p>

<p>實際看看感覺如何</p>

<p>進入網站後，註冊登入後</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.04.07.png" alt="image" /></p>

<p>左上角的 dropdown list 選擇 create new API</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.04.18.png" alt="image" /></p>

<p>產生後下方就會跑出範例文擋</p>

<p>這個網站會透過特定格式的編排自己希望的 API endpoint 及範例回傳值後，產生出一份漂亮的文件</p>

<p>網站中間是模式的選擇</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.10.33.png" alt="image" /></p>

<p>Documentation 是實際讓其他人看的，Editor 則是編輯模式</p>

<p>我們就稍微簡單規劃一下 TODO List 的 RESTful API 吧!</p>

<p>這是我自己規劃的 <a href="http://docs.todolist7.apiary.io/">文件</a></p>

<p>基本上 route 會長這個樣子:</p>

<pre><code>TODOs
GET /user/{user_id}/todos/
POST /user/{user_id}/todos/
GET /user/{user_id}/todos/{id}
PUT /user/{user_id}/todos/{id}
DELETE /user/{user_id}/todos/{id}
</code></pre>

<p>資料格式也都在該文件整理好了</p>

<p><code>/user/{user_id}/</code> 只是用來辨識是哪個 user 的 todo task data</p>

<p>在這個小 API 不會琢磨在使用者系統的建立，只會專注在操作 todo task data</p>

<p>我們可以直接透過 PostMan 來丟丟看</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.43.06.png" alt="image" /></p>

<p>我們設定必須要使用 API-key 才能存取 API，比較進階的做法就是使用 Oauth 的方式取得 token 來存取 API</p>

<p>不過在這個小 API 也不會建立一個 Oauth Server，我們簡單使用 API-key 來認證即可</p>

<p>接下來的時間我們就會開始依據規劃好的文件，使用 Node.js + express + mongodb 來實作囉!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d15] - [Javascript 番外篇] Javascript Callback, Event]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/15/api-d15/"/>
    <updated>2014-10-15T18:34:37+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/15/api-d15</id>
    <content type="html"><![CDATA[<p>這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<p>javascript 有個特性：event</p>

<p>意思就是說，javascript 中，所有的事情都是由事件驅動的</p>

<p>如果說有寫過 web 前端的話，</p>

<p>其實呼叫 button.click function 時</p>

<p>並不會馬上執行 click 裡面的動作</p>

<p>而是加了一個 click 的 listener</p>

<p>等到 button 被 click 後，才會執行 click 裡面的程式碼</p>

<p>所以寫習慣一般 procedure 的程式會有點不太習慣</p>

<p>舉個 procedure 的例子，下面有五件事想要做：</p>

<pre><code class="javascript">煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>一般的程式會是照順序執行</p>

<p>也就是 煮飯完 -> 接電話 -> 吃麵 -> 丟垃圾</p>

<p>總執行時間 = 23 分鐘</p>

<p>但是如果把這段 code 丟給 javascript 執行的話</p>

<pre><code>煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>就變成同時做煮飯，接電話，吃麵，丟垃圾了！</p>

<p>為了要預防這件事，有些事情還是有順序性的，</p>

<p>因此就要使用到 javascript callback 的特性</p>

<pre><code>煮飯(function() {
    吃飯(function() {
        接電話(function() {
            丟垃圾();
        });
    });
});
</code></pre>

<p>意思就是煮飯完吃飯，吃完飯接電話，接完電話丟垃圾</p>

<p>以下有一個範例：</p>

<pre><code class="javascript">function wash() {
    setTimeout(function() {
        console.log("wash");
    }, 1000);
}

function eat() {
    setTimeout(function() {
        console.log("eat");
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork() {
    wash();
    eat();
    running();
}

doHouseWork();
</code></pre>

<p>做家事執行了三件事，wash, eat, 和 running</p>

<p>其中每件事都設定不同的完成時間</p>

<p>以 procedure 的程式執行方式來看，在這邊用 ruby 舉例:</p>

<pre><code class="ruby">def wash
  sleep 1
  puts "wash"
end 

def eat
  sleep 5
  puts "eat"
end 

def running 
  sleep 3
  puts "running"
end 

def doHouseWork 
  wash
  eat
  running
end 

doHouseWork
</code></pre>

<p>是會 wash 1 秒後，接著 eat 5 秒，再 running 3 秒</p>

<p>所以總共是 9 秒</p>

<p>output 的順序會是:</p>

<pre><code>wash // 1 秒
eat // 5 秒
running // 3 秒
</code></pre>

<p>但是在 javascript 中，output 的順序卻是:</p>

<pre><code>wash // 1 秒
running // 3 秒
eat // 5 秒
</code></pre>

<p>所以總長度是 5 秒</p>

<p>那今天假設想要讓 javascript 有順序性時該怎麼辦?</p>

<p>拿上面的例子作修改的話:</p>

<pre><code class="javascript">function wash(callback) {
    setTimeout(function() {
        console.log("wash");
        callback.call();
    }, 1000);
}

function eat(callback) {
    setTimeout(function() {
        console.log("eat");
        callback.call();
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork(callback) {
    console.log("doing house work");
    callback.call();
}

doHouseWork(function(){
    wash(function() {
        eat(function() {
            running();
        });
    });
});
</code></pre>

<p>很不錯的特性，但是也要特別對於這種特性作處理</p>

<p>有個 lib 很好用，<code>async.js</code> <a href="https://github.com/caolan/async">來源</a></p>

<p>下回待續!</p>
]]></content>
  </entry>
  
</feed>
