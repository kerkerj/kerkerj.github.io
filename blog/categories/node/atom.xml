<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Node | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/node/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2015-04-23T02:01:04+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d8] - Node.js - Hello World!]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/08/api-d8/"/>
    <updated>2014-10-08T13:04:20+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/08/api-d8</id>
    <content type="html"><![CDATA[<h1>Node.js - Hello World!</h1>

<p>一樣先開虛擬機哦~</p>

<p>並且開啟終端機連進 server 裡面~</p>

<p>以下是 <a href="http://nodejs.org/">Node.js</a> 官方網站的 web server 程式範例，我稍作小修改：</p>

<pre><code class="javascript">var http = require('http');

http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(1337, '0.0.0.0');

console.log('Server running at http://0.0.0.0:1337/');
</code></pre>

<p>我們先在虛擬機的資料夾建立一個子資料夾 &lsquo;HelloWorld&rsquo;</p>

<p>在 HelloWorld 資料夾裡面建立一個 app.js</p>

<p>內容如上，存檔。</p>

<p>使用終端機進入 server :</p>

<pre><code>$ vagrant ssh
$ cd /vagrant/HelloWorld
$ node app.js
</code></pre>

<p>到瀏覽器輸入 <a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a></p>

<p>(或者是你的 Vagrantfile 裡面設定的 private IP)</p>

<p>即可看到 Hello World 了！</p>

<p>要關掉 Server 也非常簡單，回到下指令的地方，按下 ctrl + c 即可中斷程式</p>

<h2>分析</h2>

<p>簡單分析一下此段程式：</p>

<pre><code class="javascript">var http = require('http');
</code></pre>

<p>將 http 這個模組引入，並指定給物件 http</p>

<pre><code class="javascript">http.createServer(
    ...
).listen(1337, '0.0.0.0');
</code></pre>

<p>先略過中間的 function 不看，<br/>
這段 code 的用意即是讓呼叫 http 物件中的 createServer 的方法，
.listen() 則是設定該 server 要跑在哪個 port、hostname</p>

<pre><code class="javascript">function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}
</code></pre>

<p>上面的 code 則是原本在 .createServer() 裡的，
我們可以看一下 Node.js 的 API doc <a href="http://nodejs.org/api/http.html#http_http_createserver_requestlistener">關於此方法的部分</a></p>

<p>.createServer() 要帶入的東西其實是一個 requestListener，<br/>
也就是當 Server 跑起來時，我們開啟瀏覽器，輸入 127.0.0.1:1337 時，<br/>
Node.js Server 要回丟的東西，因此觀察一下此 listener:</p>

<pre><code class="javascript">function (req, res) {
    ...
}
</code></pre>

<p>function 中帶入參數的是 req, res，意即 request, response，<br/>
request 即是 server 接收到 client 端的訊息，<br/>
response 則是 server 要回丟給 client 的訊息，<br/>
由於在此範例中，我們只是要回丟給 client 端一個 hello world 的訊息，
因此，我們不處理 client 送給 server 的 request，
我們只需處理要回丟給 client 的訊息，</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World\n');
</code></pre>

<p>寫網頁的開發者應該對一些關鍵字例如 Content-type, text/plain 不陌生，<br/>
第一行代表回傳給使用者的訊息中，HTTP HEAD 的設定是 http status code 200,
並且 Content-type 設定為 text/plain</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
</code></pre>

<p>那麼，以下這行 code 的意思即是，此次要回送給使用者的訊息到這裡結束，以 &ldquo;Hello World&rdquo; 作結尾</p>

<pre><code class="javascript">res.end('Hello World\n');
</code></pre>

<p>因此整段 code 看下來，就是一個非常簡單的 http server，</p>

<p><a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a> 總是會回傳 Hello World</p>

<p>今天就完成了我們的 Hello World 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event-driven I/O Models and Coroutine Notes]]></title>
    <link href="http://kerkerj.github.io/blog/2014/08/18/event-driven-i-slash-o-models-and-coroutine/"/>
    <updated>2014-08-18T23:19:51+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/08/18/event-driven-i-slash-o-models-and-coroutine</id>
    <content type="html"><![CDATA[<h2>Event-driven I/O model</h2>

<p>首先，聽到 Event-driven 是從 <a href="http://nodejs.org/">Node.js</a> 得知，</p>

<blockquote><p>Node.js® is a platform built on <a href="http://code.google.com/p/v8/">Chrome&rsquo;s JavaScript runtime</a> for easily building fast, scalable network applications.</p>

<p>Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</p></blockquote>

<p>其實剛聽到這詞會有點陌生，我們可以先從 Victor 所寫的文章開始讀起:
<a href="http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/">淺談coroutine與gevent</a></p>

<p>裡面提到了幾種網路模型：</p>

<blockquote><ol>
<li>阻塞式單一行程</li>
<li>阻塞式多行程</li>
<li>阻塞式多行程多執行序</li>
<li>非阻塞式事件驅動</li>
<li>非阻塞式 coroutine</li>
</ol>
</blockquote>

<p>以下是各語言 event-driven 的 model<br/>
(Node.js 就不列出了，本身就是 event-driven 設計)</p>

<pre><code>Event-driven model:
* Ruby  -&gt; [Eventmachine](http://rubyeventmachine.com/)  
            -&gt; [Celluloid::IO](https://github.com/celluloid/celluloid-io)   
            -&gt; [Thin Server](http://code.macournoyer.com/thin)   
* Python    -&gt; [Twisted](https://twistedmatrix.com/trac/)  
            -&gt; [Tornado](http://www.tornadoweb.org/en/stable)   
* Perl   -&gt; [Perl Object Environment (POE)](http://poe.perl.org)    
* PHP       -&gt; [REACT](http://reactphp.org) 
</code></pre>

<p>以 Ruby 建構 API Service 的話，可以使用 Sinatra + Eventmachine + thin proxy + Nginx 的 Solution:<br/>
<a href="http://recipes.sinatrarb.com/p/embed/event-machine">Embedding Sinatra within EventMachine</a></p>

<p>延伸閱讀: <br/>
<a href="https://www.igvita.com/2008/05/27/ruby-eventmachine-the-speed-demon/">2008 - Eventmachine and Reactor pattern</a> <br/>
<a href="http://developwithstyle.com/articles/2012/05/23/lessons-learnt-from-building-a-rest-based-api/">2012 - Lessons Learnt From Building a REST API</a><br/>
<a href="https://docs.google.com/document/d/1dU-juYN25FMXdp6Ju62KAIT_0tuuZAPEgZkj-aT6kPQ/edit#heading=h.lafes4uxj2b0">年份未知 - 針對各 framework 進行評測 Event Driven I/O Web Application Server Analysis</a><br/>
<a href="http://blog.sina.com.cn/s/blog_704b6af70100py9n.html">Twisted 教程</a></p>

<h4>Reactor 模型</h4>

<p>Node.js 處理 concurrency 是 Reactor mode<br/>
Ruby 的 Goliath framework 也是 Reactor mode<br/>
Golang, Erlang 是 CSP (communicating sequential process)</p>

<p>現在比較流行的是 event-driven 的 Reactor mode, e.g. Node.js, Goliath<br/>
但是 Node.js 比較令人詬病的是 code 難維護，太多層層的 callback 會擾亂邏輯<br/>
畢竟線性處理比較符合人類思維 <br/>
而 Ruby 使用 Fiber 以避免寫出過多的 callback<br/>
Python 的 Twisted 也已經存在好一陣子，穩定發展中</p>

<p>不過以 Node.js 典型的應用的確是 proxy, API server<br/>
因此我們可以參考 Node.js 的特性，使用其他語言來達到同樣的效果<br/>
那就是 event-driven</p>

<h2>Coroutine Programming</h2>

<pre><code>* Golang - goroutine (native) 
* Python - [gevent](http://www.gevent.org/)  
* Ruby - Fiber (native)   
* Lua   
</code></pre>

<p>延伸閱讀:<br/>
<a href="http://www.bigfastblog.com/">Ruby 的 eventmachine 相關討論</a><br/>
<a href="http://www.blogjava.net/killme2008/archive/2010/03/11/315158.html">Ruby Fiber 指南</a><br/>
<a href="http://electronic-blue.herokuapp.com/blog/2012/06/coroutine-an-introduction/">2012 - Lua - Coroutine introduction</a><br/>
<a href="https://www.igvita.com/2009/05/13/fibers-cooperative-scheduling-in-ruby/">2009 - Fibers &amp; Cooperative Scheduling in Ruby</a><br/>
<a href="http://www.blogjava.net/killme2008/archive/2010/03/02/314264.html">2010 - Lua、LuaJIT Coroutine和Ruby Fiber的切換效率對比</a></p>

<hr />

<p>建構 API Service 考慮到的除了 Server 以外，<br/>
語言的特性通常也必須考慮進去，例如<br/>
sync v.s. async<br/>
coroutine v.s. non-coroutine<br/>
但通常以當前需求而言，其實也不需要 over-design<br/>
只要選擇拿手的，能夠快速方便的開發出雛形，<br/>
我想等到真的快要 10000 per/second request 時，再來煩惱更進一步的架構吧</p>
]]></content>
  </entry>
  
</feed>
