<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Api | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/api/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-19T21:24:10+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d19] - 實戰開發 - Index & Route & Http Status Code]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/19/api-d19/"/>
    <updated>2014-10-19T21:19:24+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/19/api-d19</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day19">Github 參考</a></p>

<p>昨天先把專案目錄初始化，裝完該裝的套件後</p>

<p>在 routes 中加入一個 index.js 檔案</p>

<pre><code class="javascript">'use strict';

var express = require('express');
var router = express.Router();

router.get('/', function(req, res) {
    res.status(200).json({ greetings: "hello world!"});
});

module.exports = router;
</code></pre>

<p>建立一個 <code>app.js</code> 在專案根目錄中:</p>

<p>app.js</p>

<pre><code>var express = require('express');
var app = express();
var index = require('./routes/index');

// Set routers
app.use('/', index);

module.exports = app;
</code></pre>

<p>然後在 bin 資料夾建立一個 server.js:</p>

<p>bin/server.js:</p>

<pre><code>'use strict';

var debug = require('debug')('TODOAPI');
var app = require('../app');

app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
    debug('Express server listening on port ' + server.address().port);
});
</code></pre>

<p>並且在 package.json 中修改並加入:</p>

<p>加入 <code>start</code> : <code>"start": "node ./bin/server.js",</code></p>

<pre><code>"scripts": {
    "start": "node ./bin/server.js",
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
</code></pre>

<p>這樣我們就可以透過 <code>npm start</code> 來啟動 server 了!</p>

<p>試著啟動看看 <code>npm start</code></p>

<p>到網址列輸入 <code>http://localhost:3000/</code></p>

<p>就可以看到 <code>{"greetings":"hello world!"}</code> 了!</p>

<p>我們從本文的後面往回看：其實就是一個 request 會經過的地方:</p>

<p>當我們下了 <code>npm start</code>，npm 會搜尋 package.json 中有沒有 <code>start</code> 指令</p>

<p>若有的話就會執行他所設定的指令 <code>node ./bin/server.js</code></p>

<p>這樣就會執行 server.js 了</p>

<p>我們再看一下 server.js，講解在底下的註解:</p>

<pre><code>// 使用嚴格模式
'use strict';

// 加入 debugger
var debug = require('debug')('TODOAPI');

// 將我們寫的 app.js 引入，建立一個 app instance
var app = require('../app');

// 設定 app instance 的 port, 若環境變數有設定的話就使用環境變數的值
// 沒有設定環境變數的話則是 3000
app.set('port', process.env.PORT || 3000);

// 啟動 server，讓 server 監聽剛剛上一行所設定的 port，
// 並且使用 debugger
var server = app.listen(app.get('port'), function() {
    debug('Express server listening on port ' + server.address().port);
});
</code></pre>

<p>既然 server.js 啟動了一個 app.js 的 instance</p>

<p>那我們就要來看一下 app.js</p>

<pre><code>// 引入 express 模組
var express = require('express');

// 初始化一個 express instance
var app = express();

// 將 route 引入
var index = require('./routes/index');

// 設定若有 request 進到 http://localhost:3000/ 時，
// 交給 routes/index.js 來作後續處理
app.use('/', index);

最後這一行是這個檔案 export 成一個模組
module.exports = app;
</code></pre>

<p>那現在我們了解到了，如果有一個要求打進了 <code>http://localhost:3000/</code></p>

<p>它會將該要求轉發給 routes/index.js 來作處理</p>

<p>因此我們再進到 index.js 看看內容</p>

<pre><code>// 使用嚴格模式
'use strict';

// 引入 express 模組
var express = require('express');

// 在這邊我們要使用 express 模組中的 Router
// 因為在 app.js 中，若是使用 app.use('/', index)
// 該 index 物件必須是一個 Router 物件，
// 因此在這邊我們才會這樣寫
// 於是 router 就是一個 express 的 router 物件了
var router = express.Router();

// 設定該  router 有哪些路徑要來聽
// 在這邊我們設定當有 request 進到 根目錄，
// 且是使用 GET 方法時，我們的回覆是:
// HTTP status code 爲 200
// 回傳的資料為 json 格式，傳入的內容是一個 javascript 物件
// .json 方法會幫我們轉成 json 格式回傳給使用者
router.get('/', function(req, res) {
    res.status(200).json({ greetings: "hello world!"});
});

// 最後將這個檔案 export 成一個 router 模組
module.exports = router;
</code></pre>

<p>所以透過這樣的方式我們就了解到了一個 request 是如何在模組化後的程式奔跑遊走</p>

<p>另外要特別提到的是 http status code</p>

<p>http status code 其實是一個非常好讓 client 知道這次 API request 發生什麼事的資料，充分利用 HTTP 協議所定義的狀態碼</p>

<p>我們有時候瀏覽網頁會看到: 404 Not found! 或是 500 Internal Server Error</p>

<p>這就是 HTTP status code</p>

<p>那我們可以透過定義好回傳的 http status code 來代表此次 request 的狀態</p>

<p>例如：</p>

<p>client 端輸入的 API 網址錯誤了</p>

<p>我們就回傳 status code: 404</p>

<p>如果是不小心 server 的 code 寫錯了，導致該次 request 完全讓 server 死掉了，</p>

<p>那就可以回傳 500 interanl server error</p>

<p>因此在做 error handling 時，請定義好 status code，他一定會有幫助的!</p>

<p>常用的 status code:</p>

<pre><code>200 - Success
201 - Created
400 - Bad request
401 - Unauthorized
403 - Forbidden
404 - Not found
500 - Internal Server Error
</code></pre>

<p>詳細還可以參考: <a href="http://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP status code</a></p>

<p><a href="http://www.restapitutorial.com/httpstatuscodes.html">其他教學</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d18] - 實戰開發 - 套件模組]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/18/api-d18/"/>
    <updated>2014-10-18T18:28:19+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/18/api-d18</id>
    <content type="html"><![CDATA[<h2>會使用到的套件:</h2>

<pre><code>主體:
express - web framework
body-parser - parse request body

測試相關:
mocha - test framework
mocha-mongoose - 用來和 mocha 和 mongoose 中間做介接的套件
superagent - 拿它來丟 http request
validator - 用來驗證某個物件是否為某個型別
expect.js - 類似 BDD 的語法，用來寫測試的
debug - debug package

DB 相關:
mongoose - mongodb orm
mongodb - mongodb native driver

開發相關:
nodemon - detect file change and restart server

生產環境相關:
log4js - 記錄 request log
</code></pre>

<p>這是我的 package.json, 可以複製到專案目錄，然後下 <code>npm install</code></p>

<pre><code>{
  "name": "TODOAPI",
  "version": "1.0.0",
  "description": "",
  "main": "app.js",
  "scripts": {
    "start": "node ./bin/server.js env=development",
    "test": "./node_modules/mocha/bin/mocha",
    "test-detail": "./node_modules/mocha/bin/mocha --reporter list",
    "stop": "pkill -lf server.js"
  },
  "author": "kerkerj",
  "license": "ISC",
  "dependencies": {
    "body-parser": "^1.9.0",
    "debug": "^2.0.0",
    "expect.js": "^0.3.1",
    "express": "^4.9.5",
    "log4js": "^0.6.21",
    "mocha": "^1.21.4",
    "mocha-mongoose": "^1.0.1",
    "mongodb": "^1.4.19",
    "mongoose": "^3.8.17",
    "superagent": "^0.20.0",
    "validator": "^3.19.1"
  }
}
</code></pre>

<h2>安裝套件，及全域套件 mocha</h2>

<pre><code>// in project folder
$ npm install express body-parser mocha mocha-mongoose superagent validator expect.js debug mongoose mongodb log4js -save 
$ npm install -g nodemon
</code></pre>

<h2>各個套件簡單設定</h2>

<p>接下來會針對一些套件作說明，但是由於可能有些人不懂整個專案的運作，因此下面看看就好，之後實作上有問題可以再回來看。</p>

<h2>Nodemon 的作用</h2>

<p>範例:</p>

<pre><code>$ nodemon ./bin/server.js
...
</code></pre>

<p>就可以放著不管它了~ 只要檔案有變動，就會自動重開 server</p>

<h2>使用 logger - log4js</h2>

<p>設定 logger - log4js, 並將 log 寫入到 logs/access.log 裏</p>

<pre><code>// Set logger
var log4js = require('log4js');
log4js.configure({
    appenders: [
        { type: 'console' }, //控制台輸出
        {
            type: 'file', //文件輸出
            filename: 'logs/access.log',
            maxLogSize: 20000000, // 20 MB
            backups: 10,
            category: 'normal'
        }
    ],
    replaceConsole: true
});

var logger = log4js.getLogger('normal');
logger.setLevel('INFO');

app.use(log4js.connectLogger(logger, {level: 'auto', format:':method :url'}));
</code></pre>

<p><a href="http://blog.fens.me/nodejs-log4js/">node log4s</a></p>

<h2>使用 body-parser 處理 request 的資料</h2>

<p>加入 middleware</p>

<pre><code>app.use( bodyParser.json() );
app.use( bodyParser.urlencoded({ extended: true }) );
</code></pre>

<p>需要加入 { extended: true/false }, 否則會 warning:</p>

<p>body-parser deprecated undefined extended: provide extended</p>

<p>如果要接收 json request</p>

<p>client 端在 Header 中必須先設定 &ldquo;Content-type: applciation/json&rdquo;</p>

<p>才能夠在 router 中使用 <code>req.body</code> 拿到 json 值</p>

<h2>測試套件</h2>

<pre><code>mocha - 專案
expect.js - 專案
superagent - 專案
</code></pre>

<p>測試流程 -</p>

<p>先跑 server 起來，透過自動化程式自動丟 request 給 server，測試結束</p>

<pre><code>$ npm start
$ mocha
$ npm stop
</code></pre>

<p>所以必須先在 package.json 中設定好 script</p>

<pre><code>{
    (...)
    "scripts": {
      "start": "node ./bin/server.js",
      "test": "mocha",
      "stop": "pkill -lf server.js"
  },
  (...)
}
</code></pre>

<p>由於我將啟動 server 的 script 放在 bin 資料夾裡，因此</p>

<p><code>npm start</code> 的 script 就會執行:</p>

<pre><code>node ./bin/server.js
</code></pre>

<p><code>npm stop</code> 的話，用到了 *nix 的指令，會先到 process list 中找到和 server.js 有關的 process，然後 kill process (<code>pkill</code>)</p>

<pre><code>pkill -lf server.js
</code></pre>

<p>跑測試的話，直接下 <code>mocha</code>，在這邊我們也丟一個 script 指定給 <code>npm test</code></p>

<p>下 <code>npm test</code> 就是等同於下 <code>mocha</code></p>

<p>上面只是大致上講解一下每個套件如何用，接下來我們會以實際的例子來說明</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d17] - 實戰開發 - 專案結構]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/17/api-d17/"/>
    <updated>2014-10-17T21:17:00+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/17/api-d17</id>
    <content type="html"><![CDATA[<p>首先我們就在虛擬機的資料夾底下，建立一個專案資料夾吧!</p>

<p>今天會來簡單切割一下我們的專案目錄</p>

<h2>建立新專案目錄:</h2>

<pre><code>$ cd /vagrant/
$ mkdir TODOAPI
$ cd TODOAPI
$ npm init
// 輸入專案資訊
$ 
</code></pre>

<h2>建立專案結構</h2>

<pre><code>/
| - bin/
| - routes/
| - model/
| - node_modules/
| - logs/
| - config/
| - test/
| - app.js
| - package.json
</code></pre>

<p>分別講解一下各個 folder 的工作:</p>

<h3><code>bin</code></h3>

<p>筆者會在 <code>bin</code> 資料夾底下放一個 <code>server.js</code></p>

<p>這個 <code>server.js</code> 就是會專門用來啟動一個 <code>app.js</code> instance</p>

<h3><code>routes</code></h3>

<p>基本上如果了解 MVC 架構的話，<code>routes</code> 就是 <code>controller</code> 的意思，其實如果讀者本身夠了解的話，這個資料夾也可以改成 <code>controller</code> 也 ok，應該說，其實資料夾怎麼放都是看個人隨意即可，只是若是要模組化的話，筆者會這樣來處理一個專案結構。</p>

<h3><code>model</code></h3>

<p>拿來放資料庫 schema 以及相關的資料庫操作的資料夾</p>

<h3><code>node_modules</code></h3>

<p>這其實是之後安裝的模組會放在這個資料夾裡，在這邊可以先不用建立沒關係</p>

<h3><code>logs</code></h3>

<p>由於我們是建立一個 restful service，因此 log 的記錄也是很重要的，我們把 log 放在這個資料夾裡</p>

<h3><code>configs</code></h3>

<p>我們在這個資料夾裡放置一些專案設定，例如 db 設定或者是 log 的設定等等</p>

<h3><code>test</code></h3>

<p>撰寫測試程式的資料夾~</p>

<h3><code>app.js</code></h3>

<p>程式的進入點，可以想像成 index.php~</p>

<h3><code>package.json</code></h3>

<p>專案的資訊以及相關模組的資訊都會被放在這裡!</p>

<hr />

<p>其實關於專案結構有許多不同的討論，<code>express</code> 也有一個專案自動產生器，不過如果對結構內容不了解而使用產生器的話，很容易變成只知表面不知內部運作，因此我們還是一步一步來，先定義好我們專案的需求結構</p>

<p>另外，因為我們是建立 restful API service，在此並沒有用到 html 頁面，也因此就沒有 <code>view</code> 或 <code>public</code> 這兩個資料夾囉~</p>

<p>延伸閱讀:</p>

<p>我們可以透過觀摩別人的專案來參考他們的專案架構:</p>

<p><a href="http://scotch.io/tutorials/javascript/node-and-angular-to-do-app-application-organization-and-structure">Node and Angular To-Do App: Application Organization and Structure</a></p>

<p><a href="http://stackoverflow.com/questions/18789864/node-js-express-global-modules-best-practices-for-application-structure">node.js &amp; express - global modules &amp; best practices for application structure</a></p>

<p>在 Github 上的討論，非常值得一看: <a href="https://gist.github.com/lancejpollard/1398757">Github discussion</a></p>

<p>後來覺得也可以模仿 rails 的分法:</p>

<pre><code>/
| - app/
| - ----controllers/
| - ----models/
| - ----views/
| - ----helpers/
| - node_modules/
| - logs/
| - libs/
| - public/
| - config/
| - test/
| - server.js
| - package.json
</code></pre>

<p>都 OK!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d16] - 實戰開發 - 設定主題及規劃]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/16/api-d16/"/>
    <updated>2014-10-16T18:39:40+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/16/api-d16</id>
    <content type="html"><![CDATA[<p>接下來我們想要做到的是一個 TODO list 的 RESTful API</p>

<p>並且會先使用 <a href="http://apiary.io/">apiary.io</a> 做規劃</p>

<p>實際看看感覺如何</p>

<p>進入網站後，註冊登入後</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.04.07.png" alt="image" /></p>

<p>左上角的 dropdown list 選擇 create new API</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.04.18.png" alt="image" /></p>

<p>產生後下方就會跑出範例文擋</p>

<p>這個網站會透過特定格式的編排自己希望的 API endpoint 及範例回傳值後，產生出一份漂亮的文件</p>

<p>網站中間是模式的選擇</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.10.33.png" alt="image" /></p>

<p>Documentation 是實際讓其他人看的，Editor 則是編輯模式</p>

<p>我們就稍微簡單規劃一下 TODO List 的 RESTful API 吧!</p>

<p>這是我自己規劃的 <a href="http://docs.todolist7.apiary.io/">文件</a></p>

<p>基本上 route 會長這個樣子:</p>

<pre><code>TODOs
GET /user/{user_id}/todos/
POST /user/{user_id}/todos/
GET /user/{user_id}/todos/{id}
PUT /user/{user_id}/todos/{id}
DELETE /user/{user_id}/todos/{id}
</code></pre>

<p>資料格式也都在該文件整理好了</p>

<p><code>/user/{user_id}/</code> 只是用來辨識是哪個 user 的 todo task data</p>

<p>在這個小 API 不會琢磨在使用者系統的建立，只會專注在操作 todo task data</p>

<p>我們可以直接透過 PostMan 來丟丟看</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.43.06.png" alt="image" /></p>

<p>我們設定必須要使用 API-key 才能存取 API，比較進階的做法就是使用 Oauth 的方式取得 token 來存取 API</p>

<p>不過在這個小 API 也不會建立一個 Oauth Server，我們簡單使用 API-key 來認證即可</p>

<p>接下來的時間我們就會開始依據規劃好的文件，使用 Node.js + express + mongodb 來實作囉!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d15] - [Javascript 番外篇] Javascript Callback, Event]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/15/api-d15/"/>
    <updated>2014-10-15T18:34:37+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/15/api-d15</id>
    <content type="html"><![CDATA[<p>這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<p>javascript 有個特性：event</p>

<p>意思就是說，javascript 中，所有的事情都是由事件驅動的</p>

<p>如果說有寫過 web 前端的話，</p>

<p>其實呼叫 button.click function 時</p>

<p>並不會馬上執行 click 裡面的動作</p>

<p>而是加了一個 click 的 listener</p>

<p>等到 button 被 click 後，才會執行 click 裡面的程式碼</p>

<p>所以寫習慣一般 procedure 的程式會有點不太習慣</p>

<p>舉個 procedure 的例子，下面有五件事想要做：</p>

<pre><code class="javascript">煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>一般的程式會是照順序執行</p>

<p>也就是 煮飯完 -> 接電話 -> 吃麵 -> 丟垃圾</p>

<p>總執行時間 = 23 分鐘</p>

<p>但是如果把這段 code 丟給 javascript 執行的話</p>

<pre><code>煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>就變成同時做煮飯，接電話，吃麵，丟垃圾了！</p>

<p>為了要預防這件事，有些事情還是有順序性的，</p>

<p>因此就要使用到 javascript callback 的特性</p>

<pre><code>煮飯(function() {
    吃飯(function() {
        接電話(function() {
            丟垃圾();
        });
    });
});
</code></pre>

<p>意思就是煮飯完吃飯，吃完飯接電話，接完電話丟垃圾</p>

<p>以下有一個範例：</p>

<pre><code class="javascript">function wash() {
    setTimeout(function() {
        console.log("wash");
    }, 1000);
}

function eat() {
    setTimeout(function() {
        console.log("eat");
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork() {
    wash();
    eat();
    running();
}

doHouseWork();
</code></pre>

<p>做家事執行了三件事，wash, eat, 和 running</p>

<p>其中每件事都設定不同的完成時間</p>

<p>以 procedure 的程式執行方式來看，在這邊用 ruby 舉例:</p>

<pre><code class="ruby">def wash
  sleep 1
  puts "wash"
end 

def eat
  sleep 5
  puts "eat"
end 

def running 
  sleep 3
  puts "running"
end 

def doHouseWork 
  wash
  eat
  running
end 

doHouseWork
</code></pre>

<p>是會 wash 1 秒後，接著 eat 5 秒，再 running 3 秒</p>

<p>所以總共是 9 秒</p>

<p>output 的順序會是:</p>

<pre><code>wash // 1 秒
eat // 5 秒
running // 3 秒
</code></pre>

<p>但是在 javascript 中，output 的順序卻是:</p>

<pre><code>wash // 1 秒
running // 3 秒
eat // 5 秒
</code></pre>

<p>所以總長度是 5 秒</p>

<p>那今天假設想要讓 javascript 有順序性時該怎麼辦?</p>

<p>拿上面的例子作修改的話:</p>

<pre><code class="javascript">function wash(callback) {
    setTimeout(function() {
        console.log("wash");
        callback.call();
    }, 1000);
}

function eat(callback) {
    setTimeout(function() {
        console.log("eat");
        callback.call();
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork(callback) {
    console.log("doing house work");
    callback.call();
}

doHouseWork(function(){
    wash(function() {
        eat(function() {
            running();
        });
    });
});
</code></pre>

<p>很不錯的特性，但是也要特別對於這種特性作處理</p>

<p>有個 lib 很好用，<code>async.js</code> <a href="https://github.com/caolan/async">來源</a></p>

<p>下回待續!</p>
]]></content>
  </entry>
  
</feed>
