<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Api | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/api/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-16T18:44:48+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d16] - 實戰開發 - 設定主題及規劃]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/16/api-d16/"/>
    <updated>2014-10-16T18:39:40+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/16/api-d16</id>
    <content type="html"><![CDATA[<p>接下來我們想要做到的是一個 TODO list 的 RESTful API</p>

<p>並且會先使用 <a href="http://apiary.io/">apiary.io</a> 做規劃</p>

<p>實際看看感覺如何</p>

<p>進入網站後，註冊登入後</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.04.07.png" alt="image" /></p>

<p>左上角的 dropdown list 選擇 create new API</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.04.18.png" alt="image" /></p>

<p>產生後下方就會跑出範例文擋</p>

<p>這個網站會透過特定格式的編排自己希望的 API endpoint 及範例回傳值後，產生出一份漂亮的文件</p>

<p>網站中間是模式的選擇</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.10.33.png" alt="image" /></p>

<p>Documentation 是實際讓其他人看的，Editor 則是編輯模式</p>

<p>我們就稍微簡單規劃一下 TODO List 的 RESTful API 吧!</p>

<p>這是我自己規劃的 <a href="http://docs.todolist7.apiary.io/">文件</a></p>

<p>基本上 route 會長這個樣子:</p>

<pre><code>TODOs
GET /user/{user_id}/todos/
POST /user/{user_id}/todos/
GET /user/{user_id}/todos/{id}
PUT /user/{user_id}/todos/{id}
DELETE /user/{user_id}/todos/{id}
</code></pre>

<p>資料格式也都在該文件整理好了</p>

<p><code>/user/{user_id}/</code> 只是用來辨識是哪個 user 的 todo task data</p>

<p>在這個小 API 不會琢磨在使用者系統的建立，只會專注在操作 todo task data</p>

<p>我們可以直接透過 PostMan 來丟丟看</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-07%201.43.06.png" alt="image" /></p>

<p>我們設定必須要使用 API-key 才能存取 API，比較進階的做法就是使用 Oauth 的方式取得 token 來存取 API</p>

<p>不過在這個小 API 也不會建立一個 Oauth Server，我們簡單使用 API-key 來認證即可</p>

<p>接下來的時間我們就會開始依據規劃好的文件，使用 Node.js + express + mongodb 來實作囉!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d15] - [Javascript 番外篇] Javascript Callback, Event]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/15/api-d15/"/>
    <updated>2014-10-15T18:34:37+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/15/api-d15</id>
    <content type="html"><![CDATA[<p>這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<p>javascript 有個特性：event</p>

<p>意思就是說，javascript 中，所有的事情都是由事件驅動的</p>

<p>如果說有寫過 web 前端的話，</p>

<p>其實呼叫 button.click function 時</p>

<p>並不會馬上執行 click 裡面的動作</p>

<p>而是加了一個 click 的 listener</p>

<p>等到 button 被 click 後，才會執行 click 裡面的程式碼</p>

<p>所以寫習慣一般 procedure 的程式會有點不太習慣</p>

<p>舉個 procedure 的例子，下面有五件事想要做：</p>

<pre><code class="javascript">煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>一般的程式會是照順序執行</p>

<p>也就是 煮飯完 -> 接電話 -> 吃麵 -> 丟垃圾</p>

<p>總執行時間 = 23 分鐘</p>

<p>但是如果把這段 code 丟給 javascript 執行的話</p>

<pre><code>煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>就變成同時做煮飯，接電話，吃麵，丟垃圾了！</p>

<p>為了要預防這件事，有些事情還是有順序性的，</p>

<p>因此就要使用到 javascript callback 的特性</p>

<pre><code>煮飯(function() {
    吃飯(function() {
        接電話(function() {
            丟垃圾();
        });
    });
});
</code></pre>

<p>意思就是煮飯完吃飯，吃完飯接電話，接完電話丟垃圾</p>

<p>以下有一個範例：</p>

<pre><code class="javascript">function wash() {
    setTimeout(function() {
        console.log("wash");
    }, 1000);
}

function eat() {
    setTimeout(function() {
        console.log("eat");
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork() {
    wash();
    eat();
    running();
}

doHouseWork();
</code></pre>

<p>做家事執行了三件事，wash, eat, 和 running</p>

<p>其中每件事都設定不同的完成時間</p>

<p>以 procedure 的程式執行方式來看，在這邊用 ruby 舉例:</p>

<pre><code class="ruby">def wash
  sleep 1
  puts "wash"
end 

def eat
  sleep 5
  puts "eat"
end 

def running 
  sleep 3
  puts "running"
end 

def doHouseWork 
  wash
  eat
  running
end 

doHouseWork
</code></pre>

<p>是會 wash 1 秒後，接著 eat 5 秒，再 running 3 秒</p>

<p>所以總共是 9 秒</p>

<p>output 的順序會是:</p>

<pre><code>wash // 1 秒
eat // 5 秒
running // 3 秒
</code></pre>

<p>但是在 javascript 中，output 的順序卻是:</p>

<pre><code>wash // 1 秒
running // 3 秒
eat // 5 秒
</code></pre>

<p>所以總長度是 5 秒</p>

<p>那今天假設想要讓 javascript 有順序性時該怎麼辦?</p>

<p>拿上面的例子作修改的話:</p>

<pre><code class="javascript">function wash(callback) {
    setTimeout(function() {
        console.log("wash");
        callback.call();
    }, 1000);
}

function eat(callback) {
    setTimeout(function() {
        console.log("eat");
        callback.call();
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork(callback) {
    console.log("doing house work");
    callback.call();
}

doHouseWork(function(){
    wash(function() {
        eat(function() {
            running();
        });
    });
});
</code></pre>

<p>很不錯的特性，但是也要特別對於這種特性作處理</p>

<p>有個 lib 很好用，<code>async.js</code> <a href="https://github.com/caolan/async">來源</a></p>

<p>下回待續!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d14] - [Javascript 番外篇] Javascript Function Scopes 和 Closures]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/14/api-d14/"/>
    <updated>2014-10-14T22:40:32+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/14/api-d14</id>
    <content type="html"><![CDATA[<p>這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<h2>Scope</h2>

<p>例子:</p>

<pre><code class="javascript">function hi() {
    var greetings = "hi";

    console.log("Say: " + greetings);

    function sayYa(newInput) {
        greetings = newInput;
        console.log("Say: " + greetings);
    }

    function sayCool(newInput) {
        var cool = newInput;
        console.log("Say: " + cool);
    }

    sayYa("Yo");
    sayCool("Cool");

    console.log("Say: " + greetings);
}

hi();
</code></pre>

<p>很簡單的概念</p>

<p>greetins 在 sayYa 方法中被覆寫掉了</p>

<p>如果要定義 local 變數必須在 function 裏用 var 定義</p>

<p>例如 sayCool function</p>

<h2>Closure</h2>

<p>例子:</p>

<pre><code>function person(){
    var name = 'default';

    return {
        greetings: function() {
            console.log( name );
        },
        changeName: function(newInput) {
            name = newInput;
        }
    };
}

var me = new person();
me.greetings();
me.changeName("kerkerj");
me.greetings();
</code></pre>

<h2>Self-Executing Anonymous Functions</h2>

<p>使用這種方式通常是避免和其他 js 檔案造成變數混淆</p>

<p>或是初始化</p>

<p>裡面的變數和 function 只被限制在這個範圍內</p>

<p>例子:</p>

<pre><code>(function(){
    var hi = 'Hello';

    function sayHi(name){
        return hi + ' ' + name;
    }

    global.greetings = sayHi
})(global);

console.log(global.greetings("kerkerj"));
console.log(hi); // &lt;- 這會失敗
</code></pre>

<p>必須將 sayHi 指給 global 的某一個變數, 才有辦法使用它</p>

<p>在 node.js 中 global 是全域變數，在瀏覽器中是 window~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d13] - [Javascript 番外篇] Javascript Require/ Module/ Module Pattern]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/13/api-d13/"/>
    <updated>2014-10-13T18:24:17+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/13/api-d13</id>
    <content type="html"><![CDATA[<p>接下來幾天會探討 node.js 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<p>在 node.js 裏，要讀取外部模組都是透過 require 和 exports 來做溝通</p>

<p>以下列出這次最簡單 module 的例子</p>

<pre><code class="javascript">//hello.js
console.log('Hello World');
</code></pre>

<pre><code>// app.js
require('./hello.js');
</code></pre>

<h2>Module 也是有 Pattern 的</h2>

<p>第一種: Global (Not so good)</p>

<pre><code>// foo.js
foo = function() {
    console.log("foo!");
}

// app.js
require('./foo.js');
foo();
</code></pre>

<p>第二種: export an anonymous function</p>

<pre><code>// foo.js
module.exports = function() {
    console.log("foo! YA");
};

// app.js
var test = require("./foo.js");
test();
</code></pre>

<p>第三種： export a named function</p>

<pre><code>// bar.js
exports.bar = function() {
    console.log("bar");
}

// app.js
var bar = require('./bar.js').bar;
bar();
</code></pre>

<p>第四種: exports an anoymous object</p>

<pre><code>// bar4.js
var Bar4 = function() {};

Bar4.prototype.say = function() {
    console.log('bar4');
};

module.exports = new Bar4();

// app.js 
var b = require('./bar4.js');
b.say();
</code></pre>

<p>第五種: export a named object</p>

<pre><code>// bar5.js
var Bar5 = function() {};

Bar5.prototype.say = function() {
    console.log("bar5");
};

exports.Bar5 = new Bar5();

// app.js
var b = require('./bar5.js').Bar5;
b.say();
</code></pre>

<p>第六種: export an anonymous prototype</p>

<pre><code>// cool.js
var Cool = function() {};

Cool.prototype.say = function() {
    console.log('Cool!');
};

module.exports = Cool;

// app.js
var Cool = require('./cool.js');
var coo = new Cool();
coo.say();
</code></pre>

<p>第七種: export a named prototype</p>

<pre><code>// ang.js
var Ang = function () {};

Ang.prototype.say = function () {
    console.log('Ang!');
};

exports.Ang = Ang;

// app.js
var Ang = require('./ang.js').Ang;
var wer = new Ang();
wer.say();
</code></pre>

<h2>exports v.s. module.exports</h2>

<p>exports 是 module.exports 的輔助方法</p>

<p>以下有個例子會執行錯誤:</p>

<pre><code>// ya.js
module.exports = "YA";
exports.name = function() {
    console.log('My name is kerkerj');
};

// app.js
var ya = require('./ya.js');
ya.name(); TypeError: Cannot call method 'name' of undefined
</code></pre>

<p>在 ya.js 中 module.exports 有屬性了</p>

<p>因此下面的 export.name 就沒有被加入了</p>

<p>如果 module.exports 沒有任何屬性被加入的話，</p>

<p>exports 若有屬性了，則會交給 module.exports</p>

<p>反之就是剛剛的情況，moduel.exports 已經有屬性了，因此 export.name 就沒有作用了</p>

<p><a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html">延伸閱讀</a></p>

<h2>Module as class</h2>

<p>直接看例子吧 XD</p>

<pre><code>// user.js
module.exports = function(name, age) {
    this.name = name;
    this.age = age;
    this.about = function() {
        console.log(this.name +' is '+ this.age +' years old');
    };
};

// app.js
var User = require('./user.js');
var kerkerj = new User('kerkerj', 18);
kerkerj.about(); 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d12] - MongoDB - Hello World! (Client-side)]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/12/api-d12/"/>
    <updated>2014-10-12T18:50:16+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/12/api-d12</id>
    <content type="html"><![CDATA[<p>今天要使用 Node.js 的 mongodb driver 來操作 DB</p>

<p>一樣先開啟虛擬機並且登入吧</p>

<p>會使用到的套件是:</p>

<pre><code class="javascript">mongodb -&gt; mongodb native driver
</code></pre>

<p>或許有人有看過 <code>mongoose</code> -> <a href="http://mongoosejs.com/">官網</a></p>

<p>算是 MongoDB 的 ORM，我們在這邊如果有時間的話再簡單了解一下，</p>

<p>現在先使用 native driver 來操作</p>

<p>我們在這邊就不裝全域套件了，裝在 API 專案裡面</p>

<p>並且使用 <code>-save</code> 來將相依性寫入 <code>package.json 裏</code></p>

<pre><code>$ cd /vagrant/API/
$ npm install mongodb -save
</code></pre>

<p>從虛擬機回到電腦的資料夾中，在虛擬機資料夾的 API 資料夾中，</p>

<p>今天我們先不和 express 搭配，因此就是純操作 node.js + mongodb module</p>

<p>新增一個 <code>mongoTest.js</code></p>

<p>我們先來連線到 MongoDB，連線的方式有很多，下面是其中一種方式，</p>

<pre><code>// 先宣告用的到的東西
var MongoClient = require('mongodb').MongoClient
    , Server = require('mongodb').Server
    , options = { auto_reconnection: true, poolSize: 10 };

// Server 設定
var mongoClient = new MongoClient(new Server('localhost', 27017, options));

// 開啟連線
mongoClient.open(function(err, mongoClient) {
    var db1 = mongoClient.db("testDB");

    if (!err) {
        console.log("Connected!");
    }

    mongoClient.close();
    console.log("Closed!");
});
</code></pre>

<p>回到虛擬機執行</p>

<pre><code>$ node mongoTest.js
Connected!
Closed!
</code></pre>

<p>接著用另外一種連接方式，介紹 CRUD 的操作:</p>

<pre><code>var mongoClient = require('mongodb').MongoClient;

mongoClient.connect('mongodb://localhost:27017/testDB', function(err, db) {
    if(err) throw err;

    // Data
    var todo1 = {todo: "Buy books", time: "2014/10/11", who: "myself"};
    var todo2 = {todo: "Buy milk", time: "2014/10/15", who: "brother"};
    var todo3 = {todo: "Wash cats", time: "2014/11/21", who: "myself"};

    var collection = db.collection('todoTest');
    var where = {todo: "Buy milk"};

    // 新增資料
    collection.insert(todo1, function(err, docs) {
        console.log(docs);
    });

    collection.insert(todo2, function(err, docs) {
        console.log(docs);
    });

    collection.insert(todo3, function(err, docs) {
        console.log(docs);
    });

    // 更新資料
    collection.update(where, { $set: { time: "2014/12/25"} }, function(err) {
        console.log(err);
    });

    // 刪除某筆資料
    collection.remove(where, function(err) {
        console.log(err);
    });

    // 查詢某筆資料
    collection.find(where).toArray(function(err, results) {
        console.dir(results);
    });

    // 查詢所有資料
    collection.find().toArray(function(err, results) {
        console.dir(results);
    });
});
</code></pre>

<p>請注意，以上操作由於 javascript async 特性的關係，</p>

<p>每個操作是會同時間送出，不同時間回送，看操作的運算時間而定</p>

<p>因此若要依順序性的話，一是使用 callback，二是使用 async.js</p>

<p>後面應該會提到 XD</p>

<p>將這些程式碼存到 js file 裏，將某些行先註解掉，執行看看就可以略知一二了，</p>

<p>可以同時搭配終端機直接到 DB 查看</p>

<p>p.s. 大家可能會覺得這樣的方式很麻煩，MongoDB 有沒有好用的 client 來管理 DB 呢</p>

<p>我推薦 RoboMongo，多平台，且可以直接輸入指令，蠻方便的，</p>

<p>那如果是用我們現在的虛擬機的方式，要如何使用 RoboMongo ？</p>

<p>首先，虛擬機的 DB 必須先開啟外部網路可以連線，</p>

<p>注意! 我們目前並沒有創立使用者帳號密碼，不需要驗證即可進入 DB，這樣的做法只限於 demo, 與虛擬機中使用</p>

<p>正式環境還是必須建立使用者帳號密碼</p>

<p>先進到虛擬機更改 db 設定:</p>

<pre><code>$ sudo nano /etc/mongod.conf
</code></pre>

<p>將 bind_ip = 0.0.0.0</p>

<p>按下 ctrl+x 選擇 Y 存檔</p>

<p>重開 mongodb</p>

<pre><code>$ sudo service mongod restart
</code></pre>

<p>若已經下載過 RoboMongo，開啟並輸入欲連線的 DB 設定：</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-06%2013.56.39.png" alt="" /></p>

<p>就可以連進去管理了!</p>

<p>再次提醒，這樣的做法只限於虛擬機及 demo 中測試</p>

<p>正式環境要嘛建立使用者帳號密碼</p>

<p>要嘛就是讓 DB 只限本機存取，請記住這件事情哦~</p>
]]></content>
  </entry>
  
</feed>
