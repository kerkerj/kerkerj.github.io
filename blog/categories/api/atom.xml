<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Api | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/api/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-12T18:56:09+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d12] - MongoDB - Hello World! (Client-side)]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/12/api-d12/"/>
    <updated>2014-10-12T18:50:16+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/12/api-d12</id>
    <content type="html"><![CDATA[<p>今天要使用 Node.js 的 mongodb driver 來操作 DB</p>

<p>一樣先開啟虛擬機並且登入吧</p>

<p>會使用到的套件是:</p>

<pre><code class="javascript">mongodb -&gt; mongodb native driver
</code></pre>

<p>或許有人有看過 <code>mongoose</code> -> <a href="http://mongoosejs.com/">官網</a></p>

<p>算是 MongoDB 的 ORM，我們在這邊如果有時間的話再簡單了解一下，</p>

<p>現在先使用 native driver 來操作</p>

<p>我們在這邊就不裝全域套件了，裝在 API 專案裡面</p>

<p>並且使用 <code>-save</code> 來將相依性寫入 <code>package.json 裏</code></p>

<pre><code>$ cd /vagrant/API/
$ npm install mongodb -save
</code></pre>

<p>從虛擬機回到電腦的資料夾中，在虛擬機資料夾的 API 資料夾中，</p>

<p>今天我們先不和 express 搭配，因此就是純操作 node.js + mongodb module</p>

<p>新增一個 <code>mongoTest.js</code></p>

<p>我們先來連線到 MongoDB，連線的方式有很多，下面是其中一種方式，</p>

<pre><code>// 先宣告用的到的東西
var MongoClient = require('mongodb').MongoClient
    , Server = require('mongodb').Server
    , options = { auto_reconnection: true, poolSize: 10 };

// Server 設定
var mongoClient = new MongoClient(new Server('localhost', 27017, options));

// 開啟連線
mongoClient.open(function(err, mongoClient) {
    var db1 = mongoClient.db("testDB");

    if (!err) {
        console.log("Connected!");
    }

    mongoClient.close();
    console.log("Closed!");
});
</code></pre>

<p>回到虛擬機執行</p>

<pre><code>$ node mongoTest.js
Connected!
Closed!
</code></pre>

<p>接著用另外一種連接方式，介紹 CRUD 的操作:</p>

<pre><code>var mongoClient = require('mongodb').MongoClient;

mongoClient.connect('mongodb://localhost:27017/testDB', function(err, db) {
    if(err) throw err;

    // Data
    var todo1 = {todo: "Buy books", time: "2014/10/11", who: "myself"};
    var todo2 = {todo: "Buy milk", time: "2014/10/15", who: "brother"};
    var todo3 = {todo: "Wash cats", time: "2014/11/21", who: "myself"};

    var collection = db.collection('todoTest');
    var where = {todo: "Buy milk"};

    // 新增資料
    collection.insert(todo1, function(err, docs) {
        console.log(docs);
    });

    collection.insert(todo2, function(err, docs) {
        console.log(docs);
    });

    collection.insert(todo3, function(err, docs) {
        console.log(docs);
    });

    // 更新資料
    collection.update(where, { $set: { time: "2014/12/25"} }, function(err) {
        console.log(err);
    });

    // 刪除某筆資料
    collection.remove(where, function(err) {
        console.log(err);
    });

    // 查詢某筆資料
    collection.find(where).toArray(function(err, results) {
        console.dir(results);
    });

    // 查詢所有資料
    collection.find().toArray(function(err, results) {
        console.dir(results);
    });
});
</code></pre>

<p>請注意，以上操作由於 javascript async 特性的關係，</p>

<p>每個操作是會同時間送出，不同時間回送，看操作的運算時間而定</p>

<p>因此若要依順序性的話，一是使用 callback，二是使用 async.js</p>

<p>後面應該會提到 XD</p>

<p>將這些程式碼存到 js file 裏，將某些行先註解掉，執行看看就可以略知一二了，</p>

<p>可以同時搭配終端機直接到 DB 查看</p>

<p>p.s. 大家可能會覺得這樣的方式很麻煩，MongoDB 有沒有好用的 client 來管理 DB 呢</p>

<p>我推薦 RoboMongo，多平台，且可以直接輸入指令，蠻方便的，</p>

<p>那如果是用我們現在的虛擬機的方式，要如何使用 RoboMongo ？</p>

<p>首先，虛擬機的 DB 必須先開啟外部網路可以連線，</p>

<p>注意! 我們目前並沒有創立使用者帳號密碼，不需要驗證即可進入 DB，這樣的做法只限於 demo, 與虛擬機中使用</p>

<p>正式環境還是必須建立使用者帳號密碼</p>

<p>先進到虛擬機更改 db 設定:</p>

<pre><code>$ sudo nano /etc/mongod.conf
</code></pre>

<p>將 bind_ip = 0.0.0.0</p>

<p>按下 ctrl+x 選擇 Y 存檔</p>

<p>重開 mongodb</p>

<pre><code>$ sudo service mongod restart
</code></pre>

<p>若已經下載過 RoboMongo，開啟並輸入欲連線的 DB 設定：</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-06%2013.56.39.png" alt="" /></p>

<p>就可以連進去管理了!</p>

<p>再次提醒，這樣的做法只限於虛擬機及 demo 中測試</p>

<p>正式環境要嘛建立使用者帳號密碼</p>

<p>要嘛就是讓 DB 只限本機存取，請記住這件事情哦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d11] - MongoDB - Hello World!]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/11/api-d11/"/>
    <updated>2014-10-11T20:09:08+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/11/api-d11</id>
    <content type="html"><![CDATA[<p>今天先講在 Server 中如何操作 MongoDB</p>

<p>一樣開啟虛擬機，</p>

<p>我們在先前已經有先安裝過 MongoDB 了，因此，在 Ubuntu Server 中預設是開機啟動的</p>

<p>登入虛擬機吧~</p>

<p>登入虛擬機後，我們要進入 MongoDB，必須使用 <code>mongo</code> 這個 MongoDB Shell</p>

<pre><code>$ mongo
MongoDB shell version: 2.6.4
connecting to: test
Welcome to the MongoDB shell.
For interactive help, type "help".
For more comprehensive documentation, see
    http://docs.mongodb.org/
Questions? Try the support group
    http://groups.google.com/group/mongodb-user
&gt;  
</code></pre>

<p>此時會發現輸入指令的地方變成了 <code>&gt;</code> 表示我們已經在 mongodb 裡面了</p>

<p>為什麼不需要帳號密碼即可進入 MongoDB 呢，因為 MongoDB 預設是不需要做登入的</p>

<p>並且加上預設只能由本機存取，也就是說，外部連入的 IP 是進不了 MongoDB 的</p>

<p>這部分後面會再作說明。</p>

<p>傳統的 Table 在 MongoDB 中，稱之為 Collection</p>

<p>一筆 record 在 MongoDB 中，稱之為 document</p>

<p>進入 MongoDB 後，</p>

<p>就可以簡單操作一些指令：</p>

<p>查詢所有的 DB:</p>

<pre><code>&gt; show databases;
admin  (empty)
local  0.078GB
</code></pre>

<p>切換 DB</p>

<pre><code>&gt; use test;
</code></pre>

<p><code>use DBNAME</code> 若 DBNAME 不存在於 MongoDB 中的話，</p>

<p>等同於建立一個新的 DB，意思就是我們不需要下 &lsquo;建立 DB&rsquo; 這個指令，</p>

<p>直接 <code>use</code> 就是一個新的 DB 了，不過這個 DB 會直到有 Collection 被新增才算真正的被建立</p>

<p>意即如果我們 use 了一個新的 DB，但是並沒有做任何新增 Collection 的動作就離開，</p>

<p>這個 DB 也不會被建立起來</p>

<p>當我們使用 <code>use DBNAME</code> 進入 DB 後：</p>

<h3>新增 Collection</h3>

<pre><code>&gt; db.createCollection("TestCollection")
{ "ok" : 1 }
</code></pre>

<h3>CRUD 操作</h3>

<p>此時 Collection &ldquo;TestCollection&rdquo; 就被建立了，
可以使用:</p>

<h4>新增資料:</h4>

<p>example: <code>db.TestCollection.insert(DATA);</code></p>

<p>DATA 就是 javascript 的 array map</p>

<pre><code>&gt; db.TestCollection.insert({data: "test_data", num: 2, arr: ["arr1", "arr2", "arr3"]});
</code></pre>

<h4>查詢資料</h4>

<p>example: <code>db.TestCollection.find(WHERE_CONDITION);</code></p>

<pre><code>&gt; db.TestCollection.find({data: "test_data"});
{ "_id" : ObjectId("5430497db94bb4afe2f8b387"), "data" : "test_data", "num" : 2, "arr" : [ "arr1", "arr2", "arr3" ] }
</code></pre>

<p>p.s. 每插入一筆資料，MongoDB 預設都會給訂一組 ObjectId</p>

<h4>查詢所有資料</h4>

<pre><code>&gt; db.TestCollection.find();
{ "_id" : ObjectId("5430497db94bb4afe2f8b387"), "data" : "test_data", "num" : 2, "arr" : [ "arr1", "arr2", "arr3" ] }
</code></pre>

<h4>修改資料</h4>

<p>example: <code>db.TestCollection.update(WHERE_CONDITION, SET);</code></p>

<pre><code>&gt; db.TestCollection.update({data: "test_data"}, { $set: {num: 3} });
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

// 查看 num 是否從 2 變 3 了
&gt; db.TestCollection.find({data: "test_data"});
{ "_id" : ObjectId("5430497db94bb4afe2f8b387"), "data" : "test_data", "num" : 3, "arr" : [ "arr1", "arr2", "arr3" ] }
</code></pre>

<h4>刪除資料</h4>

<p>exmaple: <code>db.TestCollection.remove(WHERE_CONDITION);</code></p>

<pre><code>&gt; db.TestCollection.remove({data: "test_data"});
</code></pre>

<h3>刪除 Collection</h3>

<pre><code>&gt; db.TestCollection.drop();
</code></pre>

<h3>查詢有哪些 Collection</h3>

<pre><code>&gt; show collections;
</code></pre>

<h3>砍掉目前所在的整個 DB:</h3>

<pre><code>&gt; use test;
&gt; db.dropDatabase();
{ "dropped" : "test", "ok" : 1 }
</code></pre>

<p>tips: 在 mongo shell 裡有自動補完的功能，可以按下 tab 來查看有什麼方法可以用</p>

<p>ctrl-D 離開 Mongo Shell</p>

<p><a href="http://docs.mongodb.org/manual/">MongoDB 官網文件</a>非常詳細，可以多看看</p>

<p>明天會用 Node.js 的 MongoDB driver 來操作 MongoDB!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d10] - Express - Hello World!]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/10/api-d10/"/>
    <updated>2014-10-10T01:49:55+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/10/api-d10</id>
    <content type="html"><![CDATA[<h1>Express - Hello World!</h1>

<p>今天就要來安裝主角之一的 <a href="http://expressjs.com/">Express</a> 了!</p>

<p>一樣開啟虛擬機器我應該是可以不用多說了 XD</p>

<p>先確認自己的 node 是不是 NVM 的 node 喲</p>

<h2>建立專案</h2>

<pre><code>$ cd /vagrant/
$ mkdir API
$ cd API/
$ npm init
</code></pre>

<p>自己輸入專案的相關內容吧，不知道的就直接按 enter 空白丟給他~</p>

<p>就會產生 package.json 了!</p>

<h2>安裝 Express</h2>

<pre><code>// 在專案目錄底下 (/vagrant/API/)

$ npm install express -save
</code></pre>

<p>下 <code>-save</code> 的原因是要將 express 加入 package.json 中</p>

<p>離開虛擬機，其實我們也可以在虛擬機資料夾看到剛剛建立的專案了，</p>

<p>現在開始就可以使用自己喜歡的編輯器來開啟這個專案資料夾，我個人偏好使用 Sublime Text</p>

<p>要執行專案時再回終端機即可</p>

<h2>Express Hello World!</h2>

<p>在 API 資料夾中建立一個 app.js</p>

<p>內容是:</p>

<pre><code>javascript
var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('Hello World');
});

app.listen(3000, function() {
    console.log('Listening on port %d', server.address().port);
});
</code></pre>

<p>儲存後，回到終端機，將 express 跑起來:</p>

<pre><code>vagrant@vagrant-ubuntu-trusty-64:/vagrant/API$ node app.js
Listening on port 3000
</code></pre>

<p>開啟瀏覽器，瀏覽 <code>http://192.168.33.10:3000</code> (url 視個人環境而定)</p>

<p>出現 <code>Hello World! Express!</code> 啦～～ 又一個 Hello World 啦~~</p>

<p>是不是有比 Node.js 的範例更簡潔一點呢?</p>

<p>簡單分析一下這段 code :</p>

<pre><code>// 引入 express module
var express = require('express');

// 產生一個 express instance - app
var app = express();

// Express 的重點所在! 稍後解釋
app.get('/', function(req, res){
  res.send('Hello World');
});

// 讓 express server 跑在 port 3000
app.listen(3000, function() {
    console.log('Listening on port %d', server.address().port);
});
</code></pre>

<p>以上概念基本上都和 Node.js 概念差不多</p>

<p>值得一提的是 Express 的 Routing:</p>

<pre><code>app.get('/', function(req, res){
  res.send('Hello World');
});
</code></pre>

<p>最前面有提到 HTTP 的動詞 GET, POST, PUT, DELETE &hellip;</p>

<p>在這邊就必須用上了！</p>

<p>我們可以看一下 express 的 <a href="http://expressjs.com/4x/api.html#router.VERB">API reference</a></p>

<p><code>app.get</code> 的 <code>.get</code> 就是代表 HTTP GET</p>

<p>如果後面接 <code>.post</code> 就是 HTTP POST, 等等都同樣概念</p>

<p><a href="http://expressjs.com/4x/api.html#router.VERB">API reference</a> 中提到，</p>

<pre><code>router.VERB(path, [callback...], callback)
</code></pre>

<p><code>path</code> 的意思就是要開放給 client 的路由, 透過不同的路由導向不同的動作</p>

<p>中間的 <code>[callback...]</code> 是 middleware 這個之後會再解釋</p>

<p>最後一個 callback 是用來處理 request 及 response</p>

<p>在這個例子中，client 並沒有丟參數，因此不需要對 request 作處理，</p>

<p>而 server 要回應 response</p>

<p>所以使用了 <code>res.send('Hello World');</code> 來回傳資料</p>

<p>是不是很簡單勒!</p>

<h2>專案產生器</h2>

<p>或許有人會使用 <code>express-generator</code> 來產生 expresss 專案目錄</p>

<p>雖然它很方便，一次建立好專案結構，並且安裝一些常用搭配的套件，</p>

<p>但是由於在尚未了解 express 的運作原理，</p>

<p>一開始一次建立完整我認為過快，因此先不建議這樣用，</p>

<p>當然，如果已經很熟練很了解 express 中可以使用的東西了，使用產生器當然是節省時間囉~</p>

<pre><code>$ npm install -g express-generator
$ express /tmp/foo &amp;&amp; cd /tmp/foo
</code></pre>

<p>下一篇會講解如何簡單操作 MongoDB!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d9] - NVM 與 NPM 使用]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/09/api-d9/"/>
    <updated>2014-10-09T21:46:12+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/09/api-d9</id>
    <content type="html"><![CDATA[<h1>NVM 與 NPM 使用</h1>

<h2>NVM - Node.js Version Manager</h2>

<h3>安裝</h3>

<p>如果是 Ubuntu 的話必須先要有 <code>build-essential</code> 和 <code>libssl-dev</code> 套件</p>

<p>不過這個我們之前就裝過了，所以直接安裝 NVM 吧~</p>

<pre><code>$ curl https://raw.githubusercontent.com/creationix/nvm/v0.17.2/install.sh | bash
$ source ~/.bashrc
</code></pre>

<h3>使用 NVM 安裝 node.js</h3>

<p>先前我們有使用 Ubuntu 本身的 apt-get 安裝 Node.js</p>

<p>不過那是被安裝到 /usr/bin/node</p>

<p>有時候要安裝套件需要 sudo 提供管理者權限</p>

<p>非常麻煩，因此我們使用 NVM 來安裝另一個 Node.js</p>

<p>這個 Node.js 的執行檔就任我們使用，不需要提供管理者權限了</p>

<pre><code>$ nvm install 0.10
</code></pre>

<p>nvm 就會安裝 0.10 版本，安裝完後就要使用它：</p>

<pre><code>$ nvm use 0.10
</code></pre>

<p>再來我們把 nvm 的 node.js 設定成預設的 node</p>

<p>否則重開機後，node 指令會變回原本系統的 node</p>

<pre><code>$ nvm alias default 0.10
</code></pre>

<p>我們觀察一下現在使用的 node 指令是哪裡來的:</p>

<pre><code>$ which node
/home/vagrant/.nvm/v0.10.32/bin/node
</code></pre>

<p>Good! 他已經被安裝到我們使用者目錄底下了</p>

<p>原本的系統 Node.js 是在 <code>/usr/bin/node</code></p>

<p>如果要切換回系統的 Node.js:</p>

<pre><code>$ nvm use system
Now using system version of node: v0.10.32.

// 看一下現在使用 node 的路徑
$ which node
/usr/bin/node
</code></pre>

<h2>NPM - Node.js Package Manager</h2>

<p>NPM 顧名思義就是 node.js 的套件管理系統，</p>

<p>世界上有許許多多的開發者為 Node.js 開發了許許多多的套件，</p>

<p>我們受惠于此，也不用再自己造輪子，拿這些佛心的大大的套件來使用，打造出我們想要的服務，</p>

<p>像我們接下來會使用的 Express 和 Mongodb 的 driver 都是別人寫好開放出來給大家用的！</p>

<p>下面簡單介紹 NPM 的使用方式</p>

<h3>初始化專案資料夾</h3>

<pre><code>$ npm init 
</code></pre>

<p>終端機會詢問各種問題來幫忙建立 package.json 的檔案</p>

<p>是在資料夾中建立專案前必下的指令</p>

<p>並且，使用 package.json 有個好處</p>

<p>只要將 package.json 給其他人</p>

<p>其他人只需要將 package.json 放到某個資料夾</p>

<p>並下:</p>

<pre><code>$ npm install
</code></pre>

<p>就會在該資料夾安裝 package.json 中列出的所有套件</p>

<p>就不需要一個一個尋找及安裝，非常方便！</p>

<h3>安裝套件</h3>

<pre><code>// 安裝全域套件
$ npm install [套件名稱] -g

// 安裝套件在專案資料夾 
// 會安裝在目前所在的資料夾，所以要下此指令必須先確認自己是否在專案根目錄
$ npm install [套件名稱]

// 通常專案資料夾底下都會有一個 package.json 來管理套件相依性
// 如果在專案資料夾底下下此指令，會將你所安裝的套件加入 package.json 中
// 一樣也是要先確認自己是否在專案目錄底下
$ npm install [套件名稱] -save
</code></pre>

<h3>移除套件</h3>

<pre><code>// 移除全域套件
$ npm uninstall [套件名稱] -g

// 移除在專案資料夾的某個套件 
// 會移除在目前所在的資料夾某個套件，所以要下此指令必須先確認自己是否在專案根目錄
$ npm uninstall [套件名稱]

// 通常專案資料夾底下都會有一個 package.json 來管理套件相依性
// 如果在專案資料夾底下下此指令，會將你所移除的套件從 package.json 中刪除
// 一樣也是要先確認自己是否在專案目錄底下
$ npm uninstall [套件名稱] -save
</code></pre>

<h3>列出套件</h3>

<pre><code>// 列出全域套件
$ npm ls -g

// 列出全域套件詳細資訊
$ npm ls -gl

// 在專案資料夾底下：

// 列出專案資料夾的套件
$ npm ls 

// 列出專案資料夾的詳細套件資訊
$ npm ls -l
</code></pre>

<h3>更新套件</h3>

<pre><code>// 更新全域套件
$ npm update -g

// 在專案資料夾底下：

// 更新專案套件
$ npm update 
</code></pre>

<h3>搜尋套件</h3>

<pre><code>$ npm search [套件名稱]
</code></pre>

<h2>注意!!</h2>

<p>請注意，使用系統 Node.js 的 npm 所安裝的套件，是屬於系統 Node.js 的</p>

<p>切換到使用者目錄底下的 Node.js 時，是不會共用系統 npm 的套件的</p>

<p>請注意這一點，接下來我們都會使用 nvm 的 node.js</p>

<p>我們可以透過以下例子來驗證:</p>

<pre><code>// 使用系統 node.js
$ nvm use system
Now using system version of node: v0.10.32.

// 查看 npm 全域套件
$ npm list -g  
/usr/lib
├─┬ express@4.9.5
│ ├─┬ accepts@1.1.1
│ │ ├─┬ mime-types@2.0.2
│ │ │ └── mime-db@1.1.0
│ │ └── negotiator@0.4.8
....

// 使用 nvm node.js
$ nvm use 0.10
Now using node v0.10.32

// 查看 npm 全域套件
$ npm list -g 
/home/vagrant/.nvm/v0.10.32/lib
└─┬ npm@1.4.28
  ├── abbrev@1.0.5
  ├── ansi@0.3.0
  ├── ansicolors@0.3.2
  ├── ansistyles@0.1.3
  ├── archy@0.0.2
  ├── block-stream@0.0.7
  ├── char-spinner@1.0.1
  ├── child-process-close@0.1.1
  ├── chmodr@0.1.0
...
</code></pre>

<p>主要差別就在於 列出全域套件時，還會提醒你這些套件裝在哪裡，如果不是裝在使用者目錄底下，</p>

<p>表示現在用的是系統的 Node.js</p>

<p>因此發現自己不對了就快換回來吧，如果系統裝爛了，也可以利用先前打包的 box 還原哦!</p>

<h2>怎麼找套件?</h2>

<p>套件那麼多，我要到哪裡找？</p>

<p>除了根據自己的需求 Google 外，</p>

<p>下面是 Node.js module 的官方網站: <a href="https://nodejsmodules.org/">https://nodejsmodules.org/</a></p>

<p>有做最受歡迎的套件排名，進去瀏覽一下，有時候會發現一些好用的套件哦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d8] - Node.js - Hello World!]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/08/api-d8/"/>
    <updated>2014-10-08T13:04:20+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/08/api-d8</id>
    <content type="html"><![CDATA[<h1>Node.js - Hello World!</h1>

<p>一樣先開虛擬機哦~</p>

<p>並且開啟終端機連進 server 裡面~</p>

<p>以下是 <a href="http://nodejs.org/">Node.js</a> 官方網站的 web server 程式範例，我稍作小修改：</p>

<pre><code class="javascript">var http = require('http');

http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(1337, '0.0.0.0');

console.log('Server running at http://0.0.0.0:1337/');
</code></pre>

<p>我們先在虛擬機的資料夾建立一個子資料夾 &lsquo;HelloWorld&rsquo;</p>

<p>在 HelloWorld 資料夾裡面建立一個 app.js</p>

<p>內容如上，存檔。</p>

<p>使用終端機進入 server :</p>

<pre><code>$ vagrant ssh
$ cd /vagrant/HelloWorld
$ node server.js
</code></pre>

<p>到瀏覽器輸入 <a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a></p>

<p>(或者是你的 Vagrantfile 裡面設定的 private IP)</p>

<p>即可看到 Hello World 了！</p>

<p>要關掉 Server 也非常簡單，回到下指令的地方，按下 ctrl + c 即可中斷程式</p>

<h2>分析</h2>

<p>簡單分析一下此段程式：</p>

<pre><code class="javascript">var http = require('http');
</code></pre>

<p>將 http 這個模組引入，並指定給物件 http</p>

<pre><code class="javascript">http.createServer(
    ...
).listen(1337, '0.0.0.0');
</code></pre>

<p>先略過中間的 function 不看，<br/>
這段 code 的用意即是讓呼叫 http 物件中的 createServer 的方法，
.listen() 則是設定該 server 要跑在哪個 port、hostname</p>

<pre><code class="javascript">function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}
</code></pre>

<p>上面的 code 則是原本在 .createServer() 裡的，
我們可以看一下 Node.js 的 API doc <a href="http://nodejs.org/api/http.html#http_http_createserver_requestlistener">關於此方法的部分</a></p>

<p>.createServer() 要帶入的東西其實是一個 requestListener，<br/>
也就是當 Server 跑起來時，我們開啟瀏覽器，輸入 127.0.0.1:1337 時，<br/>
Node.js Server 要回丟的東西，因此觀察一下此 listener:</p>

<pre><code class="javascript">function (req, res) {
    ...
}
</code></pre>

<p>function 中帶入參數的是 req, res，意即 request, response，<br/>
request 即是 server 接收到 client 端的訊息，<br/>
response 則是 server 要回丟給 client 的訊息，<br/>
由於在此範例中，我們只是要回丟給 client 端一個 hello world 的訊息，
因此，我們不處理 client 送給 server 的 request，
我們只需處理要回丟給 client 的訊息，</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World\n');
</code></pre>

<p>寫網頁的開發者應該對一些關鍵字例如 Content-type, text/plain 不陌生，<br/>
第一行代表回傳給使用者的訊息中，HTTP HEAD 的設定是 http status code 200,
並且 Content-type 設定為 text/plain</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
</code></pre>

<p>那麼，以下這行 code 的意思即是，此次要回送給使用者的訊息到這裡結束，以 &ldquo;Hello World&rdquo; 作結尾</p>

<pre><code class="javascript">res.end('Hello World\n');
</code></pre>

<p>因此整段 code 看下來，就是一個非常簡單的 http server，</p>

<p><a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a> 總是會回傳 Hello World</p>

<p>今天就完成了我們的 Hello World 了!</p>
]]></content>
  </entry>
  
</feed>
