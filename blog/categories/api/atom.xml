<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Api | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/api/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-05T16:47:43+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d5] - [Server 番外篇] 建立自己的本機虛擬伺服器 1 - Vagrant + VirtualBox 安裝]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/05/api-d5/"/>
    <updated>2014-10-05T16:40:18+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/05/api-d5</id>
    <content type="html"><![CDATA[<p>VirtualBox 是一套虛擬軟體，可以方便幫助我們在現有的作業系統上</p>

<p>模擬另一個作業系統 (如 linux, Ubuntu, CentOS&hellip;)</p>

<p>在虛擬機器裡面所以的一切變動，都不會影響到現有的作業系統，</p>

<p>非常適合拿來做測試使用</p>

<p>由於現在大部份的 Service 除了架設在 Windows Server 外，最大宗的就是 *nix distribution 了</p>

<p>因此這在這個系列文中，也是一定要教大家如何建立起虛擬測試機器，</p>

<p>來模擬真實 Server 環境中，如何架設自己撰寫的 API Service</p>

<h2>VirtualBox</h2>

<p>到 <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> 官方網站下載合適的安裝檔案吧!</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-04%2012.56.26.png" alt="p1" /></p>

<p>安裝完成就可以了!</p>

<p>因為我們接下來會使用 Vagrant 這套 commaond line tool 來對 VirtualBox 進行操作</p>

<p>因此只要安裝完 VirtualBox 後就可以不用管他了 XD</p>

<h2>Vagrant</h2>

<p><a href="https://www.vagrantup.com/">Vagrant</a></p>

<p>它可以幫助我們快速的建立一個輕量、可重複使用、並且可以打包起來帶著走的環境</p>

<p>透過編輯一個設定檔，就可以簡單設定該虛擬系統的 *nix 基本設定，如 共享資料夾、網路存取等等，</p>

<p>不需要透過 VirtualBox</p>

<p>通常這套軟體可以應用在團隊開發上：</p>

<p>以網頁開發來說，如果大家的測試環境與版本都不太一樣，例如 apache 或 php 版本不同</p>

<p>有時候會造成團隊溝通的負擔，因此透過 Vagrant 將 server 環境重新建立一套虛擬機器，</p>

<p>並且透過 Vagrant 打包，就可以丟給其他人使用，這樣一來大家的環境都一樣，</p>

<p>就可以避免這個問題，</p>

<p>而且還有一點，Server 的安裝是很累人的，同樣的事情基本上都不會想做第二遍，</p>

<p>因此打包一個乾淨的環境後備份，弄髒了可以隨時快速再把備份拿出來用，非常方便！</p>

<h3>安裝:</h3>

<p>到 <a href="https://www.vagrantup.com/downloads">下載頁面</a> 尋找適合自己的下載並且安裝</p>

<p>安裝完後應該就可以在終端機中使用 vagrant 這個指令了!</p>

<pre><code>$ vagrant -v
Vagrant 1.6.5
</code></pre>

<p>目前最新的版本應該是 1.6.5</p>

<h3>建立自己的虛擬機器</h3>

<p>首先在自己想要建立虛擬機器的地方先開一個資料夾</p>

<pre><code>$ mkdir ~/ithome/ 
</code></pre>

<p>切換到該資料夾</p>

<pre><code>$ cd ~/ithome
</code></pre>

<p>使用 vagrant 初始化這個資料夾，並且指定我們要使用 Ubuntu 14.04 版本</p>

<pre><code>$ vagrant init ubuntu/trusty64
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.
</code></pre>

<p>如果想要使用別種 *nix 版本可以到這裡找 - <a href="https://vagrantcloud.com/discover/featured">VagrantCloud</a></p>

<p>下完 <code>vagrant init ubuntu/trusty64</code> 指令後，指令告訴你有一個檔案叫做 <code>Vagrantfile</code> 被建立在這個資料夾裡了，</p>

<p>可以使用 <code>vagrant up</code> 來開啟虛擬機器</p>

<p>不過我們先不要下開機指令，我們先來看看 <code>Vagrantfile</code> 的內容，我直接把比較重要的設定說明寫在註解裡面了：</p>

<pre><code>  ...

  // 此行是說明要使用哪一個 box ，會到自己的系統裡面尋找，如果沒有的話就會下載一個
  // 由於我們剛剛是使用 VagrantCloud 找的版本，因此 vagrant 會去找 
  config.vm.box = "ubuntu/trusty64"

  // 這個是設定網路
  // 預設是 NAT，也就是如果我們在虛擬機器裝了網頁伺服器，
  // 必須使用 port forwarding 的方式來讀到虛擬機器裡面的網頁 
  #config.vm.network "forwarded_port", guest: 80, host: 8080

  // Important! 
  // 承上，或者我們可以使用一個 private network ip，我們把它開啟註解吧~
  // 這樣我們開啟虛擬機器時，他的 IP 就會是 192.168.33.10
  config.vm.network "private_network", ip: "192.168.33.10"

  // 開啟註解的話，就是直接使用 bridge 的方式，如果是使用分享器的話
  // 虛擬機會到分享器要一個 IP 
  # config.vm.network "public_network"

  // 這個是設定共享資料夾
  // 預設是放 Vagrantfile 的那個資料夾
  // 在這個資料夾放檔案的話，在虛擬機器裡的 '/vagrant/' 資料夾是可以看到的!!
  // 如果有想要指定到特殊的資料夾，再編輯此行並開啟註解即可
  # config.vm.synced_folder "../data", "/vagrant_data"

end
</code></pre>

<p>再來就讓它開機吧!</p>

<pre><code>$ vagrant up 
</code></pre>

<p>如果沒有下載過 ubuntu 系統的話，會先幫你下載，所以需要等待一些時間</p>

<p>若看到終端機說系統已經建立完成，</p>

<p>就可以連線進去了!</p>

<pre><code>$ vagrant ssh
.....
vagrant@vagrant-ubuntu-trusty-64:~$ 
</code></pre>

<p>就會發現終端機的 prompt 已經不一樣了，變成 ubuntu-trusty-64 ，表示我們已經進入虛擬機器裡面了</p>

<p>由於今天的內容只會先到這，關於 Ubuntu 的設定是明天，所以記得離開虛擬機器並且幫他關機 XDD</p>

<pre><code>// 如果剛剛有進入虛擬機器的話，輸入 exit 離開
$ exit
</code></pre>

<p>再下關機指令:</p>

<pre><code>$ vagrant halt 
</code></pre>

<p>虛擬機器就被關起來了!</p>

<p>順帶一提</p>

<p>如果在虛擬機器開機時，需要更改 Vagrantfile 的設定，</p>

<p>改完後虛擬機器必須要重新開啟才會讀到新的設定</p>

<pre><code>$ vagrant reload
</code></pre>

<p>下回待續!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d4] - 使用技術與工具介紹及原因]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/04/api-d4/"/>
    <updated>2014-10-04T18:52:58+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/04/api-d4</id>
    <content type="html"><![CDATA[<h1>使用技術與工具介紹及原因</h1>

<p>終於要開始進入正題了！</p>

<p>在了解 REST/RESTful 後，</p>

<p>就要從無到有 - 從 Server 到 API endpoint 都由自己打造</p>

<p>今天會先來說明接下來會使用到哪些工具及技術</p>

<p>由於筆者使用 Mac ，因此若是有其他平台的使用者可能需要自行找教學</p>

<h2>Server - Ubuntu with Vagrant + VitrualBox</h2>

<p>接下來幾天會先從這個部分開始提起</p>

<p>我們會使用 VirtualBox + Vagrant 的方式來建立自己的虛擬環境</p>

<p>避免一些讀者可能對 Server command line 不熟</p>

<p>這個部分是大家可以跳過的部分，但是我還是會從無到有架起來</p>

<h2>Backend Language - Node.js</h2>

<p>後端語言使用了 Node.js，其實本來有考慮使用 Golang，</p>

<p>但顧及自己的時間&hellip; 還是使用 Node.js，方便快速</p>

<p>這幾年是 Javascript 的時代，</p>

<p>優勝美地似乎也可以支援使用 Javascript 撰寫 <a href="https://github.com/tylergaw/js-osx-app-examples">Automation Tool</a></p>

<p>從前端打到後端甚至到 DB 都可以使用到 Javascript ，</p>

<p>是該來看看 Javascript 的語法特性了 :D</p>

<p>而且 Node.js Event-driven 的特性，可以利用少少的資源提供高效能的服務</p>

<p>同時搭配易用性及社群活躍度，這是我選擇 Node.js 而非選擇 Golang 的原因</p>

<h2>Framework - Express</h2>

<p>我使用了 Node.js 的 web framework - Express</p>

<p>Node.js 之於 Express 可以把它想像成是 Ruby 之於 Sinatra</p>

<p>我使用 Express 方便處理 Route</p>

<p>並且這套 framework 算是 Node.js 裡最具代表性的 framework</p>

<p>學起來也還不錯</p>

<h2>Database - MongoDB</h2>

<p>DB 為了追求簡單快速，我使用了 MongoDB</p>

<p>從 API 到 DB 無縫接軌，簡單的操作模式以及 Schema-free 的特性</p>

<p>應該會讓這整件事情變得更簡單</p>

<h2>Test client - PostMan (chrome extension)</h2>

<p>由於 API 是純粹後端 service，我們使用 Express 並不會使用到樣板語言，</p>

<p>也就是我們並不會撰寫 View (HTML, CSS 等等的語法)</p>

<p>因此除了寫測試外，我們就可以使用這套 Chrome Extension 來對 API 做存取!</p>

<hr />

<p>結束! 接下來幾天會教大家建立自己的虛擬機哦~~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d3] - 使用時機與實際 API 參考]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/03/api-d3/"/>
    <updated>2014-10-03T21:07:32+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/03/api-d3</id>
    <content type="html"><![CDATA[<h1>使用時機與實際 API 參考</h1>

<p>什麼時候需要打造 RESTful API?<br/>
看看別人的 RESTful API (Instagram/Twitter)</p>

<p>什麼時候需要打造 RESTful API?<br/>
我認為當有數組資源要被多種不同平台使用時，就需要打造 RESTful API<br/>
例如，有 Android/ iOS / Web 要對同一 table 做存取時，<br/>
假設有個 MySQL DB，各個平台都使用各自的 mysql-driver 來直接操作 DB<br/>
假設有個 A 專案建立了一套書籍管理系統，資料庫裡記錄了大大小小的書籍，<br/>
而有個新的 B 專案需要使用到書籍的資料，此時 DB 操作的程式碼只能再寫一遍，<br/>
且各個平台重新撰寫，似乎是不大靠譜。</p>

<p>撰寫 RESTful API 的好處之一即是 RESTful 使用 HTTP 協定，<br/>
各個平台皆支援，不需要太複雜的程式，只需要使用各個平台的 http-client，<br/>
各個平台也不需要了解 DB 操作語法，只需要知道 json, xml 習慣的資料格式，  <br/>
且開發 API 還能夠對各個資源輕易地上 cache 增進反應速度，<br/>
開發 RESTful API 好處多多，哪天想 Open API 也就不需要再多作處理了～</p>

<p>接著讓我們來看看兩個有名網站的 API 吧！</p>

<p>Instagram: <a href="http://instagram.com/developer/api-console/">http://instagram.com/developer/api-console/</a><br/>
Twitter: <a href="https://dev.twitter.com/rest/tools/console">https://dev.twitter.com/rest/tools/console</a></p>

<p>很顯然的，我比較喜歡 Instagram 的 API 資源定義與命名方式 :P</p>

<p>下一篇會介紹我接下來會用到的工具箱，暖身結束，要正式開始了!<br/>
(不好意思前面嘴炮一點 XD)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d2] - 定義 2 - RESTful 的優點與要求]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/02/api-d2/"/>
    <updated>2014-10-02T20:17:24+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/02/api-d2</id>
    <content type="html"><![CDATA[<p>承上篇，</p>

<p>RESTful 的優點如下所列:</p>

<pre><code> 1. 瀏覽器即可以作為 client 端
 2. 可以更高效地利用 cache 來達到更快的回應速度
 3. 界面與資料分離
 4. 節省伺服器的計算資源
 5. 可重用! web/android/ios 都可以用, 無痛轉換!
</code></pre>

<p>RESTful 的要求:</p>

<pre><code> 1. client - server 架構  
 2. 分層系統  
 3. 利用快取機制增加效能  
      server-side: 在 GET 資源時，若該資源並沒有被變更，就可以利用 cache 機制減少 query，並且加快回應速度  
      client-side: 透過 client 端 cache 記錄 cache 版本，  
           若向 server 要求資源時發現 server 最新版與 cache 相同，  
           則 client 端直接取用本地資源即可，不需要再做一次查詢  
      省機器運算及流量 = 省錢  
 4. 通訊協定具有無狀態性  
      不能讓兩隻 API 做同一個動作!  
           假設完成轉賬手續必須先 call A 再 call B 的話，  
           若做完 A 後斷線導致 B 無法執行，後續要處理 A -&gt; B 的方式會很麻煩  
      且不應該假設伺服器知道目前的狀態!  
      因此設計出來的 API 不能有狀態性  
 5. 統一界面  
      使用 HTTP Verb: GET/POST/PUT/DELETE  
</code></pre>

<p>下一篇會討論什麼時候該打造 RESTful API?  以及看看別人寫的 RESTful API</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d1] - 定義 1 - 什麼是 REST/RESTful?]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/02/api-d1/"/>
    <updated>2014-10-02T01:02:26+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/02/api-d1</id>
    <content type="html"><![CDATA[<p>Representational State Transfer，簡稱 <code>REST</code>，<br/>
它是一種網路架構風格，他並不是一種標準。</p>

<p>而 RESTful 可以這樣子想像:<br/>
美麗 (Beauty) 的事物可以稱為 Beautiful<br/>
設計為 REST 的系統就可以稱為 RESTful</p>

<p>以 API 而言，假設我們正在撰寫一組待辦事項的 API，<br/>
可能會有以下方式來作為 API 的 interface:<br/>
<code>
獲取使用者資料     /getAllUsers
獲取使用者資料     /getUser/1
新增使用者資料     /createUser
更新使用者資料     /updateUser/1
刪除使用者資料     /deleteUser/1
</code></p>

<p>若是以 REST 風格來開發 RESTful API 的話:
<code>
獲取使用者資料     /GET            /users
獲取使用者資料     /GET            /user/1
新增使用者資料     /POST          /user
更新使用者資料     /PUT             /user/1
刪除使用者資料     /DELETE      /user/1
</code></p>

<p>兩者差異是在於 RESTful API 充分地使用了 HTTP protocol (GET/POST/PUT/DELETE)，<br/>
達到<br/>
1. 以直觀簡潔的資源 URI<br/>
2. 並且善用 HTTP Verb<br/>
3. 達到對資源的操作<br/>
4. 並使用 Web 所接受的資料類型: JSON, XML, YAML 等，最常見的是 JSON</p>

<p>通常是使用 HTTP, URI, JSON, HTML 這些現有廣泛流行的協議和標準，<br/>
且使用 HTTP status code 來代表該資源的狀態。</p>

<p>框架中強制使用 REST 風格的最有名的應該就是 Ruby on Rails 了!<br/>
(不過我們並不會使用 Rails 來開發 API service :P)</p>

<p>p.s. 因為 REST 並非是一種標準，因此有時候也不一定非得要照著 REST 來做，<br/>
只是在資源的操作面上，可以設計成這類的風格，以達到簡潔易懂，並且可重用。</p>

<p>下一篇會來聊聊 REST 的要求與優點</p>
]]></content>
  </entry>
  
</feed>
