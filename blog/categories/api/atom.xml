<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Api | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/api/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-08T13:15:34+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d8] - Node.js - Hello World!]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/08/api-d8/"/>
    <updated>2014-10-08T13:04:20+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/08/api-d8</id>
    <content type="html"><![CDATA[<h1>Node.js - Hello World!</h1>

<p>一樣先開虛擬機哦~</p>

<p>並且開啟終端機連進 server 裡面~</p>

<p>以下是 <a href="http://nodejs.org/">Node.js</a> 官方網站的 web server 程式範例，我稍作小修改：</p>

<pre><code class="javascript">var http = require('http');

http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(1337, '0.0.0.0');

console.log('Server running at http://0.0.0.0:1337/');
</code></pre>

<p>我們先在虛擬機的資料夾建立一個子資料夾 &lsquo;HelloWorld&rsquo;</p>

<p>在 HelloWorld 資料夾裡面建立一個 app.js</p>

<p>內容如上，存檔。</p>

<p>使用終端機進入 server :</p>

<pre><code>$ vagrant ssh
$ cd /vagrant/HelloWorld
$ node server.js
</code></pre>

<p>到瀏覽器輸入 <a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a></p>

<p>(或者是你的 Vagrantfile 裡面設定的 private IP)</p>

<p>即可看到 Hello World 了！</p>

<p>要關掉 Server 也非常簡單，回到下指令的地方，按下 ctrl + c 即可中斷程式</p>

<h2>分析</h2>

<p>簡單分析一下此段程式：</p>

<pre><code class="javascript">var http = require('http');
</code></pre>

<p>將 http 這個模組引入，並指定給物件 http</p>

<pre><code class="javascript">http.createServer(
    ...
).listen(1337, '0.0.0.0');
</code></pre>

<p>先略過中間的 function 不看，<br/>
這段 code 的用意即是讓呼叫 http 物件中的 createServer 的方法，
.listen() 則是設定該 server 要跑在哪個 port、hostname</p>

<pre><code class="javascript">function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}
</code></pre>

<p>上面的 code 則是原本在 .createServer() 裡的，
我們可以看一下 Node.js 的 API doc <a href="http://nodejs.org/api/http.html#http_http_createserver_requestlistener">關於此方法的部分</a></p>

<p>.createServer() 要帶入的東西其實是一個 requestListener，<br/>
也就是當 Server 跑起來時，我們開啟瀏覽器，輸入 127.0.0.1:1337 時，<br/>
Node.js Server 要回丟的東西，因此觀察一下此 listener:</p>

<pre><code class="javascript">function (req, res) {
    ...
}
</code></pre>

<p>function 中帶入參數的是 req, res，意即 request, response，<br/>
request 即是 server 接收到 client 端的訊息，<br/>
response 則是 server 要回丟給 client 的訊息，<br/>
由於在此範例中，我們只是要回丟給 client 端一個 hello world 的訊息，
因此，我們不處理 client 送給 server 的 request，
我們只需處理要回丟給 client 的訊息，</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World\n');
</code></pre>

<p>寫網頁的開發者應該對一些關鍵字例如 Content-type, text/plain 不陌生，<br/>
第一行代表回傳給使用者的訊息中，HTTP HEAD 的設定是 http status code 200,
並且 Content-type 設定為 text/plain</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
</code></pre>

<p>那麼，以下這行 code 的意思即是，此次要回送給使用者的訊息到這裡結束，以 &ldquo;Hello World&rdquo; 作結尾</p>

<pre><code class="javascript">res.end('Hello World\n');
</code></pre>

<p>因此整段 code 看下來，就是一個非常簡單的 http server，</p>

<p><a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a> 總是會回傳 Hello World</p>

<p>今天就完成了我們的 Hello World 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d7] - [Server 番外篇] 建立自己的本機虛擬伺服器 3 - 打包環境]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/07/api-d7/"/>
    <updated>2014-10-07T19:12:40+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/07/api-d7</id>
    <content type="html"><![CDATA[<p>昨天我們已經把一個全新乾淨的環境架起來了</p>

<p>這時候我們不希望因為日後的操作導致 Server 環境髒掉，又要重灌</p>

<p>因此我們今天就來練習一下如何使用 vagrant 打包環境!</p>

<h2>Vagrant 打包</h2>

<p>一樣先進入虛擬機資料夾，先確保虛擬機沒有在運作:</p>

<pre><code>$ vagrant status
Current machine states:

default                   poweroff (virtualbox)

The VM is powered off. To restart the VM, simply run `vagrant up`
</code></pre>

<p>如果是 poweroff 的話，就可以進行接下來的動作，如果是其他狀態的話，就先下關機指令囉</p>

<pre><code>$ vagrant package
==&gt; default: Clearing any previously set forwarded ports...
==&gt; default: Exporting VM...
==&gt; default: Compressing package to: /Users/.../ithome/package.box
</code></pre>

<p>vagrant 就會在虛擬機器資料夾底下建立一個 package.box</p>

<p>這個檔案就是整個伺服器環境的檔案了!</p>

<p>假設今天想要讓團隊成員使用，只要他們都有 VirtualBox + Vagrant 的話，</p>

<p>就可以依循下面的指令步驟將你所做的 box 匯入並使用：</p>

<p>首先我們可以先看看原本所使用的 box 清單:</p>

<pre><code>$ vagrant box list
ubuntu/trusty64                          (virtualbox, 14.04)
</code></pre>

<p>是 <code>ubuntu/trusty64</code> 沒錯！</p>

<p>那麼我們現在想要加入剛剛所製作的 box ，並重新命名：</p>

<pre><code>$ vagrant box add my_box package.box
==&gt; box: Adding box 'my_box' (v0) for provider:
    box: Downloading: file:///Users/.../ithome/package.box
==&gt; box: Successfully added box 'my_box' (v0) for 'virtualbox'!
</code></pre>

<p>此時再看看 box 清單:</p>

<pre><code>$ vagrant box list
ubuntu/trusty64                          (virtualbox, 14.04)
my_box                                   (virtualbox, 0)
</code></pre>

<p>就會多一個了!</p>

<p><code>vagrant box add my_box package.box</code></p>

<p>這個指令的意思是將 <code>package.box</code> 加入 box 清單，並以 my_box 命名</p>

<p><code>package.box</code> 可以是本機路徑，也可以是網址，</p>

<p>如果要分享給團隊成員使用，就可以使用 url 分享，其他人就可以下指令來下載 box 並加入 box list</p>

<p>例如:</p>

<pre><code>$ vagrant box add my_box http://my_dropbox.com/package.box
</code></pre>

<p>接著其他人就可以建立自己的虛擬機資料夾，並且到該資料夾中下指令就可以初始化虛擬機器了，例如：</p>

<pre><code>$ mkdir ~/my_machine/
$ cd ~/my_machine/
$ vagrant init my_box 
</code></pre>

<p>超方便的啦～</p>

<p>如果想要從 box list 中刪除不需要的 box，下此指令即可：</p>

<pre><code>$ vagrant box remove my_box
Are you sure you want to remove this box? [y/N] y
</code></pre>

<p>上面只會刪除 box 清單，</p>

<p>如果要刪除虛擬機器資料夾，以及虛擬機器的所有檔案的話，先到虛擬機器資料夾，然後下此指令：</p>

<pre><code>$ vagrant destroy
    default: Are you sure you want to destroy the 'default' VM? [y/N] y
</code></pre>

<p>虛擬機就會被移除，再來只要將該資料夾砍掉即可～ 就恢復成乾乾淨淨的了~</p>

<p>是不是很方便勒~~</p>

<p>接下來我們就會開始先寫寫 Node.js 的 Hello World 囉~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d6] - [Server 番外篇] 建立自己的本機虛擬伺服器 2 - Ubuntu 基本設定與安裝 Node.js, MongoDB]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/06/api-d6/"/>
    <updated>2014-10-06T18:54:07+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/06/api-d6</id>
    <content type="html"><![CDATA[<h1>[Server 番外篇] 建立自己的本機虛擬伺服器 2 - Ubuntu 基本設定與安裝 Node.js, MongoDB</h1>

<p>嗨又到了 Server 時間了!</p>

<p>接下來我們都會做一些指令操作，</p>

<p>如果進一步有興趣的可以 Google 鳥哥的私房菜，</p>

<p>完整的 Linux 操作教學，淺顯易懂，想學習操作 linux OS 的話必看！</p>

<p>今天我們要稍稍整理一下昨天剛安裝完的 Ubuntu 作業系統，以及安裝一些我們需要用到的東西</p>

<p>首先我們的第一步就是先開啟終端機，到昨天放 Vagrantfile 的資料夾:</p>

<pre><code>$ cd ~/ithome/
</code></pre>

<p>開啟 Ubuntu</p>

<pre><code>$ vagrant up
</code></pre>

<p>順帶一提，有時候開機時可能會卡在一個地方：</p>

<pre><code>default: Warning: Connection timeout. Retrying...
default: Warning: Connection timeout. Retrying...
default: Warning: Connection timeout. Retrying...
</code></pre>

<p>這個就稍微等一下吧~ 如果電腦性能比較差的話可能會卡比較久，不過應該不至於會卡超過 10 分鐘</p>

<p>如果卡超過十分鐘可能要強制中斷，並且尋找解決辦法了～</p>

<p>開機完成後就登入吧!</p>

<pre><code>$ vagrant ssh
...
vagrant@vagrant-ubuntu-trusty-64:~$
</code></pre>

<h2>Ubuntu 套件, 設定時區</h2>

<p>今天就要來幫 Ubuntu 安裝一些東西，</p>

<p>首先先產生 locale file for zh_TW</p>

<pre><code>$ sudo locale-gen zh_TW.UTF-8
</code></pre>

<p>更新檔案清單並安裝更新, 移除更新後不需要的套件:</p>

<pre><code>$ sudo apt-get update &amp;&amp; sudo apt-get -y upgrade
$ sudo apt-get -y autoremove
</code></pre>

<p>再來是安裝一些常用的套件 如 git, curl, vim 等等:</p>

<pre><code>$ sudo apt-get -y install build-essential vim git-core curl autoconf libssl-dev
</code></pre>

<p>設定時區, 照著指令選就好了~</p>

<pre><code>$ sudo dpkg-reconfigure tzdata
...

// 選擇完畢後, 輸入 date 指令來查詢伺服器時間
$ date
Sat Oct  6 20:47:03 CST 2014
</code></pre>

<h2>Node.js 安裝</h2>

<p>我們使用了 ppa 以安裝最新的 Node.js 版本:</p>

<pre><code>// 加入 ppa
$ sudo add-apt-repository ppa:chris-lea/node.js
 Evented I/O for V8 javascript. Node's goal is to provide an easy way to build scalable network programs
 More info: https://launchpad.net/~chris-lea/+archive/ubuntu/node.js
Press [ENTER] to continue or ctrl-c to cancel adding it
(要再按一下 enter)

// 因為加入新的檔案清單來源了，所以重新更新 ubuntu 的檔案清單
$ sudo apt-get update

// 安裝 nodejs
$ sudo apt-get -y install nodejs
</code></pre>

<p>這樣就完成安裝了!</p>

<p>確認一下版本是否安裝成功:</p>

<pre><code>$ node -v 
v0.10.32 

$ npm -v 
1.4.28
</code></pre>

<p>ya! 這樣 Ubuntu 就有 node.js 了!</p>

<h2>MongoDB</h2>

<p>再來就是要安裝 MongoDB 了!</p>

<p>我們參考 MongoDB <a href="http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/">官方網站的文件</a></p>

<pre><code>//加入 apt-key
$ sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10


// 新增一個來源清單，並將 mongodb 的來源寫進該來源清單
$ echo 'deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen' | sudo tee /etc/apt/sources.list.d/mongodb.list

// 重新更新來源清單
$ sudo apt-get update

// 安裝 mongodb
$ sudo apt-get install -y mongodb-org
</code></pre>

<p>安裝完成後 Mongo db 就會跑起來了，從以下指令可以得知</p>

<pre><code>$ ps aux | grep mongo
</code></pre>

<p>順便確認一下版本:</p>

<pre><code>$ mongod --version
db version v2.6.4
2014-10-04T06:31:01.553+0000 git version: 3a830be0eb92d772aa855ebb711ac91d658ee910

$ mongo --verion
MongoDB shell version: 2.6.4
</code></pre>

<p>MongoDB 除了安裝了 DB 本身，還提供了指令提供操作，稱之為 MongoDB Shell，</p>

<p>方便我們使用 Shell 進去 DB 裡面做 DB 操作</p>

<p>以下是 mongodb service 的指令:</p>

<pre><code>// 開啟 mongodb
$ sudo service mongod start

// 關閉 mongodb
$ sudo service mongod stop

// 重啟 mongodb
$ sudo service mongod restart
</code></pre>

<p>好啦~ 今天就先到這，記得把虛擬機器關起來~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d5] - [Server 番外篇] 建立自己的本機虛擬伺服器 1 - Vagrant + VirtualBox 安裝]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/05/api-d5/"/>
    <updated>2014-10-05T16:40:18+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/05/api-d5</id>
    <content type="html"><![CDATA[<p>VirtualBox 是一套虛擬軟體，可以方便幫助我們在現有的作業系統上</p>

<p>模擬另一個作業系統 (如 linux, Ubuntu, CentOS&hellip;)</p>

<p>在虛擬機器裡面所以的一切變動，都不會影響到現有的作業系統，</p>

<p>非常適合拿來做測試使用</p>

<p>由於現在大部份的 Service 除了架設在 Windows Server 外，最大宗的就是 *nix distribution 了</p>

<p>因此這在這個系列文中，也是一定要教大家如何建立起虛擬測試機器，</p>

<p>來模擬真實 Server 環境中，如何架設自己撰寫的 API Service</p>

<h2>VirtualBox</h2>

<p>到 <a href="https://www.virtualbox.org/wiki/Downloads">VirtualBox</a> 官方網站下載合適的安裝檔案吧!</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-04%2012.56.26.png" alt="p1" /></p>

<p>安裝完成就可以了!</p>

<p>因為我們接下來會使用 Vagrant 這套 commaond line tool 來對 VirtualBox 進行操作</p>

<p>因此只要安裝完 VirtualBox 後就可以不用管他了 XD</p>

<h2>Vagrant</h2>

<p><a href="https://www.vagrantup.com/">Vagrant</a></p>

<p>它可以幫助我們快速的建立一個輕量、可重複使用、並且可以打包起來帶著走的環境</p>

<p>透過編輯一個設定檔，就可以簡單設定該虛擬系統的 *nix 基本設定，如 共享資料夾、網路存取等等，</p>

<p>不需要透過 VirtualBox</p>

<p>通常這套軟體可以應用在團隊開發上：</p>

<p>以網頁開發來說，如果大家的測試環境與版本都不太一樣，例如 apache 或 php 版本不同</p>

<p>有時候會造成團隊溝通的負擔，因此透過 Vagrant 將 server 環境重新建立一套虛擬機器，</p>

<p>並且透過 Vagrant 打包，就可以丟給其他人使用，這樣一來大家的環境都一樣，</p>

<p>就可以避免這個問題，</p>

<p>而且還有一點，Server 的安裝是很累人的，同樣的事情基本上都不會想做第二遍，</p>

<p>因此打包一個乾淨的環境後備份，弄髒了可以隨時快速再把備份拿出來用，非常方便！</p>

<h3>安裝:</h3>

<p>到 <a href="https://www.vagrantup.com/downloads">下載頁面</a> 尋找適合自己的下載並且安裝</p>

<p>安裝完後應該就可以在終端機中使用 vagrant 這個指令了!</p>

<pre><code>$ vagrant -v
Vagrant 1.6.5
</code></pre>

<p>目前最新的版本應該是 1.6.5</p>

<h3>建立自己的虛擬機器</h3>

<p>首先在自己想要建立虛擬機器的地方先開一個資料夾</p>

<pre><code>$ mkdir ~/ithome/ 
</code></pre>

<p>切換到該資料夾</p>

<pre><code>$ cd ~/ithome
</code></pre>

<p>使用 vagrant 初始化這個資料夾，並且指定我們要使用 Ubuntu 14.04 版本</p>

<pre><code>$ vagrant init ubuntu/trusty64
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.
</code></pre>

<p>如果想要使用別種 *nix 版本可以到這裡找 - <a href="https://vagrantcloud.com/discover/featured">VagrantCloud</a></p>

<p>下完 <code>vagrant init ubuntu/trusty64</code> 指令後，指令告訴你有一個檔案叫做 <code>Vagrantfile</code> 被建立在這個資料夾裡了，</p>

<p>可以使用 <code>vagrant up</code> 來開啟虛擬機器</p>

<p>不過我們先不要下開機指令，我們先來看看 <code>Vagrantfile</code> 的內容，我直接把比較重要的設定說明寫在註解裡面了：</p>

<pre><code>  ...

  // 此行是說明要使用哪一個 box ，會到自己的系統裡面尋找，如果沒有的話就會下載一個
  // 由於我們剛剛是使用 VagrantCloud 找的版本，因此 vagrant 會去找 
  config.vm.box = "ubuntu/trusty64"

  // 這個是設定網路
  // 預設是 NAT，也就是如果我們在虛擬機器裝了網頁伺服器，
  // 必須使用 port forwarding 的方式來讀到虛擬機器裡面的網頁 
  #config.vm.network "forwarded_port", guest: 80, host: 8080

  // Important! 
  // 承上，或者我們可以使用一個 private network ip，我們把它開啟註解吧~
  // 這樣我們開啟虛擬機器時，他的 IP 就會是 192.168.33.10
  config.vm.network "private_network", ip: "192.168.33.10"

  // 開啟註解的話，就是直接使用 bridge 的方式，如果是使用分享器的話
  // 虛擬機會到分享器要一個 IP 
  # config.vm.network "public_network"

  // 這個是設定共享資料夾
  // 預設是放 Vagrantfile 的那個資料夾
  // 在這個資料夾放檔案的話，在虛擬機器裡的 '/vagrant/' 資料夾是可以看到的!!
  // 如果有想要指定到特殊的資料夾，再編輯此行並開啟註解即可
  # config.vm.synced_folder "../data", "/vagrant_data"

end
</code></pre>

<p>再來就讓它開機吧!</p>

<pre><code>$ vagrant up 
</code></pre>

<p>如果沒有下載過 ubuntu 系統的話，會先幫你下載，所以需要等待一些時間</p>

<p>若看到終端機說系統已經建立完成，</p>

<p>就可以連線進去了!</p>

<pre><code>$ vagrant ssh
.....
vagrant@vagrant-ubuntu-trusty-64:~$ 
</code></pre>

<p>就會發現終端機的 prompt 已經不一樣了，變成 ubuntu-trusty-64 ，表示我們已經進入虛擬機器裡面了</p>

<p>由於今天的內容只會先到這，關於 Ubuntu 的設定是明天，所以記得離開虛擬機器並且幫他關機 XDD</p>

<pre><code>// 如果剛剛有進入虛擬機器的話，輸入 exit 離開
$ exit
</code></pre>

<p>再下關機指令:</p>

<pre><code>$ vagrant halt 
</code></pre>

<p>虛擬機器就被關起來了!</p>

<p>順帶一提</p>

<p>如果在虛擬機器開機時，需要更改 Vagrantfile 的設定，</p>

<p>改完後虛擬機器必須要重新開啟才會讀到新的設定</p>

<pre><code>$ vagrant reload
</code></pre>

<p>下回待續!!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d4] - 使用技術與工具介紹及原因]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/04/api-d4/"/>
    <updated>2014-10-04T18:52:58+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/04/api-d4</id>
    <content type="html"><![CDATA[<h1>使用技術與工具介紹及原因</h1>

<p>終於要開始進入正題了！</p>

<p>在了解 REST/RESTful 後，</p>

<p>就要從無到有 - 從 Server 到 API endpoint 都由自己打造</p>

<p>今天會先來說明接下來會使用到哪些工具及技術</p>

<p>由於筆者使用 Mac ，因此若是有其他平台的使用者可能需要自行找教學</p>

<h2>Server - Ubuntu with Vagrant + VitrualBox</h2>

<p>接下來幾天會先從這個部分開始提起</p>

<p>我們會使用 VirtualBox + Vagrant 的方式來建立自己的虛擬環境</p>

<p>避免一些讀者可能對 Server command line 不熟</p>

<p>這個部分是大家可以跳過的部分，但是我還是會從無到有架起來</p>

<h2>Backend Language - Node.js</h2>

<p>後端語言使用了 Node.js，其實本來有考慮使用 Golang，</p>

<p>但顧及自己的時間&hellip; 還是使用 Node.js，方便快速</p>

<p>這幾年是 Javascript 的時代，</p>

<p>優勝美地似乎也可以支援使用 Javascript 撰寫 <a href="https://github.com/tylergaw/js-osx-app-examples">Automation Tool</a></p>

<p>從前端打到後端甚至到 DB 都可以使用到 Javascript ，</p>

<p>是該來看看 Javascript 的語法特性了 :D</p>

<p>而且 Node.js Event-driven 的特性，可以利用少少的資源提供高效能的服務</p>

<p>同時搭配易用性及社群活躍度，這是我選擇 Node.js 而非選擇 Golang 的原因</p>

<h2>Framework - Express</h2>

<p>我使用了 Node.js 的 web framework - Express</p>

<p>Node.js 之於 Express 可以把它想像成是 Ruby 之於 Sinatra</p>

<p>我使用 Express 方便處理 Route</p>

<p>並且這套 framework 算是 Node.js 裡最具代表性的 framework</p>

<p>學起來也還不錯</p>

<h2>Database - MongoDB</h2>

<p>DB 為了追求簡單快速，我使用了 MongoDB</p>

<p>從 API 到 DB 無縫接軌，簡單的操作模式以及 Schema-free 的特性</p>

<p>應該會讓這整件事情變得更簡單</p>

<h2>Test client - PostMan (chrome extension)</h2>

<p>由於 API 是純粹後端 service，我們使用 Express 並不會使用到樣板語言，</p>

<p>也就是我們並不會撰寫 View (HTML, CSS 等等的語法)</p>

<p>因此除了寫測試外，我們就可以使用這套 Chrome Extension 來對 API 做存取!</p>

<hr />

<p>結束! 接下來幾天會教大家建立自己的虛擬機哦~~</p>
]]></content>
  </entry>
  
</feed>
