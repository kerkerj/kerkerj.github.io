<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-25T22:03:32+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d15] - [Javascript 番外篇] Javascript Callback, Event]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/15/api-d15/"/>
    <updated>2014-10-15T18:34:37+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/15/api-d15</id>
    <content type="html"><![CDATA[<p>這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<p>javascript 有個特性：event</p>

<p>意思就是說，javascript 中，所有的事情都是由事件驅動的</p>

<p>如果說有寫過 web 前端的話，</p>

<p>其實呼叫 button.click function 時</p>

<p>並不會馬上執行 click 裡面的動作</p>

<p>而是加了一個 click 的 listener</p>

<p>等到 button 被 click 後，才會執行 click 裡面的程式碼</p>

<p>所以寫習慣一般 procedure 的程式會有點不太習慣</p>

<p>舉個 procedure 的例子，下面有五件事想要做：</p>

<pre><code class="javascript">煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>一般的程式會是照順序執行</p>

<p>也就是 煮飯完 -> 接電話 -> 吃麵 -> 丟垃圾</p>

<p>總執行時間 = 23 分鐘</p>

<p>但是如果把這段 code 丟給 javascript 執行的話</p>

<pre><code>煮飯(); // 10 分鐘

接電話(); // 1 分鐘

吃麵(); // 5 分鐘

丟垃圾(); // 7 分鐘
</code></pre>

<p>就變成同時做煮飯，接電話，吃麵，丟垃圾了！</p>

<p>為了要預防這件事，有些事情還是有順序性的，</p>

<p>因此就要使用到 javascript callback 的特性</p>

<pre><code>煮飯(function() {
    吃飯(function() {
        接電話(function() {
            丟垃圾();
        });
    });
});
</code></pre>

<p>意思就是煮飯完吃飯，吃完飯接電話，接完電話丟垃圾</p>

<p>以下有一個範例：</p>

<pre><code class="javascript">function wash() {
    setTimeout(function() {
        console.log("wash");
    }, 1000);
}

function eat() {
    setTimeout(function() {
        console.log("eat");
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork() {
    wash();
    eat();
    running();
}

doHouseWork();
</code></pre>

<p>做家事執行了三件事，wash, eat, 和 running</p>

<p>其中每件事都設定不同的完成時間</p>

<p>以 procedure 的程式執行方式來看，在這邊用 ruby 舉例:</p>

<pre><code class="ruby">def wash
  sleep 1
  puts "wash"
end 

def eat
  sleep 5
  puts "eat"
end 

def running 
  sleep 3
  puts "running"
end 

def doHouseWork 
  wash
  eat
  running
end 

doHouseWork
</code></pre>

<p>是會 wash 1 秒後，接著 eat 5 秒，再 running 3 秒</p>

<p>所以總共是 9 秒</p>

<p>output 的順序會是:</p>

<pre><code>wash // 1 秒
eat // 5 秒
running // 3 秒
</code></pre>

<p>但是在 javascript 中，output 的順序卻是:</p>

<pre><code>wash // 1 秒
running // 3 秒
eat // 5 秒
</code></pre>

<p>所以總長度是 5 秒</p>

<p>那今天假設想要讓 javascript 有順序性時該怎麼辦?</p>

<p>拿上面的例子作修改的話:</p>

<pre><code class="javascript">function wash(callback) {
    setTimeout(function() {
        console.log("wash");
        callback.call();
    }, 1000);
}

function eat(callback) {
    setTimeout(function() {
        console.log("eat");
        callback.call();
    }, 5000);
}

function running() {
    setTimeout(function() {
        console.log("running");
    }, 3000);
}

function doHouseWork(callback) {
    console.log("doing house work");
    callback.call();
}

doHouseWork(function(){
    wash(function() {
        eat(function() {
            running();
        });
    });
});
</code></pre>

<p>很不錯的特性，但是也要特別對於這種特性作處理</p>

<p>有個 lib 很好用，<code>async.js</code> <a href="https://github.com/caolan/async">來源</a></p>

<p>下回待續!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d14] - [Javascript 番外篇] Javascript Function Scopes 和 Closures]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/14/api-d14/"/>
    <updated>2014-10-14T22:40:32+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/14/api-d14</id>
    <content type="html"><![CDATA[<p>這幾天會探討 javascript 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<h2>Scope</h2>

<p>例子:</p>

<pre><code class="javascript">function hi() {
    var greetings = "hi";

    console.log("Say: " + greetings);

    function sayYa(newInput) {
        greetings = newInput;
        console.log("Say: " + greetings);
    }

    function sayCool(newInput) {
        var cool = newInput;
        console.log("Say: " + cool);
    }

    sayYa("Yo");
    sayCool("Cool");

    console.log("Say: " + greetings);
}

hi();
</code></pre>

<p>很簡單的概念</p>

<p>greetins 在 sayYa 方法中被覆寫掉了</p>

<p>如果要定義 local 變數必須在 function 裏用 var 定義</p>

<p>例如 sayCool function</p>

<h2>Closure</h2>

<p>例子:</p>

<pre><code>function person(){
    var name = 'default';

    return {
        greetings: function() {
            console.log( name );
        },
        changeName: function(newInput) {
            name = newInput;
        }
    };
}

var me = new person();
me.greetings();
me.changeName("kerkerj");
me.greetings();
</code></pre>

<h2>Self-Executing Anonymous Functions</h2>

<p>使用這種方式通常是避免和其他 js 檔案造成變數混淆</p>

<p>或是初始化</p>

<p>裡面的變數和 function 只被限制在這個範圍內</p>

<p>例子:</p>

<pre><code>(function(){
    var hi = 'Hello';

    function sayHi(name){
        return hi + ' ' + name;
    }

    global.greetings = sayHi
})(global);

console.log(global.greetings("kerkerj"));
console.log(hi); // &lt;- 這會失敗
</code></pre>

<p>必須將 sayHi 指給 global 的某一個變數, 才有辦法使用它</p>

<p>在 node.js 中 global 是全域變數，在瀏覽器中是 window~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d13] - [Javascript 番外篇] Javascript Require/ Module/ Module Pattern]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/13/api-d13/"/>
    <updated>2014-10-13T18:24:17+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/13/api-d13</id>
    <content type="html"><![CDATA[<p>接下來幾天會探討 node.js 的特性，由於比較少在寫 js ，因此有錯請指正</p>

<p>在 node.js 裏，要讀取外部模組都是透過 require 和 exports 來做溝通</p>

<p>以下列出這次最簡單 module 的例子</p>

<pre><code class="javascript">//hello.js
console.log('Hello World');
</code></pre>

<pre><code>// app.js
require('./hello.js');
</code></pre>

<h2>Module 也是有 Pattern 的</h2>

<p>第一種: Global (Not so good)</p>

<pre><code>// foo.js
foo = function() {
    console.log("foo!");
}

// app.js
require('./foo.js');
foo();
</code></pre>

<p>第二種: export an anonymous function</p>

<pre><code>// foo.js
module.exports = function() {
    console.log("foo! YA");
};

// app.js
var test = require("./foo.js");
test();
</code></pre>

<p>第三種： export a named function</p>

<pre><code>// bar.js
exports.bar = function() {
    console.log("bar");
}

// app.js
var bar = require('./bar.js').bar;
bar();
</code></pre>

<p>第四種: exports an anoymous object</p>

<pre><code>// bar4.js
var Bar4 = function() {};

Bar4.prototype.say = function() {
    console.log('bar4');
};

module.exports = new Bar4();

// app.js 
var b = require('./bar4.js');
b.say();
</code></pre>

<p>第五種: export a named object</p>

<pre><code>// bar5.js
var Bar5 = function() {};

Bar5.prototype.say = function() {
    console.log("bar5");
};

exports.Bar5 = new Bar5();

// app.js
var b = require('./bar5.js').Bar5;
b.say();
</code></pre>

<p>第六種: export an anonymous prototype</p>

<pre><code>// cool.js
var Cool = function() {};

Cool.prototype.say = function() {
    console.log('Cool!');
};

module.exports = Cool;

// app.js
var Cool = require('./cool.js');
var coo = new Cool();
coo.say();
</code></pre>

<p>第七種: export a named prototype</p>

<pre><code>// ang.js
var Ang = function () {};

Ang.prototype.say = function () {
    console.log('Ang!');
};

exports.Ang = Ang;

// app.js
var Ang = require('./ang.js').Ang;
var wer = new Ang();
wer.say();
</code></pre>

<h2>exports v.s. module.exports</h2>

<p>exports 是 module.exports 的輔助方法</p>

<p>以下有個例子會執行錯誤:</p>

<pre><code>// ya.js
module.exports = "YA";
exports.name = function() {
    console.log('My name is kerkerj');
};

// app.js
var ya = require('./ya.js');
ya.name(); TypeError: Cannot call method 'name' of undefined
</code></pre>

<p>在 ya.js 中 module.exports 有屬性了</p>

<p>因此下面的 export.name 就沒有被加入了</p>

<p>如果 module.exports 沒有任何屬性被加入的話，</p>

<p>exports 若有屬性了，則會交給 module.exports</p>

<p>反之就是剛剛的情況，moduel.exports 已經有屬性了，因此 export.name 就沒有作用了</p>

<p><a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html">延伸閱讀</a></p>

<h2>Module as class</h2>

<p>直接看例子吧 XD</p>

<pre><code>// user.js
module.exports = function(name, age) {
    this.name = name;
    this.age = age;
    this.about = function() {
        console.log(this.name +' is '+ this.age +' years old');
    };
};

// app.js
var User = require('./user.js');
var kerkerj = new User('kerkerj', 18);
kerkerj.about(); 
</code></pre>
]]></content>
  </entry>
  
</feed>
