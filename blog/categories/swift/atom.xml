<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-09T21:58:33+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift-d9] - Playground - Class, Struct]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/09/swift-d9/"/>
    <updated>2014-10-09T21:46:17+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/09/swift-d9</id>
    <content type="html"><![CDATA[<h1>Playground - Class, Struct</h1>

<p>再來就是要提重點的東西了!</p>

<p>class 和 struct 是用來建構整個程式重要的東西</p>

<p>兩者的差異在於：class 可以繼承其他 class，但是 struct 無法繼承</p>

<p>以下是宣告方式</p>

<pre><code class="swift">class SomeClass {
    //...
}

struct SomeStruct {
    //...
}
</code></pre>

<p>注意，Swift 的 class 和 struct 命名慣例是大寫命名風格 <code>UpperCamelCase</code></p>

<p>而屬性和方法則是 <code>lowerCamelCase</code></p>

<p>例如 <code>increaseCount</code>, <code>addTwoInts</code></p>

<p>舉個例子:</p>

<pre><code>struct Resolution {
    var width = 0
    var height = 0
}

class CustomLabel {
    var resolution = Resolution()
    var isLabel = true
    var name: String?
}
</code></pre>

<p>實體化，就可以改變其中的值了</p>

<pre><code>var someResolution = Resolution()
var someLabel = CustomLabel()

someResolution.width = 100
someLabel.resolution.height = 200
</code></pre>

<p>就是一直 <code>點</code> 下去就對了!</p>

<p>Struct 我們也可以直接給定初始值，class 就不能這樣做了~</p>

<pre><code>var someResolution = Resolution(width: 200, height: 300)
</code></pre>

<p>sttuct 的 Getter 和 Setter 只存在於 computed properties</p>

<p>亦即是必須要被計算過的才能使用 Getter, Setter</p>

<p>以下就直接看別人的例子吧:</p>

<pre><code>struct Point {
    var x = 0.0, y = 0.0
}
struct Size {
    var width = 0.0, height = 0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    var center: Point {
    get {
        let centerX = origin.x + (size.width / 2)
        let centerY = origin.y + (size.height / 2)
        return Point(x: centerX, y: centerY)
    }
    set(newCenter) {
        origin.x = newCenter.x - (size.width / 2)
        origin.y = newCenter.y - (size.height / 2)
    }
    }
}
var square = Rect(origin: Point(x: 0.0, y: 0.0),
    size: Size(width: 10.0, height: 10.0))
let initialSquareCenter = square.center
square.center = Point(x: 15.0, y: 15.0)
println("square.origin is now at (\(square.origin.x), \(square.origin.y))")
</code></pre>

<h3>Struct 和 enum 是一種值型別</h3>

<p>值型別的的例子像是 Int, String &hellip;.</p>

<p>那 struct 和 enum 也是，都是以值來操作的</p>

<h3>Class 是參考型別</h3>

<h2>使用時機</h2>

<p>struct:</p>

<ul>
<li>用來封裝少量相關的資料</li>
<li>不需要繼承</li>
<li>是 copy value 而不是 reference</li>
</ul>


<p>例如：Label 的長寬, 三角形的三個點</p>

<h2>Class 二三事</h2>

<p>礙于篇幅關係，這邊簡單講解一些 class 比較重要的點</p>

<p>通常一個 class 裡面會有一些 variable 與 methods</p>

<p>通常還會有靜態的 variables, methods 或是 建構子 (constructor)</p>

<p>甚至是延遲載入一個變數</p>

<p>下面就簡單寫了一個 class 來說明這幾個部分</p>

<pre><code>class Person {

    var name: String
    var height: Int!

    // 型別屬性 (靜態變數)
    class var isAnimal: Bool {
        return true
    }

    // 初始化時必定輸入 name, 必須知道初始化時變數所代表的意義
    init(name: String) {
        self.name = name
    }

    // 型別方法 (靜態方法)
    class func sayHi() -&gt; String {
        return "Hi!"
    }

    func sayYa() -&gt; String {
        return "Ya"
    }

    final func car(#title: String) -&gt; String{
        return title
    }

    lazy var personalizedGreeting: String = {
        [unowned self] in
        return "Hello, \(self.name)!"
    }()
}

let person = Person(name: "Kerkerj")
println(person.personalizedGreeting)
println(person.car(title: "Toyota"))
println(person.sayYa())
println(Person.sayHi())
println(Person.isAnimal)
</code></pre>

<p><code>self</code> 的意思就代表 class 自己，就字面上來看應該蠻好懂的</p>

<p>通常 <code>lazy</code> 的使用時機在於，</p>

<p>有個值需要被複雜或大量計算時，或是初始化時可能需要大量計算時，</p>

<p>我們可以加入 <code>lazy</code>，使該變數在需要操作時再計算</p>

<p>下面再簡單講一點繼承的東西</p>

<p>直接看例子，我設定了一個 class 稱為 Man，繼承自 Person</p>

<pre><code>class Man: Person {
    class var sex: String {
        return "Male"
    }

    override init(name: String) {
        super.init(name: name)
    }

    override func sayYa() -&gt; String {
        return "YAYA"
    }

    func sayYo() -&gt; String {
        return "YO"
    }
}

let kerkerj = Man(name: "kerkerj")
println(kerkerj.name)
println(kerkerj.sayYa())
println(kerkerj.sayYo())
println(Man.sex)
</code></pre>

<p>可以觀察一下自動補完的選項，當輸入 <code>kerkerj.</code> 時</p>

<p>後面會出現除了 Man 這個 class 本身提供的變數與方法外，</p>

<p>還有 Person 的變數與方法，這就是因為 Man 繼承自 Person 的關係</p>

<p>Man 裡面覆寫了 init, sayYa 的方法，</p>

<p>原本 sayYa 只會出現一次 &ldquo;YA&rdquo;, 覆寫過後會出現兩次變成 &ldquo;YAYA&rdquo;</p>

<p>另外 Man 再多加了一個 sayYo 的方法</p>

<p>如果父類別的某些方法不想被覆寫，在關鍵字前加上 <code>final</code></p>

<p>就可以防止被覆寫</p>

<hr />

<p>以上是一些 class 和 struct 的特性</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d8] - Playground - Enumerations]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/08/swift-d8/"/>
    <updated>2014-10-08T13:04:25+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/08/swift-d8</id>
    <content type="html"><![CDATA[<h1>Playground - Enumerations</h1>

<p>通常會使用來定義一組相關的值</p>

<p>也是很方便的東西</p>

<h2>列舉語法</h2>

<pre><code class="swift">enum SomeEnumeration {
  // enumeration definition goes here
}
</code></pre>

<p>比方說，車子</p>

<pre><code>enum Car {
    case toyota
    case benz
    case BMW
}
</code></pre>

<p>也可以這樣寫</p>

<pre><code>enum Car {
    case toyota, benz, BMW
}
</code></pre>

<p>使用:</p>

<pre><code>var car = Car.benz
</code></pre>

<h2>和 Switch 的搭配</h2>

<pre><code>enum Car {
    case Toyota, Benz, BMW
}

var car = Car.Benz

switch car {
case .Toyota:
    println("Toyota")
case .Benz:
    println("Benz")
case .BMW:
    println("BMW")
}
</code></pre>

<h2>Associated Values</h2>

<p>以 Barcode 來舉例子</p>

<pre><code>enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}

var productBarcode = Barcode.UPCA(12, 8948, 333)
</code></pre>

<p>我們可以借此來定義一些結構</p>

<h2>Raw Values</h2>

<p>我們可以先給定預設值：</p>

<pre><code>enum Barcode: String {
    case UPCA = "upca"
    case QRCode = "qrcode"
}

var productBarcode = Barcode.UPCA
println(productBarcode.toRaw())
</code></pre>

<p>可以透過 raw value 來找尋</p>

<pre><code>println(Barcode.fromRaw("qrcode"))
</code></pre>

<p>這個部分雖然不多，但是很實用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d7] - Playground - Closures]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/07/swift-d7/"/>
    <updated>2014-10-07T19:12:45+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/07/swift-d7</id>
    <content type="html"><![CDATA[<p>閉包表達式語法：</p>

<pre><code class="swift">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<p>舉個例子:</p>

<pre><code>func multiple(value: Int, multiple: Int -&gt; Int) -&gt; Int {
    return multiple(value)
}

multiple(3, { (value) -&gt; Int in
    value * 3
})
</code></pre>

<p>在 <code>multiple</code> function 中需要傳入一個 <code>function</code></p>

<p>在這邊我們並沒有另外定義，而是直接使用閉包的方式傳入一個 <code>function</code></p>

<p>這個閉包就符合了上面的定義</p>

<h2>根據上下文判斷型別 (Inferring type from context)</h2>

<p>承上一個例子，我們可以寫得更簡潔一點</p>

<pre><code>multiple(3, { value in
    value * 3
})
</code></pre>

<p>這是因為 Swift 會根據兩邊的定義來判斷型別，因此可以寫得更簡潔一些</p>

<h3>參數名稱縮寫, 運算子函式</h3>

<p>直接看例子</p>

<pre><code>func biggerThan0(value: Int, isBigger: Int -&gt; Bool) -&gt; Bool {
    return isBigger(value)
}

biggerThan0(-1,
    { $0 &gt; 0 }
)
</code></pre>

<h3>尾隨閉包 (trailing closures)</h3>

<p>通常如果閉包太長的話，可以把閉包接在括號後面：</p>

<pre><code>func someFunc(closure: () -&gt; ()) {
    // main
}

someFunc({
    // closure main
})

somFunc() {
    // closure main
}
</code></pre>

<p>以上面的例子做例子:</p>

<pre><code>func biggerThan0(value: Int, isBigger: Int -&gt; Bool) -&gt; Bool {
    return isBigger(value)
}

biggerThan0(-1) { $0 &gt; 0 }
</code></pre>

<p>如果是不需要參數的話，甚至可以把 () 省略掉</p>

<p>這邊直接參考一下別人的例子，是使用 array map 方法</p>

<p>下面要做的事情是</p>

<p>將 [16,58,510] 轉成 [&ldquo;OneSix&rdquo;, &ldquo;FiveEight&rdquo;, &ldquo;FiveOneZero&rdquo;]</p>

<pre><code>let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]

let numbers = [16, 58, 510]

let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
</code></pre>

<p>這個例子中，array 的 map 會用後面接的閉包，接連的處理陣列裡面的元素</p>

<p>所以最後 strings 的陣列就是處理過後的陣列</p>

<p>而處理的方法則是將 Int 的每個位數分別轉換成 String 連接起來再回傳</p>

<p>很方便的方法!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d6] - Playground - Function]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/06/swift-d6/"/>
    <updated>2014-10-06T18:54:13+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/06/swift-d6</id>
    <content type="html"><![CDATA[<h1>Playground - function</h1>

<p>來看看 Swift 各種 function 的寫法吧!</p>

<p>Swift 使用 <code>func</code> 當作宣告的保留字</p>

<p>GOLANG 的 fu&hellip;. XD</p>

<p>寫 Swift 的 function 會很開心</p>

<h2>基本的</h2>

<pre><code class="swift">func say() {
    println("Hello!")
}
</code></pre>

<h2>有一個回傳值的</h2>

<pre><code class="swift">func say() -&gt; String {
    return "Hello!"
}
</code></pre>

<h2>有多個回傳值的!!! (就是回傳 Tuple)</h2>

<pre><code class="swift">func say() -&gt; (String, Int) {
    let greeting = "hello"
    let times = 5
    return (greeting, times)
}

say()
</code></pre>

<h2>有參數的</h2>

<pre><code class="swift">func say(g: String) {
    println(g)
}

say("Hello")
</code></pre>

<p>多個參數</p>

<pre><code class="swift">func say(g: String, times: Int) {
    for index in 1...times {
        println(g)
    }
}

say("Hello", 3)
</code></pre>

<h2>有參數的進階版</h2>

<pre><code class="swift">func say(greetings g: String) {
    println(g)
}

say("Hello", 3)
</code></pre>

<p>此時如果同樣使用 <code>say("hello")</code> 會出錯</p>

<p>因為我們剛剛宣告了外部參數名稱</p>

<p>因此需要:</p>

<pre><code class="swift">say(greetings: "hello")
</code></pre>

<p>這種寫法在必須代入許多參數時，非常好用，會讓程式可讀性變高</p>

<p>另外，方便起見，也可以加上 <code>#</code>，表示外部參數名稱與 func 內部名稱是一樣的</p>

<pre><code class="swift">func say(greetings g: String, #times: Int) {
    for index in 1...times {
        println(g)
    }
}
say(greetings: "Hello", times: 3)
</code></pre>

<p>可以看到第一種寫法和第二種寫法是一樣的功用~</p>

<h2>給參數預設值</h2>

<pre><code class="swift">func say(greetings g: String = "hello") {
    println(g)
}

say()
</code></pre>

<p>如果呼叫 <code>say()</code> 而沒有給定參數時，會直接使用預設值</p>

<h2>常數參數與變數參數</h2>

<p>簡單看一下以下的程式碼</p>

<pre><code class="swift">func say(greetings: String = "hello") {
    greetings = "\(greetings), welcome!"
    println(greetings)
}

let greetings = "Hello!"
say(greetings: greetings)
</code></pre>

<p>我們定義了一個常數，代入 say() 裡面，</p>

<p>但是 say function 裡面必須改變代入的值，於是這個時候 Xcode 就會該了</p>

<p>那要怎麼辦呢?</p>

<p>修改成:</p>

<pre><code class="swift">func say(var greetings: String = "hello") {
    greetings = "\(greetings), welcome!"
    println(greetings)
}

let greetings = "Hello!"
say(greetings: greetings)
</code></pre>

<p>多加一個 <code>var</code> 宣告，就會 copy 一份傳入，就可以更改值了!</p>

<p>一樣是非常有用的語法!</p>

<h2>輸入輸出函數</h2>

<p>直接看例子</p>

<pre><code class="swift">func swapInt(inout a: Int, inout b: Int) {
    let tmpA = a
    a = b
    b = tmpA
}

var a = 1
var b = 2

swap(&amp;a, &amp;b)

println(a)
println(b)
</code></pre>

<p>酷吧</p>

<h2>function types 函式型別</h2>

<p>直接看例子</p>

<pre><code class="swift">func addTwoInt(a: Int, b: Int) -&gt; Int {
    return a + b
}

func mTwoInt(a: Int, b: Int) -&gt; Int {
    return a * b
}

func printHello() {
    println("Hello World")
}

var mathFunction: (Int, Int) -&gt; Int = addTwoInt

println("result: \(mathFunction(2, 3))")
</code></pre>

<p>前面宣告了三個 function ，</p>

<p>而</p>

<pre><code class="swift">var mathFunction: (Int, Int) -&gt; Int = addTwoInt
</code></pre>

<p>後面的這句的意思是:</p>

<p>我們定義了一個變數叫做 <code>mathFunction</code>，</p>

<p>他的型別是「一個 (Int, Int) 的參數，並且回傳 Int」的 function，</p>

<p>簡單說就是 mathFunction 的型別是一個 Function</p>

<p>並指向 addTwoInt 這個 function</p>

<p>所以上面的例子中，<code>mathFunction</code> 代入的 <code>(2, 3)</code> 會丟給 addTwoInt，</p>

<p>並且最後回傳 Int</p>

<p>有 javascript 的味道:</p>

<pre><code class="javascript">var test = function(a, b) {
  return a + b;
};

var add = test;

console.log("result = " + add(2, 3));
</code></pre>

<h2>function as parameter types</h2>

<p>函式也可以拿來當做參數傳入函式中，</p>

<p>接續上面的例子，加入：</p>

<pre><code>func printResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int )  {
    println("Result: \(mathFunction(a, b))")
}
printResult(mathFunction, 2, 3)
</code></pre>

<h2>function as return type</h2>

<p>函式也可以拿來當做回傳值</p>

<p>就是在原本的回傳符號 <code>-&gt;</code> 後面代入函式型別</p>

<p>這邊直接借別人的例子來參考吧</p>

<pre><code>// 定義兩個 function 
func stepForward(input: Int) -&gt; Int {
    return input + 1
}
func stepBackward(input: Int) -&gt; Int {
    return input - 1
}

// 再定義一個 function ，透過布林值導往上面不同的 function
func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    return backwards ? stepBackward : stepForward
}

var currentValue = 3

// 將 chooseStepFunction 指給 moveNearerToZero
// 所以 moveNearerToZero 現在是一個 function 了!
let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)

println("Counting to zero:")
// Counting to zero:
while currentValue != 0 {
    println("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
println("zero!")
</code></pre>

<h2>Nested Function</h2>

<p>就是 funciton 中的 function，變數有分 global、local 變數，function 也有</p>

<p>以上面的例子來改寫:</p>

<pre><code>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    return backwards ? stepBackward : stepForward
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d5] - Playground - Array, Dictionary, Controll Flow]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/05/swift-d5/"/>
    <updated>2014-10-05T16:40:23+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/05/swift-d5</id>
    <content type="html"><![CDATA[<h2>Array</h2>

<h3>宣告</h3>

<pre><code class="swift">// var VARIABLE_NAME: [TYPE] = .....

var fruits: [String] = ["apple", "banana"]
var nums: [Int] = [1, 2]

// 或是讓 Swift 自行判斷類型:
var fruits = ["apple", "banana"]
var nums = [1, 2]

// 初始化:
var cars = [String]()
</code></pre>

<p>ps. Beta 版時的寫法是 <code>var fruits: String[]</code></p>

<p>現在已經變成了 <code>var fruits: [String]</code></p>

<h3>操作</h3>

<pre><code>// 判斷該陣列是否有值，回傳 true 或 false
fruits.isEmpty 

// 增加元素
fruits.append("watermelon")
fruits += ["lemon"]

// 取值 
fruits[0]
fruits[0...2]

// 刪除值 - 將 apple 移除，banana 會自動補上
fruits.removeAtIndex(0)
fruits[0]

// 兩個陣列合併 (必須相同類別 e.g. String)
fruits + cars

// 陣列元素數量
fruits.count
</code></pre>

<h2>Dictionary</h2>

<h3>宣告</h3>

<p>由於 Dictionary 是 key/value 為一組 (pair)，</p>

<p>因此宣告時必須宣告 key 和 value 分別是哪種型別</p>

<pre><code>var httpStatus: Dictionary&lt;Int, String&gt; = Dictionary&lt;Int, String&gt;()

var httpStatus: Dictionary&lt;Int, String&gt; = [200: "Success", 404: "Not found"]
</code></pre>

<h3>操作</h3>

<pre><code>// 一樣有 isEmpty 方法
httpStatus.isEmpty

// 取值
httpStatus[200] // = "Success"

// 加入值
httpStatus[500] = "Internal Server Error"

// 修改值
httpStatus[200] = "True"
httpStatus.updateValue("internal server error", forKey: 500)

// 刪除值
httpStatus.removeValueForKey(200)

// 字典元素數量
httpStatus.count
</code></pre>

<h2>Controll Flow</h2>

<h3>For loop</h3>

<pre><code>for fruit in fruits {
    println(fruit)
}

for var index = 0; index &lt; fruits.count; ++index {
    println(fruits[index])
}
</code></pre>

<h3>While</h3>

<pre><code>var index = 0
while index &lt; fruits.count {
    println(fruits[index])
    index++
}
</code></pre>

<h3>Do-while</h3>

<pre><code>var index = 0
do {
    println(fruits[index])
    index++ 
} while (index &lt; fruits.count)
</code></pre>

<h3>If</h3>

<pre><code>var index = 5566

if index = 5566 {
    println("5566 不能亡")
}

if index = 5566 {
    println("5566 不能亡")
} else {
    println("You are not 5566")
}

if index = 5566 {
    println("5566 不能亡")
} else if index &lt; 5566 {
    println("You are less than 5566")
} else {
    println("You are bigger than 5566")
}
</code></pre>

<h3>Switch</h3>

<pre><code>var index = 0

switch index {
case 0, 1, 2
    println("small")
case 8, 9, 11 
    println("big")
default:
    println("others")
}
</code></pre>

<p>引入 Tuple</p>

<pre><code>let httpStatus = (200, "Success")

switch httpStatus {
case (let statusCode, "Error"):
    println("(\(statusCode)) is Error")
case (200, let msg):
    println("(\(msg))'s statusCode is 200")
}
</code></pre>

<h2>Switch - break, continue, fallthrough</h2>

<h3>Continue</h3>

<p>continue 會使該次的 loop 停止，並繼續執行下一個 loop</p>

<p>continue 不存在於單一的 switch, 只會在 loop 裡的 switch 語句時才能使用</p>

<pre><code>var fruits = ["apple", "banana", "lemon", "waterlemon", "orange"]
for fruit in fruits {
    println("Start")

    switch fruit {
    case "banana":
        continue
    default:
        println(fruit)
    }

    println("End")
}
</code></pre>

<p>Start 和 End 理論上都要被印五次，</p>

<p>但是加入了 continue 後，banana case 當次 loop 的 End 就沒有被執行了</p>

<h3>Break</h3>

<p>通常是用在不想處理某個 case 或，特別想要處理時 (?) 反之嘛 XD</p>

<p>當使用了 break，會立即中斷 switch 程式碼的執行，並且跳到 switch 區塊程式碼結束的大括號後 (}) 的第一行程式</p>

<p>暫時想不到什麼好例子&hellip;.</p>

<p>先借別人的例子來用吧:</p>

<pre><code>let numberSymbol: Character = "三"  // 簡體中文裡的數字 3
var possibleIntegerValue: Int?
switch numberSymbol {
case "1", "١", "一", "๑":
    possibleIntegerValue = 1
case "2", "٢", "二", "๒":
    possibleIntegerValue = 2
case "3", "٣", "三", "๓":
    possibleIntegerValue = 3
case "4", "٤", "四", "๔":
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    println("The integer value of \(numberSymbol) is \(integerValue).")
} else {
    println("An integer value could not be found for \(numberSymbol).")
}
// 輸出 "The integer value of 三 is 3.
</code></pre>

<h3>Fallthrough</h3>

<p>在 Swift 中，掃到第一個符合的 case 後，就會中斷 switch 的執行了，避免掉入一些 case 處理的錯誤</p>

<p>而 fallthrough, 很有趣, 宣告後，會讓 switch 繼續掃下一個 case</p>

<pre><code>let num = 5
var description = "\(num) is"
switch num {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime, also"
    fallthrough
case 5: 
    println("I'm here")
default:
    description += " an integer."
}
println(description)
// I'm here
// 5 is a prime, also an integer.
</code></pre>
]]></content>
  </entry>
  
</feed>
