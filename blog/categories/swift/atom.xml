<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-08T13:14:23+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift-d8] - Playground - Enumerations]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/08/swift-d8/"/>
    <updated>2014-10-08T13:04:25+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/08/swift-d8</id>
    <content type="html"><![CDATA[<h1>Playground - Enumerations</h1>

<p>通常會使用來定義一組相關的值</p>

<p>也是很方便的東西</p>

<h2>列舉語法</h2>

<pre><code class="swift">enum SomeEnumeration {
  // enumeration definition goes here
}
</code></pre>

<p>比方說，車子</p>

<pre><code>enum Car {
    case toyota
    case benz
    case BMW
}
</code></pre>

<p>也可以這樣寫</p>

<pre><code>enum Car {
    case toyota, benz, BMW
}
</code></pre>

<p>使用:</p>

<pre><code>var car = Car.benz
</code></pre>

<h2>和 Switch 的搭配</h2>

<pre><code>enum Car {
    case Toyota, Benz, BMW
}

var car = Car.Benz

switch car {
case .Toyota:
    println("Toyota")
case .Benz:
    println("Benz")
case .BMW:
    println("BMW")
}
</code></pre>

<h2>Associated Values</h2>

<p>以 Barcode 來舉例子</p>

<pre><code>enum Barcode {
    case UPCA(Int, Int, Int)
    case QRCode(String)
}

var productBarcode = Barcode.UPCA(12, 8948, 333)
</code></pre>

<p>我們可以借此來定義一些結構</p>

<h2>Raw Values</h2>

<p>我們可以先給定預設值：</p>

<pre><code>enum Barcode: String {
    case UPCA = "upca"
    case QRCode = "qrcode"
}

var productBarcode = Barcode.UPCA
println(productBarcode.toRaw())
</code></pre>

<p>可以透過 raw value 來找尋</p>

<pre><code>println(Barcode.fromRaw("qrcode"))
</code></pre>

<p>這個部分雖然不多，但是很實用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d7] - Playground - Closures]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/07/swift-d7/"/>
    <updated>2014-10-07T19:12:45+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/07/swift-d7</id>
    <content type="html"><![CDATA[<p>閉包表達式語法：</p>

<pre><code class="swift">{ (parameters) -&gt; returnType in
    statements
}
</code></pre>

<p>舉個例子:</p>

<pre><code>func multiple(value: Int, multiple: Int -&gt; Int) -&gt; Int {
    return multiple(value)
}

multiple(3, { (value) -&gt; Int in
    value * 3
})
</code></pre>

<p>在 <code>multiple</code> function 中需要傳入一個 <code>function</code></p>

<p>在這邊我們並沒有另外定義，而是直接使用閉包的方式傳入一個 <code>function</code></p>

<p>這個閉包就符合了上面的定義</p>

<h2>根據上下文判斷型別 (Inferring type from context)</h2>

<p>承上一個例子，我們可以寫得更簡潔一點</p>

<pre><code>multiple(3, { value in
    value * 3
})
</code></pre>

<p>這是因為 Swift 會根據兩邊的定義來判斷型別，因此可以寫得更簡潔一些</p>

<h3>參數名稱縮寫, 運算子函式</h3>

<p>直接看例子</p>

<pre><code>func biggerThan0(value: Int, isBigger: Int -&gt; Bool) -&gt; Bool {
    return isBigger(value)
}

biggerThan0(-1,
    { $0 &gt; 0 }
)
</code></pre>

<h3>尾隨閉包 (trailing closures)</h3>

<p>通常如果閉包太長的話，可以把閉包接在括號後面：</p>

<pre><code>func someFunc(closure: () -&gt; ()) {
    // main
}

someFunc({
    // closure main
})

somFunc() {
    // closure main
}
</code></pre>

<p>以上面的例子做例子:</p>

<pre><code>func biggerThan0(value: Int, isBigger: Int -&gt; Bool) -&gt; Bool {
    return isBigger(value)
}

biggerThan0(-1) { $0 &gt; 0 }
</code></pre>

<p>如果是不需要參數的話，甚至可以把 () 省略掉</p>

<p>這邊直接參考一下別人的例子，是使用 array map 方法</p>

<p>下面要做的事情是</p>

<p>將 [16,58,510] 轉成 [&ldquo;OneSix&rdquo;, &ldquo;FiveEight&rdquo;, &ldquo;FiveOneZero&rdquo;]</p>

<pre><code>let digitNames = [
    0: "Zero", 1: "One", 2: "Two",   3: "Three", 4: "Four",
    5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"
]

let numbers = [16, 58, 510]

let strings = numbers.map {
    (var number) -&gt; String in
    var output = ""
    while number &gt; 0 {
        output = digitNames[number % 10]! + output
        number /= 10
    }
    return output
}
</code></pre>

<p>這個例子中，array 的 map 會用後面接的閉包，接連的處理陣列裡面的元素</p>

<p>所以最後 strings 的陣列就是處理過後的陣列</p>

<p>而處理的方法則是將 Int 的每個位數分別轉換成 String 連接起來再回傳</p>

<p>很方便的方法!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d6] - Playground - Function]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/06/swift-d6/"/>
    <updated>2014-10-06T18:54:13+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/06/swift-d6</id>
    <content type="html"><![CDATA[<h1>Playground - function</h1>

<p>來看看 Swift 各種 function 的寫法吧!</p>

<p>Swift 使用 <code>func</code> 當作宣告的保留字</p>

<p>GOLANG 的 fu&hellip;. XD</p>

<p>寫 Swift 的 function 會很開心</p>

<h2>基本的</h2>

<pre><code class="swift">func say() {
    println("Hello!")
}
</code></pre>

<h2>有一個回傳值的</h2>

<pre><code class="swift">func say() -&gt; String {
    return "Hello!"
}
</code></pre>

<h2>有多個回傳值的!!! (就是回傳 Tuple)</h2>

<pre><code class="swift">func say() -&gt; (String, Int) {
    let greeting = "hello"
    let times = 5
    return (greeting, times)
}

say()
</code></pre>

<h2>有參數的</h2>

<pre><code class="swift">func say(g: String) {
    println(g)
}

say("Hello")
</code></pre>

<p>多個參數</p>

<pre><code class="swift">func say(g: String, times: Int) {
    for index in 1...times {
        println(g)
    }
}

say("Hello", 3)
</code></pre>

<h2>有參數的進階版</h2>

<pre><code class="swift">func say(greetings g: String) {
    println(g)
}

say("Hello", 3)
</code></pre>

<p>此時如果同樣使用 <code>say("hello")</code> 會出錯</p>

<p>因為我們剛剛宣告了外部參數名稱</p>

<p>因此需要:</p>

<pre><code class="swift">say(greetings: "hello")
</code></pre>

<p>這種寫法在必須代入許多參數時，非常好用，會讓程式可讀性變高</p>

<p>另外，方便起見，也可以加上 <code>#</code>，表示外部參數名稱與 func 內部名稱是一樣的</p>

<pre><code class="swift">func say(greetings g: String, #times: Int) {
    for index in 1...times {
        println(g)
    }
}
say(greetings: "Hello", times: 3)
</code></pre>

<p>可以看到第一種寫法和第二種寫法是一樣的功用~</p>

<h2>給參數預設值</h2>

<pre><code class="swift">func say(greetings g: String = "hello") {
    println(g)
}

say()
</code></pre>

<p>如果呼叫 <code>say()</code> 而沒有給定參數時，會直接使用預設值</p>

<h2>常數參數與變數參數</h2>

<p>簡單看一下以下的程式碼</p>

<pre><code class="swift">func say(greetings: String = "hello") {
    greetings = "\(greetings), welcome!"
    println(greetings)
}

let greetings = "Hello!"
say(greetings: greetings)
</code></pre>

<p>我們定義了一個常數，代入 say() 裡面，</p>

<p>但是 say function 裡面必須改變代入的值，於是這個時候 Xcode 就會該了</p>

<p>那要怎麼辦呢?</p>

<p>修改成:</p>

<pre><code class="swift">func say(var greetings: String = "hello") {
    greetings = "\(greetings), welcome!"
    println(greetings)
}

let greetings = "Hello!"
say(greetings: greetings)
</code></pre>

<p>多加一個 <code>var</code> 宣告，就會 copy 一份傳入，就可以更改值了!</p>

<p>一樣是非常有用的語法!</p>

<h2>輸入輸出函數</h2>

<p>直接看例子</p>

<pre><code class="swift">func swapInt(inout a: Int, inout b: Int) {
    let tmpA = a
    a = b
    b = tmpA
}

var a = 1
var b = 2

swap(&amp;a, &amp;b)

println(a)
println(b)
</code></pre>

<p>酷吧</p>

<h2>function types 函式型別</h2>

<p>直接看例子</p>

<pre><code class="swift">func addTwoInt(a: Int, b: Int) -&gt; Int {
    return a + b
}

func mTwoInt(a: Int, b: Int) -&gt; Int {
    return a * b
}

func printHello() {
    println("Hello World")
}

var mathFunction: (Int, Int) -&gt; Int = addTwoInt

println("result: \(mathFunction(2, 3))")
</code></pre>

<p>前面宣告了三個 function ，</p>

<p>而</p>

<pre><code class="swift">var mathFunction: (Int, Int) -&gt; Int = addTwoInt
</code></pre>

<p>後面的這句的意思是:</p>

<p>我們定義了一個變數叫做 <code>mathFunction</code>，</p>

<p>他的型別是「一個 (Int, Int) 的參數，並且回傳 Int」的 function，</p>

<p>簡單說就是 mathFunction 的型別是一個 Function</p>

<p>並指向 addTwoInt 這個 function</p>

<p>所以上面的例子中，<code>mathFunction</code> 代入的 <code>(2, 3)</code> 會丟給 addTwoInt，</p>

<p>並且最後回傳 Int</p>

<p>有 javascript 的味道:</p>

<pre><code class="javascript">var test = function(a, b) {
  return a + b;
};

var add = test;

console.log("result = " + add(2, 3));
</code></pre>

<h2>function as parameter types</h2>

<p>函式也可以拿來當做參數傳入函式中，</p>

<p>接續上面的例子，加入：</p>

<pre><code>func printResult(mathFunction: (Int, Int) -&gt; Int, a: Int, b: Int )  {
    println("Result: \(mathFunction(a, b))")
}
printResult(mathFunction, 2, 3)
</code></pre>

<h2>function as return type</h2>

<p>函式也可以拿來當做回傳值</p>

<p>就是在原本的回傳符號 <code>-&gt;</code> 後面代入函式型別</p>

<p>這邊直接借別人的例子來參考吧</p>

<pre><code>// 定義兩個 function 
func stepForward(input: Int) -&gt; Int {
    return input + 1
}
func stepBackward(input: Int) -&gt; Int {
    return input - 1
}

// 再定義一個 function ，透過布林值導往上面不同的 function
func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    return backwards ? stepBackward : stepForward
}

var currentValue = 3

// 將 chooseStepFunction 指給 moveNearerToZero
// 所以 moveNearerToZero 現在是一個 function 了!
let moveNearerToZero = chooseStepFunction(currentValue &gt; 0)

println("Counting to zero:")
// Counting to zero:
while currentValue != 0 {
    println("\(currentValue)... ")
    currentValue = moveNearerToZero(currentValue)
}
println("zero!")
</code></pre>

<h2>Nested Function</h2>

<p>就是 funciton 中的 function，變數有分 global、local 變數，function 也有</p>

<p>以上面的例子來改寫:</p>

<pre><code>func chooseStepFunction(backwards: Bool) -&gt; (Int) -&gt; Int {
    func stepForward(input: Int) -&gt; Int { return input + 1 }
    func stepBackward(input: Int) -&gt; Int { return input - 1 }
    return backwards ? stepBackward : stepForward
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d5] - Playground - Array, Dictionary, Controll Flow]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/05/swift-d5/"/>
    <updated>2014-10-05T16:40:23+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/05/swift-d5</id>
    <content type="html"><![CDATA[<h2>Array</h2>

<h3>宣告</h3>

<pre><code class="swift">// var VARIABLE_NAME: [TYPE] = .....

var fruits: [String] = ["apple", "banana"]
var nums: [Int] = [1, 2]

// 或是讓 Swift 自行判斷類型:
var fruits = ["apple", "banana"]
var nums = [1, 2]

// 初始化:
var cars = [String]()
</code></pre>

<p>ps. Beta 版時的寫法是 <code>var fruits: String[]</code></p>

<p>現在已經變成了 <code>var fruits: [String]</code></p>

<h3>操作</h3>

<pre><code>// 判斷該陣列是否有值，回傳 true 或 false
fruits.isEmpty 

// 增加元素
fruits.append("watermelon")
fruits += ["lemon"]

// 取值 
fruits[0]
fruits[0...2]

// 刪除值 - 將 apple 移除，banana 會自動補上
fruits.removeAtIndex(0)
fruits[0]

// 兩個陣列合併 (必須相同類別 e.g. String)
fruits + cars

// 陣列元素數量
fruits.count
</code></pre>

<h2>Dictionary</h2>

<h3>宣告</h3>

<p>由於 Dictionary 是 key/value 為一組 (pair)，</p>

<p>因此宣告時必須宣告 key 和 value 分別是哪種型別</p>

<pre><code>var httpStatus: Dictionary&lt;Int, String&gt; = Dictionary&lt;Int, String&gt;()

var httpStatus: Dictionary&lt;Int, String&gt; = [200: "Success", 404: "Not found"]
</code></pre>

<h3>操作</h3>

<pre><code>// 一樣有 isEmpty 方法
httpStatus.isEmpty

// 取值
httpStatus[200] // = "Success"

// 加入值
httpStatus[500] = "Internal Server Error"

// 修改值
httpStatus[200] = "True"
httpStatus.updateValue("internal server error", forKey: 500)

// 刪除值
httpStatus.removeValueForKey(200)

// 字典元素數量
httpStatus.count
</code></pre>

<h2>Controll Flow</h2>

<h3>For loop</h3>

<pre><code>for fruit in fruits {
    println(fruit)
}

for var index = 0; index &lt; fruits.count; ++index {
    println(fruits[index])
}
</code></pre>

<h3>While</h3>

<pre><code>var index = 0
while index &lt; fruits.count {
    println(fruits[index])
    index++
}
</code></pre>

<h3>Do-while</h3>

<pre><code>var index = 0
do {
    println(fruits[index])
    index++ 
} while (index &lt; fruits.count)
</code></pre>

<h3>If</h3>

<pre><code>var index = 5566

if index = 5566 {
    println("5566 不能亡")
}

if index = 5566 {
    println("5566 不能亡")
} else {
    println("You are not 5566")
}

if index = 5566 {
    println("5566 不能亡")
} else if index &lt; 5566 {
    println("You are less than 5566")
} else {
    println("You are bigger than 5566")
}
</code></pre>

<h3>Switch</h3>

<pre><code>var index = 0

switch index {
case 0, 1, 2
    println("small")
case 8, 9, 11 
    println("big")
default:
    println("others")
}
</code></pre>

<p>引入 Tuple</p>

<pre><code>let httpStatus = (200, "Success")

switch httpStatus {
case (let statusCode, "Error"):
    println("(\(statusCode)) is Error")
case (200, let msg):
    println("(\(msg))'s statusCode is 200")
}
</code></pre>

<h2>Switch - break, continue, fallthrough</h2>

<h3>Continue</h3>

<p>continue 會使該次的 loop 停止，並繼續執行下一個 loop</p>

<p>continue 不存在於單一的 switch, 只會在 loop 裡的 switch 語句時才能使用</p>

<pre><code>var fruits = ["apple", "banana", "lemon", "waterlemon", "orange"]
for fruit in fruits {
    println("Start")

    switch fruit {
    case "banana":
        continue
    default:
        println(fruit)
    }

    println("End")
}
</code></pre>

<p>Start 和 End 理論上都要被印五次，</p>

<p>但是加入了 continue 後，banana case 當次 loop 的 End 就沒有被執行了</p>

<h3>Break</h3>

<p>通常是用在不想處理某個 case 或，特別想要處理時 (?) 反之嘛 XD</p>

<p>當使用了 break，會立即中斷 switch 程式碼的執行，並且跳到 switch 區塊程式碼結束的大括號後 (}) 的第一行程式</p>

<p>暫時想不到什麼好例子&hellip;.</p>

<p>先借別人的例子來用吧:</p>

<pre><code>let numberSymbol: Character = "三"  // 簡體中文裡的數字 3
var possibleIntegerValue: Int?
switch numberSymbol {
case "1", "١", "一", "๑":
    possibleIntegerValue = 1
case "2", "٢", "二", "๒":
    possibleIntegerValue = 2
case "3", "٣", "三", "๓":
    possibleIntegerValue = 3
case "4", "٤", "四", "๔":
    possibleIntegerValue = 4
default:
    break
}
if let integerValue = possibleIntegerValue {
    println("The integer value of \(numberSymbol) is \(integerValue).")
} else {
    println("An integer value could not be found for \(numberSymbol).")
}
// 輸出 "The integer value of 三 is 3.
</code></pre>

<h3>Fallthrough</h3>

<p>在 Swift 中，掃到第一個符合的 case 後，就會中斷 switch 的執行了，避免掉入一些 case 處理的錯誤</p>

<p>而 fallthrough, 很有趣, 宣告後，會讓 switch 繼續掃下一個 case</p>

<pre><code>let num = 5
var description = "\(num) is"
switch num {
case 2, 3, 5, 7, 11, 13, 17, 19:
    description += " a prime, also"
    fallthrough
case 5: 
    println("I'm here")
default:
    description += " an integer."
}
println(description)
// I'm here
// 5 is a prime, also an integer.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d4] - Playground - Optional, ! And ?]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/04/swift-d4/"/>
    <updated>2014-10-04T18:53:03+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/04/swift-d4</id>
    <content type="html"><![CDATA[<h1>Playground - Optional, ! and ?</h1>

<p>今天要來探討 Optional 型別，我認為這塊是初學 Swift 常遇到的問題<br/>
大家搞不懂 &ldquo;!&rdquo; &ldquo;?&rdquo; 到底在幹什麼，所以今天就來了解一下</p>

<p>在 Swift 中，所有的資料型別都不能賦予 nil<br/>
也就是以下這件事是不成立的：</p>

<pre><code class="Swift">var x: String = "test"
x = nil
</code></pre>

<p>所以在 Swift 底下，就要使用 Optional 來處理值可能不存在的情況<br/>
當一個變數 x 被宣告成 Optional 型別時，該變數就會有兩個情況：</p>

<pre><code>1. 有值，等於 x
2. 沒有值
</code></pre>

<p>要宣告一個變數可能為 nil 時的方式是使用問號 &lsquo;?&#8217;：</p>

<pre><code>// 此時 x = "yaya"
var x: String? = "yaya"

// 此時 x 沒有值
x = nil
</code></pre>

<p>拿以下程式在 Playground 執行看看：</p>

<pre><code>var str: String = ""
println(str)
str = "yaya"
println(str)

var str2: String?
println(str2)
str2 = "yaya"
println(str2)
</code></pre>

<p>可以看一下 Playground 右邊的輸出框，觀察兩個 string 的差異<br/>
當 str2 被賦予 Optional 型別後，<br/>
str2  已經不是單純的 String 型別了，</p>

<p>那如何強制以 String 型別拿到 str2 的資料呢?
試著在 str2 後面加上驚嘆號，並觀察右方輸出結果:</p>

<pre><code>println(str2!)
</code></pre>

<p>請注意！若要強制取值，一定要確保此 Optional 型別中一定有值，
否則將會導致執行錯誤，以下是錯誤範例：</p>

<pre><code>var str2: String? = "yaya"
println(str2)
str2 = nil
println(str2!)
</code></pre>

<p>程式將會在第四行返回錯誤，因此使用驚嘆號強制取值前請先確保 Optional 裡有值。</p>

<p>在 Objective-C 中，nil 是指向一個不存在物件的指標；
而 Swift 中，nil 是一種非常明確地值 － 他就是代表「不存在」。</p>

<p>在 Playground 中多試試看囉~~</p>

<p>ps. Swift 的 ? 和 Ruby 的 ? 是完全不同意思的XD</p>
]]></content>
  </entry>
  
</feed>
