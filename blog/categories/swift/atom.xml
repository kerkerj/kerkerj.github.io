<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-24T20:47:09+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift-d24] - 實戰開發 - TODOList - Create View]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/24/swift-d24/"/>
    <updated>2014-10-24T20:42:41+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/24/swift-d24</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day24">Github link</a></p>

<p>今天要來建立 &ldquo;新增資料&rdquo; 的頁面</p>

<p>不過這個頁面我們也會拿來給 &ldquo;更新資料&rdquo; 的頁面使用</p>

<p>原因其實很簡單</p>

<p>兩邊要建立或編輯的資料是一樣的</p>

<p>差別只在於，當今天是編輯資料的 view call 該頁面時，</p>

<p>該頁面除了顯示編輯框外，編輯框內的文字也會預先 load 好舊的資料了</p>

<p>除此之外兩個 view 的排版一模一樣</p>

<p>所以在這邊我們就只建立一個 UpdateViewController 就可以了</p>

<p>那我們一樣建立一組 UpdateViewController.swift + UpdateViewController.xib</p>

<p>也一樣為元件建立關聯</p>

<p><img src="http://goo.gl/4AO4G0" alt="image" /></p>

<p>回到主頁</p>

<p>我們幫 Add 新增一個按鈕吧</p>

<p>在 viewDidLoad 中</p>

<pre><code class="swift">self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Add", style: UIBarButtonItemStyle.Done, target: self, action: Selector("pushToAddTODO"))
</code></pre>

<p>設定 Navigation 的右邊鍵的功能</p>

<p>並且根據 pushToAddTODO 的方法做事情</p>

<p>因此繼續下去將 pushToAddTODO 方法做一下</p>

<pre><code>    func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        addViewController.from = "add"

        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>這樣寫完後就可以執行看看了!</p>

<p>剩下的任務就是將資料寫進 fakeData 不過考慮到之後我們是使用 API</p>

<p>因此就先不特別作 ShowViewController 的資料傳遞</p>

<p>再來就做 create view 裡面的 save 按鈕!</p>

<p>接著就要到 UpdateViewController</p>

<p>幫 NavigationController 再多加一個右邊按鈕 &ldquo;Save&rdquo;</p>

<pre><code>import UIKit

class UpdateViewController: UIViewController {

    var from: String!
    @IBOutlet var textField: UITextField!

    override func viewDidLoad() {
        super.viewDidLoad()

        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Save", style: UIBarButtonItemStyle.Done, target: self, action: Selector("save"))
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }

    func save() {
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
}
</code></pre>

<p>整個程式碼都不難, 只有簡單處理 push/pop 的問題而已!</p>

<p>如果我們要加上對 ViewController 的 fakeData 做存取的話，請看以下：</p>

<p>由於需要資料傳遞，因此就必須寫 protocol</p>

<p>protocol 可簡單可複雜，今天會寫非常簡單版!</p>

<p>首先先新建一個 swift 檔案, 名為 TodoProtocol.swift</p>

<p>內容如下:</p>

<pre><code>protocol UpdateTODOlistDelegate {
    func addData(id: String, content: String)
}
</code></pre>

<p>接著到 UpdateViewController 中新建一個變數 屬於 UpdateTODOlistDelegate protocol:</p>

<pre><code>var delegate: UpdateTODOlistDelegate!
</code></pre>

<p>並且設定 save 後的行為，會呼叫 protocol 中的</p>

<p><code>addData(id: String, content: String)</code></p>

<p>將欲新增的 id, content 都丟給該方法</p>

<pre><code>func save() {
        //  "id" 在這邊是直接給死的
        delegate.addData("67", content: self.textField.text!)
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
</code></pre>

<p>接著只要在主頁的程式碼中時做 protocol, 設定接到參數後的動作</p>

<p>就可以在接到參數後，將資料寫入 fakeData 了!</p>

<p>回到主頁的程式碼，class 必須先繼承 protocol，再實作</p>

<p>設定繼承後, 實作 addData, 將接到的資料寫入 fakeData:</p>

<pre><code>func addData(id: String, content: String) {
        self.fakeData.append(["id": id, "content": content])

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>記得將 addViewController 的 delegate 設定成 self</p>

<pre><code>func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        addViewController.from = "add"
        addViewController.delegate = self

        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>執行起來就可以增加資料到 fakeData 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d23] - 實戰開發 - TODOList - Show View 2, Delete View]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/23/swift-d23/"/>
    <updated>2014-10-23T14:59:37+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/23/swift-d23</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day23">Github link</a></p>

<p>延續昨天，接下來要做換頁</p>

<p>因此我們必須先新建立一個 ShowViewController, 以及他的 xib</p>

<p>接著我們在 xib 拉幾個元件: 兩個 label, 一個用來顯示目前的 index, 另一個則是顯示內容</p>

<p>拉好後，將這兩個元件設定連結到 ShowViewController.swift</p>

<p><img src="http://goo.gl/XPjBik" alt="image" /></p>

<p>另外多在 ShowViewController 中放兩個變數</p>

<pre><code>var index: Int!
var content: String!
</code></pre>

<p>回到 ViewController, 到 tableView didSelectRowAtIndexPath 中</p>

<p>因為 didSelectRowAtIndexPath 的意思就是當 cell 被選取時要做什麼事情</p>

<p>因此當 cell 被選取時，我們就要讓他跳到下一頁，並且是使用 ShowViewController 來顯示資料</p>

<p>因此修改此方法:</p>

<pre><code>    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        var showViewController = ShowViewController(nibName: "ShowViewController", bundle: nil)
        showViewController.index = indexPath.row
        showViewController.content = fakeData[indexPath.row]["content"]

        // 回復非選取狀態
        tableView.deselectRowAtIndexPath(indexPath, animated: true)
        self.navigationController?.pushViewController(showViewController, animated: true)
    }
</code></pre>

<p>最後在 ShowViewController 中的 viewDidLoad 加入:</p>

<pre><code>        indexLabel.text = "\(index)"
        contentLabel.text = content
</code></pre>

<p>這樣一來在 ShowViewController 被建立時，顯示的 label 就會將上一個 view 設定的 index, content 的值顯示出來了</p>

<p>執行看看!</p>

<p><img src="http://goo.gl/Uib0IA" alt="image" /></p>

<p>這樣 Show 的部分就完成了!</p>

<p>接著我們回到主頁</p>

<p>要來建立將 cell 向左滑可以刪除的事件，這是 iOS 內建的事件，</p>

<p>因此建立方法也很簡單:</p>

<p>一樣是覆寫 tableView 的方法</p>

<p>要讓 tableView 可以編輯 row - canEditRowAtIndexPath</p>

<pre><code>    func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
        return true
    }
</code></pre>

<p>按下確認刪除後的行為 - 我們在這邊實際上是刪除 fakeData 的值</p>

<p>所以只要 App 重開後就又會回到三筆資料了</p>

<pre><code>    func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {

        self.fakeData.removeAtIndex(indexPath.row)

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })

        let alert = UIAlertView()
        alert.title = "Alert"
        alert.message = "Deleted!"
        alert.addButtonWithTitle("Ok")
        alert.show()
    }
</code></pre>

<p>這樣我們就有顯示單筆以及顯示多筆還有刪除可以用了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d22] - 實戰開發 - TODOList - Show View 1]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/22/swift-d22/"/>
    <updated>2014-10-22T19:13:04+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/22/swift-d22</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day22">Github link</a></p>

<p>接著我們要讓主頁顯示一些假資料:</p>

<p>由於我們未來接的 api 的資料會是 todo_id + content</p>

<p>因此我們先產生一個 dictionary array 來存放我們的假資料</p>

<pre><code class="swift">var fakeData = [[String:String]]()
fakeData = [
    ["id": "1", "content": "A"],
    ["id": "2", "content": "B"],
    ["id": "3", "content": "C"],
]
</code></pre>

<p>再來對主頁的 controller 新增 tableView 上去</p>

<p>並且對 UITableView 加入 delegate 以及 datasource</p>

<pre><code>import UIKit

class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {

    var fakeData = [[String:String]]()
    var tableView: UITableView?

    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.

        fakeData = [["1": "A"], ["2": "B"], ["3": "C"]]
        self.view.backgroundColor = UIColor.yellowColor()

        self.tableView = UITableView(frame: self.view.frame)
        self.tableView?.delegate = self
        self.tableView?.dataSource = self

        self.view.addSubview(self.tableView!)
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }


}
</code></pre>

<p>此時編譯器就會要求實作 UITableViewDataSource, UITableViewDelegate 的 methods</p>

<p>實作完就可以讓 TableView 顯示資料, 這我們之前也都有提到過了~</p>

<p>在這邊我們也同時使用自訂的 CustomTableViewCell, 簡單對 cell 改個顏色，雖然沒什麼多大用處 XD</p>

<pre><code>    func tableView(tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {
        return self.fakeData.count
    }

    func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {
        var cell: CustomTableViewCell? = tableView.dequeueReusableCellWithIdentifier("CustomCell") as? CustomTableViewCell

        if cell == nil {
            var objects = NSBundle.mainBundle().loadNibNamed("CustomTableViewCell", owner: self, options: nil)
            cell = objects[0] as? CustomTableViewCell
        }

        cell!.textLabel?.text = (self.fakeData[indexPath.row])["content"]

        return cell!
    }
</code></pre>

<p><img src="http://goo.gl/8Zis9p" alt="image" /></p>

<p>不過可以看到有小瑕疵，就是選取後他並不會回覆成原本的模樣</p>

<p>因此加入 tableView didSelectRowAtIndexPath:</p>

<pre><code>    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {

        // 回復非選取狀態
        tableView.deselectRowAtIndexPath(indexPath, animated: true)
    }
</code></pre>

<p>明天就會提到換頁以及刪除的作法!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d21] - 實戰開發 - TODOList - 前置設定]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/21/swift-d21/"/>
    <updated>2014-10-21T18:58:10+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/21/swift-d21</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day21">Github link</a></p>

<p>首先在開始寫這隻 app 前，</p>

<p>我們要先定義好程式大致上的流程</p>

<p>基本上接下來的程式碼都不會用到 storyboard</p>

<p>只會用到程式 + xib</p>

<p>程式的流程大致上是使用 Navigation controller 來控制 view 的轉換</p>

<p>第一頁 - tableView 顯示 todo items list</p>

<p><img src="http://goo.gl/RKH85d" alt="image" /></p>

<p>點進子項目可以觀看內容，進到子頁後可以編輯，</p>

<p>編輯後就即可存檔</p>

<p>新增項目則在主頁的右上角 &ldquo;Add&rdquo; 可以新增</p>

<p>我們會先從建立假的資料開始，也就是我會先刻出程式的流程</p>

<p>先不接 API</p>

<p>實際寫出運作流程後，再加上 API 操作的部分</p>

<p>因此今天的進度就先開一個新專案，將基本的 Navigation + tableView 建立起來吧:</p>

<p>首先建立一個新專案</p>

<p>再來到 project settings</p>

<p>將 Main Interface 及 Launch Screen file 拿掉</p>

<p>並將 deploy target 設成 7.1 (反正用到的程式碼都一樣~ 沒有特別使用 8.0 的 lib)</p>

<p>設定 device orientation - 只限定直的</p>

<p><img src="http://goo.gl/xQ6m25" alt="image" /></p>

<p>接著就來編輯 AppDelegate.swift</p>

<p>建立一個 NavigationController + ViewController</p>

<pre><code class="swift">@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?
    var navigationController: UINavigationController?
    var viewController: ViewController?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
        // Override point for customization after application launch.

        self.window = UIWindow(frame: UIScreen.mainScreen().bounds)
        self.window?.backgroundColor = UIColor.whiteColor()

        self.viewController = ViewController()
        self.viewController?.title = "TODO List"

        self.navigationController = UINavigationController(rootViewController: self.viewController!)

        self.window?.makeKeyAndVisible()
        self.window?.rootViewController = navigationController

        return true
    }
</code></pre>

<p>就是之前有用到的程式碼，稍作改寫</p>

<p>再來到 ViewController 中, 將背景色稍改一些</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.

        self.view.backgroundColor = UIColor.yellowColor()
    }
</code></pre>

<p>最後將 storyboard 以及 launchScreen.xib 刪掉</p>

<p>執行程式，就 OK 囉！</p>

<p><img src="http://goo.gl/n1T0zv" alt="image" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d20] - Basic - 捨棄 Storyboard 使用純程式碼 的方式撰寫 ViewController]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/20/swift-d20/"/>
    <updated>2014-10-20T18:46:16+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/20/swift-d20</id>
    <content type="html"><![CDATA[<p>今天專案的 <a href="https://github.com/kerkerj/ithome-NoStoryboardDemo">Github link</a></p>

<p>其實哦</p>

<p>寫 Swift 也有幾個禮拜了</p>

<p>我一直覺得使用 Interface Builder 的確很方便</p>

<p>但是在程式面與視覺面之間的溝通常常會漏東漏西的</p>

<p>比方說如果要設定 reusable identifier 時</p>

<p>除了程式裡面的字串要設定以外，還要再到 storyboard 裡設定同樣的字串</p>

<p>一個簡單的小程式可能不超過 20 個 View 的情況下</p>

<p>還可以這樣做，當程式長得非常大的時候，好像就很難注意到這件事，</p>

<p>而且 View 太多 storyboard 就會開始變慢&hellip;.</p>

<p>因此今天要來試著在 Swift 中</p>

<p>如何不用 Storyboard，來打造我們的程式</p>

<p>(當然 xib/nib 還是會用到，只是我們單純捨棄 storyboard，用程式來控制流程)</p>

<p>首先，一樣先建立一個測試專案</p>

<p>接著我們要動到的程式碼是 AppDelegate.swift:</p>

<p>編輯它:</p>

<pre><code class="swift">@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?
    var viewController: ViewController?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
        // Override point for customization after application launch.

        self.viewController = ViewController()
        self.viewController?.view.backgroundColor = UIColor.redColor()

        self.window = UIWindow(frame: UIScreen.mainScreen().bounds)
        self.window?.backgroundColor = UIColor.whiteColor()

        self.window?.rootViewController = viewController
        self.window?.makeKeyAndVisible()

        return true
    }
</code></pre>

<p>其實這段程式碼，就是在做 storyboard 的 &ldquo;進入點&rdquo; 這件事</p>

<pre><code>var viewController: ViewController?
</code></pre>

<p>我們用專案建立時產生的 ViewController 建立了一個物件</p>

<p>並在 application launch 的時候，將該 ViewController 建立起來，設定他的背景顏色為紅色</p>

<pre><code>self.viewController = ViewController()
self.viewController?.view.backgroundColor = UIColor.redColor()
</code></pre>

<p>另外對 window 做一些設定</p>

<pre><code>self.window = UIWindow(frame: UIScreen.mainScreen().bounds)
        self.window?.backgroundColor = UIColor.whiteColor()
</code></pre>

<p>設定他 Screen 大小 (根據手機解析度而定)
並設定 window 的背景顏色為白色</p>

<p>接著是最重要的設定:</p>

<pre><code>self.window?.rootViewController = viewController
self.window?.makeKeyAndVisible()
</code></pre>

<p>我們要讓 viewController 指定為是這個 window 的 rootViewController</p>

<p>並且 makeKeyAndVisible</p>

<p>這樣就完成手動設定進入點的程式了</p>

<p>再來我們就可以大膽一點，把 Storyboard 砍掉啦!</p>

<p>接著執行程式，就可以看到一片紅色了!!!</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-18%2015.10.21.png" alt="image" /></p>

<p>是不是很簡單!</p>

<p>如果要 NavigationController 也可以直接設定!</p>

<p>接下來的實戰開發專案就會以不使用 Storyboard 的方式開發</p>

<p>增加程式碼可讀性 :P</p>

<p>老是貼圖也很累 XDDDD</p>

<p>接下來就要用 Swift 寫一個 TODOList APP 囉!</p>

<p>並且實際接上隔壁棚的 Restful API XD</p>
]]></content>
  </entry>
  
</feed>
