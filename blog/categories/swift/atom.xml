<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-28T17:32:35+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift-d28] - 實戰開發 - TODOList - API 3 新增與更新]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/28/swift-d28/"/>
    <updated>2014-10-28T17:26:52+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/28/swift-d28</id>
    <content type="html"><![CDATA[<p><a href="day28">Github link</a></p>

<p>昨天做了 get list</p>

<p>今天就來做 新增和儲存吧!</p>

<p>可能有人會問說，那讀取一筆 todo 的 API 呢?</p>

<p>因為在這邊資料量少，所有的東西都可以從最外層的 list 拿到</p>

<p>所以雖然有換頁的動作，但是節省流量可以不需要實做這件事</p>

<p>在實際開發中也會如此，case by case，有些情況一次拿完回來處理最好</p>

<p>不過有些則不是~</p>

<p>離題了，</p>

<p>以下是新增 todo 的程式碼:</p>

<p>先到 RestApi.swift 新增 post function</p>

<pre><code class="swift">func addTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, content: String) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: self.addTodoUrl!)
        request.HTTPMethod = "POST"

        var params = ["content": content] as Dictionary&lt;String, String&gt;

        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;err)
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")


        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>再來就是在程式中呼叫這隻 API 囉! 我們會在 UpdateViewController 中做這件事</p>

<p>因為這隻 controler 處理了 &ldquo;Add&rdquo; 和 &ldquo;Update&rdquo; 兩件事</p>

<p>在 save() 這個 function 裡面修改成:</p>

<pre><code>// 記得 class 中先產生一個 api 物件
var api = RestApi()

func save() {
        if from == "add" {
            api.addTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == "edit" {
            println("Save edited data")
        }
    }
</code></pre>

<p>打開執行就可以新增 todo 了!</p>

<p>&ldquo;Update&rdquo; 的行為和新增一樣</p>

<p>先到 RestApi class 加入 update 的方法:</p>

<pre><code>func updateTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, content: String, todoId: String) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: NSURL(string: "http://192.168.1.158:3000/user/kerkerj/todos/\(todoId)")!)
        request.HTTPMethod = "PUT"

        var params = ["content": content] as Dictionary&lt;String, String&gt;

        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;err)
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")


        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>再到剛剛的 UpdateViewController ，把 save() 的另外一個 &ldquo;edit&rdquo; 的區塊改成下面的程式碼</p>

<pre><code>else if from == "edit" {
            println("Save edited data")
            api.updateTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })

            }, content: self.textField.text, todoId: self.index)
        }
</code></pre>

<p>所以整個 save() 會長這樣:</p>

<pre><code>func save() {
        if from == "add" {
            api.addTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == "edit" {
            println("Save edited data")
            api.updateTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })

            }, content: self.textField.text, todoId: self.id
        }
    }
</code></pre>

<p>在這邊要再修改一個之前的 bug Orz</p>

<p>由於我們要更新的時候，必須要使用到該筆資料的 object id</p>

<p>我們之前在 view 中傳遞的都是 content，都沒有 id，因此要加進去</p>

<p>首先要先改的地方是</p>

<p>ViewController 中的</p>

<pre><code>showViewController.id = fakeData[indexPath.row]["id"]

// 改成:
showViewController.id = fakeData[indexPath.row]["_id"]
</code></pre>

<p>因為在 mongodb 中 object id 的名字是 _id</p>

<p>再來要在 ShowViewController 中加入一個把 id 傳到 UpdateViewController</p>

<p>在 ShowViewController 中的 editTODO() 加入:</p>

<p>(因為之前 showView 就已經有拿到 id 了，只是先前的欄位寫錯，加上沒有將 id pass 到 UpdateViewControler 才會發生這種事 XD)</p>

<pre><code>editViewContronller.id = self.id
</code></pre>

<p>應該只有改這樣，最後執行看看</p>

<p>就發現可以編輯成功囉!</p>

<p>快結束啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d27] - 實戰開發 - TODOList - API 2 讀取清單資料]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/27/swift-d27/"/>
    <updated>2014-10-27T23:00:04+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/27/swift-d27</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27">Github link</a></p>

<p>(某一天把兩天份的 commit 在一起了忘了開 branch 了&hellip;)</p>

<p>接下來就要來寫 api utility 了</p>

<p>我們先開一個 swift 檔案 <code>RestApi.swift</code></p>

<pre><code class="swift">import Foundation

class RestApi {
    var API_key = "55665566"
    var getListUrl = NSURL(string: "http://192.168.1.158:3000/user/kerkerj/todos")
}
</code></pre>

<p>先做好前置設定，因為 API 有上簡單的小鎖，因此要先寫起來</p>

<p>還有 request 的網址</p>

<p>以下是 get list 的範例:</p>

<pre><code>func getTodoList(completionHandler: ((NSArray!, NSError!) -&gt; Void)!) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: self.getListUrl!)
        request.HTTPMethod = "GET"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")

        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSArray

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>我們使用內建的 NSURLSession.sharedSession 以及 NSMutableURLRequest 來建立 request</p>

<p>裡面就是設定一些 header 以及 API-Key</p>

<p>另外在資料回來後，return callback</p>

<p>在這邊有 async，寫隔壁棚的 api 回過頭來看這個感覺很熟悉 XD</p>

<p>設定好 API 後</p>

<p>回到顯示 todo 清單的主頁程式碼</p>

<p>由於我們希望能夠在 view 每次被呼叫時，都可以對 API server 做存取</p>

<p>因此必須要將 getTodoList 寫在該方法裏</p>

<p>該方法為 override func viewWillAppear(animated: Bool) {}</p>

<p>先建立一個 api 物件</p>

<pre><code>var api: RestApi = RestApi()
</code></pre>

<p>將原本的假資料刪除或註解, 不過資料物件名稱就繼續用 fakeData XD</p>

<pre><code>//        fakeData = [
//            ["id": "1", "content": "A"],
//            ["id": "2", "content": "B"],
//            ["id": "3", "content": "C"],
//        ]
</code></pre>

<p>接著在 ViewController override 一個 viewWillAppear 的方法</p>

<pre><code>override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(true)

        api.getTodoList({data, error -&gt; Void in
            if error != nil {
                dispatch_async(dispatch_get_main_queue(), {
                    let alert = UIAlertView()
                    alert.title = "Yoooooooooooooooo"
                    alert.message = "Get list faild, maybe check your network: \(error)"
                    alert.addButtonWithTitle("ok")
                    alert.delegate = self
                    alert.show()
                    println(error)
                })
            }

            if (data != nil) {

                var tmpArr = [[String: String]]()

                for item in data {
                    var _id = item["_id"] as String
                    var content = item["content"] as String
                    var dic = [String: String]()

                    dic["_id"] = _id
                    dic["content"] = content

                    tmpArr.append(dic)
                }

                self.arr = tmpArr

                println(self.arr)

                dispatch_async(dispatch_get_main_queue(), {
                    // must be "tableView!" not "tableView?"
                    self.tableView!.reloadData()
                })

            }
        })

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>以上方法都是 async 的方式</p>

<p>只要網路錯誤，就會直接跳一個 alert</p>

<p>若有資料的話就 parse</p>

<p>一併轉換成原本定義的 [[String: String]] 中</p>

<p>執行看看吧!</p>

<p>很明顯每次切回主頁時 api console 都會跳一行 request~</p>

<p>如果使用 sync 的方式就會卡很久! 而且更新 UI 還會 crash XD</p>

<p>我覺得這部分是需要好好去做處理的，在這邊的程式碼只是簡單 demo</p>

<p>並沒有考慮到太多 :P</p>

<p>明天繼續!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d26] - 實戰開發 - TODOList - API 前置資料準備]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/26/swift-d26/"/>
    <updated>2014-10-26T23:04:09+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/26/swift-d26</id>
    <content type="html"><![CDATA[<p>接下來是要串 <a href="http://ithelp.ithome.com.tw/ironman7/app/profile/20091343/dev">隔壁棚的 API</a> XD</p>

<p>從前幾天的 APP 組成</p>

<p>我們所需要的資料大概會是以下幾種:</p>

<ul>
<li>GET todo list</li>
</ul>


<pre><code class="swift">GET http://192.168.1.158:3000/user/kerkerj/todos

return:
[
    {
        "_id": "54441f64d84f1ea412db855c",
        "updated_at": "2014-10-19T20:30:28.797Z",
        "created_at": "2014-10-19T20:30:28.797Z",
        "content": "task11syy",
        "user_id": "kerkerj",
        "__v": 0
    },
    {
        "_id": "54441f6fd84f1ea412db855e",
        "updated_at": "2014-10-19T20:30:39.957Z",
        "created_at": "2014-10-19T20:30:39.957Z",
        "content": "task13",
        "user_id": "kerkerj",
        "__v": 0
    }
]
</code></pre>

<ul>
<li>Get a todo task</li>
</ul>


<pre><code>GET http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return:
{
        "_id": "54441f64d84f1ea412db855c",
        "updated_at": "2014-10-19T20:30:28.797Z",
        "created_at": "2014-10-19T20:30:28.797Z",
        "content": "task11syy",
        "user_id": "kerkerj",
        "__v": 0
}
</code></pre>

<ul>
<li>Add a todo task</li>
</ul>


<pre><code>POST http://192.168.1.158:3000/user/kerkerj/todos/
data: {"content": "your data"}

return: the data you sent
</code></pre>

<ul>
<li>Update a todo task</li>
</ul>


<pre><code>PUT http://192.168.1.158:3000/user/kerkerj/todos/
data: {"content": "your data"}

return: the data you sent
</code></pre>

<ul>
<li>Delete a todo task</li>
</ul>


<pre><code>DELETE http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return 
{"success": "true"}
</code></pre>

<p>從以上資料可以知道</p>

<p>最重要的欄位就是 _id, user_id, content</p>

<p>user_id 我們在 app 中就直接寫死了</p>

<p>所以最重要的就是 content 及 _id</p>

<p>今天先允許我偷懶一下，明天就要開始寫 api utility 給 swift 用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-day25] - 實戰開發 - TODOList - Update View]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/25/swift-day25/"/>
    <updated>2014-10-25T21:46:40+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/25/swift-day25</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27">Github link</a></p>

<p>(忘了是放在哪個 branch 了 Orz)</p>

<p>接下來就要進到最後一個 Update View 了!</p>

<p>什麼時候會進到 Update View 呢？</p>

<p>是在顯示單筆 TODO 的時候的右上方按鈕:</p>

<p><img src="http://goo.gl/tNOyRs" alt="image" /></p>

<p>我們今天只會實作 view 的部分, fakeData 就不實作了</p>

<p>因為接下來就要直接接 API 啦</p>

<p>也不需要更新 fakeData 了 :P</p>

<p>要加入 Edit 這個按鈕</p>

<p>要到 ShowViewController, 加入 UIBarButtonItem</p>

<p>並且讓其吃到一個方法，可以讓 Navigation 往下一個 View 前進:</p>

<pre><code class="swift">var id: String!

override func viewDidLoad() {
        super.viewDidLoad()

        indexLabel.text = "\(index)"
        contentLabel.text = content

        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Edit", style: UIBarButtonItemStyle.Bordered, target: self, action: Selector("editTodo"))
    }
</code></pre>

<p>p.s. 先前忘記加了 id, 現在補回來 XD</p>

<p>先新增一個 Edit 按鈕後</p>

<p>並實作 editTodo</p>

<pre><code>func editTodo() {
        var editViewContronller = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        editViewContronller.from = "edit"
        editViewContronller.content = content
        editViewContronller.index = index

        self.navigationController?.pushViewController(editViewContronller, animated: true)
    }
</code></pre>

<p>由於要先指定資料</p>

<p>因此再到 UpdateViewController 中再加入兩個參數</p>

<pre><code>    var index: Int!
    var content: String!
</code></pre>

<p>最後在 UpdateController 的 viewDidLoad 中, 加入 add or edit 的判斷</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()

        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Save", style: UIBarButtonItemStyle.Done, target: self, action: Selector("save"))

          if self.from == "edit" {
            self.textField.text = content
        }

    }
</code></pre>

<p>這時候先前設定的 &ldquo;from&rdquo; 參數就很有用了~</p>

<p>就可以根據是從 add 的 view 來的或者是 edit 的 view 來的</p>

<p>以便判定要不要 append 舊資料上去</p>

<p>此外，也因為如此</p>

<p>所以 UpdateViewController 的 save 方法也要判斷</p>

<pre><code>        if from == "add" {
            delegate.addData("g6", content: self.textField.text)
            self.navigationController?.popToRootViewControllerAnimated(true)
        } else if from == "edit" {
            println("Save edited data")
        }
</code></pre>

<p>不過因為今天我們不做資料更新</p>

<p>因此流程面大致上到此告一個段落</p>

<p>接下來就要串 API 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d24] - 實戰開發 - TODOList - Create View]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/24/swift-d24/"/>
    <updated>2014-10-24T20:42:41+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/24/swift-d24</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day24">Github link</a></p>

<p>今天要來建立 &ldquo;新增資料&rdquo; 的頁面</p>

<p>不過這個頁面我們也會拿來給 &ldquo;更新資料&rdquo; 的頁面使用</p>

<p>原因其實很簡單</p>

<p>兩邊要建立或編輯的資料是一樣的</p>

<p>差別只在於，當今天是編輯資料的 view call 該頁面時，</p>

<p>該頁面除了顯示編輯框外，編輯框內的文字也會預先 load 好舊的資料了</p>

<p>除此之外兩個 view 的排版一模一樣</p>

<p>所以在這邊我們就只建立一個 UpdateViewController 就可以了</p>

<p>那我們一樣建立一組 UpdateViewController.swift + UpdateViewController.xib</p>

<p>也一樣為元件建立關聯</p>

<p><img src="http://goo.gl/4AO4G0" alt="image" /></p>

<p>回到主頁</p>

<p>我們幫 Add 新增一個按鈕吧</p>

<p>在 viewDidLoad 中</p>

<pre><code class="swift">self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Add", style: UIBarButtonItemStyle.Done, target: self, action: Selector("pushToAddTODO"))
</code></pre>

<p>設定 Navigation 的右邊鍵的功能</p>

<p>並且根據 pushToAddTODO 的方法做事情</p>

<p>因此繼續下去將 pushToAddTODO 方法做一下</p>

<pre><code>    func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        addViewController.from = "add"

        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>這樣寫完後就可以執行看看了!</p>

<p>剩下的任務就是將資料寫進 fakeData 不過考慮到之後我們是使用 API</p>

<p>因此就先不特別作 ShowViewController 的資料傳遞</p>

<p>再來就做 create view 裡面的 save 按鈕!</p>

<p>接著就要到 UpdateViewController</p>

<p>幫 NavigationController 再多加一個右邊按鈕 &ldquo;Save&rdquo;</p>

<pre><code>import UIKit

class UpdateViewController: UIViewController {

    var from: String!
    @IBOutlet var textField: UITextField!

    override func viewDidLoad() {
        super.viewDidLoad()

        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Save", style: UIBarButtonItemStyle.Done, target: self, action: Selector("save"))
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }

    func save() {
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
}
</code></pre>

<p>整個程式碼都不難, 只有簡單處理 push/pop 的問題而已!</p>

<p>如果我們要加上對 ViewController 的 fakeData 做存取的話，請看以下：</p>

<p>由於需要資料傳遞，因此就必須寫 protocol</p>

<p>protocol 可簡單可複雜，今天會寫非常簡單版!</p>

<p>首先先新建一個 swift 檔案, 名為 TodoProtocol.swift</p>

<p>內容如下:</p>

<pre><code>protocol UpdateTODOlistDelegate {
    func addData(id: String, content: String)
}
</code></pre>

<p>接著到 UpdateViewController 中新建一個變數 屬於 UpdateTODOlistDelegate protocol:</p>

<pre><code>var delegate: UpdateTODOlistDelegate!
</code></pre>

<p>並且設定 save 後的行為，會呼叫 protocol 中的</p>

<p><code>addData(id: String, content: String)</code></p>

<p>將欲新增的 id, content 都丟給該方法</p>

<pre><code>func save() {
        //  "id" 在這邊是直接給死的
        delegate.addData("67", content: self.textField.text!)
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
</code></pre>

<p>接著只要在主頁的程式碼中時做 protocol, 設定接到參數後的動作</p>

<p>就可以在接到參數後，將資料寫入 fakeData 了!</p>

<p>回到主頁的程式碼，class 必須先繼承 protocol，再實作</p>

<p>設定繼承後, 實作 addData, 將接到的資料寫入 fakeData:</p>

<pre><code>func addData(id: String, content: String) {
        self.fakeData.append(["id": id, "content": content])

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>記得將 addViewController 的 delegate 設定成 self</p>

<pre><code>func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        addViewController.from = "add"
        addViewController.delegate = self

        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>執行起來就可以增加資料到 fakeData 了!</p>
]]></content>
  </entry>
  
</feed>
