<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-12-08T14:52:37+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift-d30] - 總結]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/30/swift-d30/"/>
    <updated>2014-10-30T01:38:05+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/30/swift-d30</id>
    <content type="html"><![CDATA[<p>30 天下來其實中間受到不少人幫忙</p>

<p>因為第一次寫 iOS 程式，對於 iOS 的基本運作流程還是詢問了不少同事</p>

<p>包含在隔壁棚用 Cocos2d 寫 2D 遊戲的 Andy</p>

<p>還有同事 Henry 和 Felix 都給予了很大的幫忙</p>

<p>最後這隻小 app 其實 code 的品質並沒有很好</p>

<p>主要還是因為寫來 demo 用的，以及老實講也沒什麼時間寫&hellip;</p>

<p>報兩個組別真的是很鐵人哪</p>

<p>還看到隔壁棚一次報三四個主題的大大</p>

<p>真是太厲害了</p>

<p>假設明年還會參賽的話，應該還是會以單一技術來鑽研吧!</p>

<p>Swift 有蠻多特性是 Objective-C 所沒有的</p>

<p>如果有想在新專案嘗試的話</p>

<p>最好還是先多看看網路上的比較</p>

<p>避免踩到雷</p>

<p>像有一點是我們同事曾經踩到的雷</p>

<p>就是 NSDictionary V.S. Dictionary</p>

<p>兩者的速度可以差到 5, 6 倍以上</p>

<p>網路上搜尋也會發現有人在討論 Swift Dictionary 的效能差異</p>

<p>若要在新專案使用還是要查詢一下避免掉一些問題</p>

<p>另外還有就是 Swift on Xcode 的穩定度還是有待加強&hellip;</p>

<p>總而言之, 30 天結束了，ya!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d29] - 實戰開發 - TODOList - API 4 刪除]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/29/swift-d29/"/>
    <updated>2014-10-29T19:33:01+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/29/swift-d29</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day29">Github link</a></p>

<p>今天要處理刪除</p>

<p>其實超簡單的</p>

<p>只是想偷懶一下 XD</p>

<p>一樣將下列程式碼新增到 RestApi class:</p>

<pre><code class="swift">func deleteTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, todoId: String) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: NSURL(string: "http://192.168.1.158:3000/user/kerkerj/todos/\(todoId)")!)
        request.HTTPMethod = "DELETE"

        var err: NSError?
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")


        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary

            println(json)

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>回到 ViewController 中的 tableView commitEditingStyle 的方法中</p>

<p>將其更新為:</p>

<pre><code>func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {

        api.deleteTodoList({data, err -&gt; Void in
            let alert = UIAlertView()
            alert.title = "Alert"
            alert.addButtonWithTitle("Ok")

            if (err != nil) {
                alert.message = "Failed to delete: \(err)"
                alert.show()
            } else {
                alert.message = "ok!"

                self.fakeData.removeAtIndex(indexPath.row)

                dispatch_async(dispatch_get_main_queue(), {
                    // must be "tableView!" not "tableView?"
                    alert.show()
                    self.tableView!.reloadData()
                })
            }
            }, todoId: fakeData[indexPath.row]["_id"]!)
    }
</code></pre>

<p>改好程式碼後，執行該程式</p>

<p>在清單中將 item 往左滑，就可以看到刪除的按鈕了!</p>

<p>超簡單的啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d28] - 實戰開發 - TODOList - API 3 新增與更新]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/28/swift-d28/"/>
    <updated>2014-10-28T17:26:52+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/28/swift-d28</id>
    <content type="html"><![CDATA[<p><a href="day28">Github link</a></p>

<p>昨天做了 get list</p>

<p>今天就來做 新增和儲存吧!</p>

<p>可能有人會問說，那讀取一筆 todo 的 API 呢?</p>

<p>因為在這邊資料量少，所有的東西都可以從最外層的 list 拿到</p>

<p>所以雖然有換頁的動作，但是節省流量可以不需要實做這件事</p>

<p>在實際開發中也會如此，case by case，有些情況一次拿完回來處理最好</p>

<p>不過有些則不是~</p>

<p>離題了，</p>

<p>以下是新增 todo 的程式碼:</p>

<p>先到 RestApi.swift 新增 post function</p>

<pre><code class="swift">func addTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, content: String) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: self.addTodoUrl!)
        request.HTTPMethod = "POST"

        var params = ["content": content] as Dictionary&lt;String, String&gt;

        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;err)
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")


        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>再來就是在程式中呼叫這隻 API 囉! 我們會在 UpdateViewController 中做這件事</p>

<p>因為這隻 controler 處理了 &ldquo;Add&rdquo; 和 &ldquo;Update&rdquo; 兩件事</p>

<p>在 save() 這個 function 裡面修改成:</p>

<pre><code>// 記得 class 中先產生一個 api 物件
var api = RestApi()

func save() {
        if from == "add" {
            api.addTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == "edit" {
            println("Save edited data")
        }
    }
</code></pre>

<p>打開執行就可以新增 todo 了!</p>

<p>&ldquo;Update&rdquo; 的行為和新增一樣</p>

<p>先到 RestApi class 加入 update 的方法:</p>

<pre><code>func updateTodoList(completionHandler: ((NSDictionary!, NSError!) -&gt; Void)!, content: String, todoId: String) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: NSURL(string: "http://192.168.1.158:3000/user/kerkerj/todos/\(todoId)")!)
        request.HTTPMethod = "PUT"

        var params = ["content": content] as Dictionary&lt;String, String&gt;

        var err: NSError?
        request.HTTPBody = NSJSONSerialization.dataWithJSONObject(params, options: nil, error: &amp;err)
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")


        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSDictionary

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>再到剛剛的 UpdateViewController ，把 save() 的另外一個 &ldquo;edit&rdquo; 的區塊改成下面的程式碼</p>

<pre><code>else if from == "edit" {
            println("Save edited data")
            api.updateTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })

            }, content: self.textField.text, todoId: self.index)
        }
</code></pre>

<p>所以整個 save() 會長這樣:</p>

<pre><code>func save() {
        if from == "add" {
            api.addTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController?.popToRootViewControllerAnimated(true)
                })
            }, content: self.textField.text)

        } else if from == "edit" {
            println("Save edited data")
            api.updateTodoList({data, error -&gt; Void in
                if data == nil {
                    println(error)
                }

                dispatch_async(dispatch_get_main_queue(), {
                    println("done")
                    self.navigationController!.popToRootViewControllerAnimated(true)
                })

            }, content: self.textField.text, todoId: self.id
        }
    }
</code></pre>

<p>在這邊要再修改一個之前的 bug Orz</p>

<p>由於我們要更新的時候，必須要使用到該筆資料的 object id</p>

<p>我們之前在 view 中傳遞的都是 content，都沒有 id，因此要加進去</p>

<p>首先要先改的地方是</p>

<p>ViewController 中的</p>

<pre><code>showViewController.id = fakeData[indexPath.row]["id"]

// 改成:
showViewController.id = fakeData[indexPath.row]["_id"]
</code></pre>

<p>因為在 mongodb 中 object id 的名字是 _id</p>

<p>再來要在 ShowViewController 中加入一個把 id 傳到 UpdateViewController</p>

<p>在 ShowViewController 中的 editTODO() 加入:</p>

<p>(因為之前 showView 就已經有拿到 id 了，只是先前的欄位寫錯，加上沒有將 id pass 到 UpdateViewControler 才會發生這種事 XD)</p>

<pre><code>editViewContronller.id = self.id
</code></pre>

<p>應該只有改這樣，最後執行看看</p>

<p>就發現可以編輯成功囉!</p>

<p>快結束啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d27] - 實戰開發 - TODOList - API 2 讀取清單資料]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/27/swift-d27/"/>
    <updated>2014-10-27T23:00:04+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/27/swift-d27</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27">Github link</a></p>

<p>(某一天把兩天份的 commit 在一起了忘了開 branch 了&hellip;)</p>

<p>接下來就要來寫 api utility 了</p>

<p>我們先開一個 swift 檔案 <code>RestApi.swift</code></p>

<pre><code class="swift">import Foundation

class RestApi {
    var API_key = "55665566"
    var getListUrl = NSURL(string: "http://192.168.1.158:3000/user/kerkerj/todos")
}
</code></pre>

<p>先做好前置設定，因為 API 有上簡單的小鎖，因此要先寫起來</p>

<p>還有 request 的網址</p>

<p>以下是 get list 的範例:</p>

<pre><code>func getTodoList(completionHandler: ((NSArray!, NSError!) -&gt; Void)!) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: self.getListUrl!)
        request.HTTPMethod = "GET"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")

        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSArray

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>我們使用內建的 NSURLSession.sharedSession 以及 NSMutableURLRequest 來建立 request</p>

<p>裡面就是設定一些 header 以及 API-Key</p>

<p>另外在資料回來後，return callback</p>

<p>在這邊有 async，寫隔壁棚的 api 回過頭來看這個感覺很熟悉 XD</p>

<p>設定好 API 後</p>

<p>回到顯示 todo 清單的主頁程式碼</p>

<p>由於我們希望能夠在 view 每次被呼叫時，都可以對 API server 做存取</p>

<p>因此必須要將 getTodoList 寫在該方法裏</p>

<p>該方法為 override func viewWillAppear(animated: Bool) {}</p>

<p>先建立一個 api 物件</p>

<pre><code>var api: RestApi = RestApi()
</code></pre>

<p>將原本的假資料刪除或註解, 不過資料物件名稱就繼續用 fakeData XD</p>

<pre><code>//        fakeData = [
//            ["id": "1", "content": "A"],
//            ["id": "2", "content": "B"],
//            ["id": "3", "content": "C"],
//        ]
</code></pre>

<p>接著在 ViewController override 一個 viewWillAppear 的方法</p>

<pre><code>override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(true)

        api.getTodoList({data, error -&gt; Void in
            if error != nil {
                dispatch_async(dispatch_get_main_queue(), {
                    let alert = UIAlertView()
                    alert.title = "Yoooooooooooooooo"
                    alert.message = "Get list faild, maybe check your network: \(error)"
                    alert.addButtonWithTitle("ok")
                    alert.delegate = self
                    alert.show()
                    println(error)
                })
            }

            if (data != nil) {

                var tmpArr = [[String: String]]()

                for item in data {
                    var _id = item["_id"] as String
                    var content = item["content"] as String
                    var dic = [String: String]()

                    dic["_id"] = _id
                    dic["content"] = content

                    tmpArr.append(dic)
                }

                self.arr = tmpArr

                println(self.arr)

                dispatch_async(dispatch_get_main_queue(), {
                    // must be "tableView!" not "tableView?"
                    self.tableView!.reloadData()
                })

            }
        })

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>以上方法都是 async 的方式</p>

<p>只要網路錯誤，就會直接跳一個 alert</p>

<p>若有資料的話就 parse</p>

<p>一併轉換成原本定義的 [[String: String]] 中</p>

<p>執行看看吧!</p>

<p>很明顯每次切回主頁時 api console 都會跳一行 request~</p>

<p>如果使用 sync 的方式就會卡很久! 而且更新 UI 還會 crash XD</p>

<p>我覺得這部分是需要好好去做處理的，在這邊的程式碼只是簡單 demo</p>

<p>並沒有考慮到太多 :P</p>

<p>明天繼續!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d26] - 實戰開發 - TODOList - API 前置資料準備]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/26/swift-d26/"/>
    <updated>2014-10-26T23:04:09+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/26/swift-d26</id>
    <content type="html"><![CDATA[<p>接下來是要串 <a href="http://ithelp.ithome.com.tw/ironman7/app/profile/20091343/dev">隔壁棚的 API</a> XD</p>

<p>從前幾天的 APP 組成</p>

<p>我們所需要的資料大概會是以下幾種:</p>

<ul>
<li>GET todo list</li>
</ul>


<pre><code class="swift">GET http://192.168.1.158:3000/user/kerkerj/todos

return:
[
    {
        "_id": "54441f64d84f1ea412db855c",
        "updated_at": "2014-10-19T20:30:28.797Z",
        "created_at": "2014-10-19T20:30:28.797Z",
        "content": "task11syy",
        "user_id": "kerkerj",
        "__v": 0
    },
    {
        "_id": "54441f6fd84f1ea412db855e",
        "updated_at": "2014-10-19T20:30:39.957Z",
        "created_at": "2014-10-19T20:30:39.957Z",
        "content": "task13",
        "user_id": "kerkerj",
        "__v": 0
    }
]
</code></pre>

<ul>
<li>Get a todo task</li>
</ul>


<pre><code>GET http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return:
{
        "_id": "54441f64d84f1ea412db855c",
        "updated_at": "2014-10-19T20:30:28.797Z",
        "created_at": "2014-10-19T20:30:28.797Z",
        "content": "task11syy",
        "user_id": "kerkerj",
        "__v": 0
}
</code></pre>

<ul>
<li>Add a todo task</li>
</ul>


<pre><code>POST http://192.168.1.158:3000/user/kerkerj/todos/
data: {"content": "your data"}

return: the data you sent
</code></pre>

<ul>
<li>Update a todo task</li>
</ul>


<pre><code>PUT http://192.168.1.158:3000/user/kerkerj/todos/
data: {"content": "your data"}

return: the data you sent
</code></pre>

<ul>
<li>Delete a todo task</li>
</ul>


<pre><code>DELETE http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return 
{"success": "true"}
</code></pre>

<p>從以上資料可以知道</p>

<p>最重要的欄位就是 _id, user_id, content</p>

<p>user_id 我們在 app 中就直接寫死了</p>

<p>所以最重要的就是 content 及 _id</p>

<p>今天先允許我偷懶一下，明天就要開始寫 api utility 給 swift 用</p>
]]></content>
  </entry>
  
</feed>
