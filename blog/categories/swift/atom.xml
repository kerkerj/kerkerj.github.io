<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-27T23:12:36+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[Swift-d27] - 實戰開發 - TODOList - API 2 讀取清單資料]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/27/swift-d27/"/>
    <updated>2014-10-27T23:00:04+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/27/swift-d27</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27">Github link</a></p>

<p>(某一天把兩天份的 commit 在一起了忘了開 branch 了&hellip;)</p>

<p>接下來就要來寫 api utility 了</p>

<p>我們先開一個 swift 檔案 <code>RestApi.swift</code></p>

<pre><code class="swift">import Foundation

class RestApi {
    var API_key = "55665566"
    var getListUrl = NSURL(string: "http://192.168.1.158:3000/user/kerkerj/todos")
}
</code></pre>

<p>先做好前置設定，因為 API 有上簡單的小鎖，因此要先寫起來</p>

<p>還有 request 的網址</p>

<p>以下是 get list 的範例:</p>

<pre><code>func getTodoList(completionHandler: ((NSArray!, NSError!) -&gt; Void)!) {
        var session = NSURLSession.sharedSession()

        var request = NSMutableURLRequest(URL: self.getListUrl!)
        request.HTTPMethod = "GET"
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        request.addValue(self.API_key, forHTTPHeaderField: "API-Key")

        let task = session.dataTaskWithRequest(request, completionHandler: {data, response, error -&gt; Void in
            if (error != nil) {
                return completionHandler(nil, error)
            }

            var error: NSError?
            let json = NSJSONSerialization.JSONObjectWithData(data, options: NSJSONReadingOptions.MutableContainers, error: &amp;error) as NSArray

            if (error != nil) {
                return completionHandler(nil, error)
            } else {
                return completionHandler(json, nil)
            }
        })

        task.resume()
    }
</code></pre>

<p>我們使用內建的 NSURLSession.sharedSession 以及 NSMutableURLRequest 來建立 request</p>

<p>裡面就是設定一些 header 以及 API-Key</p>

<p>另外在資料回來後，return callback</p>

<p>在這邊有 async，寫隔壁棚的 api 回過頭來看這個感覺很熟悉 XD</p>

<p>設定好 API 後</p>

<p>回到顯示 todo 清單的主頁程式碼</p>

<p>由於我們希望能夠在 view 每次被呼叫時，都可以對 API server 做存取</p>

<p>因此必須要將 getTodoList 寫在該方法裏</p>

<p>該方法為 override func viewWillAppear(animated: Bool) {}</p>

<p>先建立一個 api 物件</p>

<pre><code>var api: RestApi = RestApi()
</code></pre>

<p>將原本的假資料刪除或註解, 不過資料物件名稱就繼續用 fakeData XD</p>

<pre><code>//        fakeData = [
//            ["id": "1", "content": "A"],
//            ["id": "2", "content": "B"],
//            ["id": "3", "content": "C"],
//        ]
</code></pre>

<p>接著在 ViewController override 一個 viewWillAppear 的方法</p>

<pre><code>override func viewWillAppear(animated: Bool) {
        super.viewWillAppear(true)

        api.getTodoList({data, error -&gt; Void in
            if error != nil {
                dispatch_async(dispatch_get_main_queue(), {
                    let alert = UIAlertView()
                    alert.title = "Yoooooooooooooooo"
                    alert.message = "Get list faild, maybe check your network: \(error)"
                    alert.addButtonWithTitle("ok")
                    alert.delegate = self
                    alert.show()
                    println(error)
                })
            }

            if (data != nil) {

                var tmpArr = [[String: String]]()

                for item in data {
                    var _id = item["_id"] as String
                    var content = item["content"] as String
                    var dic = [String: String]()

                    dic["_id"] = _id
                    dic["content"] = content

                    tmpArr.append(dic)
                }

                self.arr = tmpArr

                println(self.arr)

                dispatch_async(dispatch_get_main_queue(), {
                    // must be "tableView!" not "tableView?"
                    self.tableView!.reloadData()
                })

            }
        })

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>以上方法都是 async 的方式</p>

<p>只要網路錯誤，就會直接跳一個 alert</p>

<p>若有資料的話就 parse</p>

<p>一併轉換成原本定義的 [[String: String]] 中</p>

<p>執行看看吧!</p>

<p>很明顯每次切回主頁時 api console 都會跳一行 request~</p>

<p>如果使用 sync 的方式就會卡很久! 而且更新 UI 還會 crash XD</p>

<p>我覺得這部分是需要好好去做處理的，在這邊的程式碼只是簡單 demo</p>

<p>並沒有考慮到太多 :P</p>

<p>明天繼續!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d26] - 實戰開發 - TODOList - API 前置資料準備]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/26/swift-d26/"/>
    <updated>2014-10-26T23:04:09+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/26/swift-d26</id>
    <content type="html"><![CDATA[<p>接下來是要串 <a href="http://ithelp.ithome.com.tw/ironman7/app/profile/20091343/dev">隔壁棚的 API</a> XD</p>

<p>從前幾天的 APP 組成</p>

<p>我們所需要的資料大概會是以下幾種:</p>

<ul>
<li>GET todo list</li>
</ul>


<pre><code class="swift">GET http://192.168.1.158:3000/user/kerkerj/todos

return:
[
    {
        "_id": "54441f64d84f1ea412db855c",
        "updated_at": "2014-10-19T20:30:28.797Z",
        "created_at": "2014-10-19T20:30:28.797Z",
        "content": "task11syy",
        "user_id": "kerkerj",
        "__v": 0
    },
    {
        "_id": "54441f6fd84f1ea412db855e",
        "updated_at": "2014-10-19T20:30:39.957Z",
        "created_at": "2014-10-19T20:30:39.957Z",
        "content": "task13",
        "user_id": "kerkerj",
        "__v": 0
    }
]
</code></pre>

<ul>
<li>Get a todo task</li>
</ul>


<pre><code>GET http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return:
{
        "_id": "54441f64d84f1ea412db855c",
        "updated_at": "2014-10-19T20:30:28.797Z",
        "created_at": "2014-10-19T20:30:28.797Z",
        "content": "task11syy",
        "user_id": "kerkerj",
        "__v": 0
}
</code></pre>

<ul>
<li>Add a todo task</li>
</ul>


<pre><code>POST http://192.168.1.158:3000/user/kerkerj/todos/
data: {"content": "your data"}

return: the data you sent
</code></pre>

<ul>
<li>Update a todo task</li>
</ul>


<pre><code>PUT http://192.168.1.158:3000/user/kerkerj/todos/
data: {"content": "your data"}

return: the data you sent
</code></pre>

<ul>
<li>Delete a todo task</li>
</ul>


<pre><code>DELETE http://192.168.1.158:3000/user/kerkerj/todos/54441f64d84f1ea412db855c

return 
{"success": "true"}
</code></pre>

<p>從以上資料可以知道</p>

<p>最重要的欄位就是 _id, user_id, content</p>

<p>user_id 我們在 app 中就直接寫死了</p>

<p>所以最重要的就是 content 及 _id</p>

<p>今天先允許我偷懶一下，明天就要開始寫 api utility 給 swift 用</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-day25] - 實戰開發 - TODOList - Update View]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/25/swift-day25/"/>
    <updated>2014-10-25T21:46:40+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/25/swift-day25</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day27">Github link</a></p>

<p>(忘了是放在哪個 branch 了 Orz)</p>

<p>接下來就要進到最後一個 Update View 了!</p>

<p>什麼時候會進到 Update View 呢？</p>

<p>是在顯示單筆 TODO 的時候的右上方按鈕:</p>

<p><img src="http://goo.gl/tNOyRs" alt="image" /></p>

<p>我們今天只會實作 view 的部分, fakeData 就不實作了</p>

<p>因為接下來就要直接接 API 啦</p>

<p>也不需要更新 fakeData 了 :P</p>

<p>要加入 Edit 這個按鈕</p>

<p>要到 ShowViewController, 加入 UIBarButtonItem</p>

<p>並且讓其吃到一個方法，可以讓 Navigation 往下一個 View 前進:</p>

<pre><code class="swift">var id: String!

override func viewDidLoad() {
        super.viewDidLoad()

        indexLabel.text = "\(index)"
        contentLabel.text = content

        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Edit", style: UIBarButtonItemStyle.Bordered, target: self, action: Selector("editTodo"))
    }
</code></pre>

<p>p.s. 先前忘記加了 id, 現在補回來 XD</p>

<p>先新增一個 Edit 按鈕後</p>

<p>並實作 editTodo</p>

<pre><code>func editTodo() {
        var editViewContronller = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        editViewContronller.from = "edit"
        editViewContronller.content = content
        editViewContronller.index = index

        self.navigationController?.pushViewController(editViewContronller, animated: true)
    }
</code></pre>

<p>由於要先指定資料</p>

<p>因此再到 UpdateViewController 中再加入兩個參數</p>

<pre><code>    var index: Int!
    var content: String!
</code></pre>

<p>最後在 UpdateController 的 viewDidLoad 中, 加入 add or edit 的判斷</p>

<pre><code>override func viewDidLoad() {
        super.viewDidLoad()

        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Save", style: UIBarButtonItemStyle.Done, target: self, action: Selector("save"))

          if self.from == "edit" {
            self.textField.text = content
        }

    }
</code></pre>

<p>這時候先前設定的 &ldquo;from&rdquo; 參數就很有用了~</p>

<p>就可以根據是從 add 的 view 來的或者是 edit 的 view 來的</p>

<p>以便判定要不要 append 舊資料上去</p>

<p>此外，也因為如此</p>

<p>所以 UpdateViewController 的 save 方法也要判斷</p>

<pre><code>        if from == "add" {
            delegate.addData("g6", content: self.textField.text)
            self.navigationController?.popToRootViewControllerAnimated(true)
        } else if from == "edit" {
            println("Save edited data")
        }
</code></pre>

<p>不過因為今天我們不做資料更新</p>

<p>因此流程面大致上到此告一個段落</p>

<p>接下來就要串 API 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d24] - 實戰開發 - TODOList - Create View]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/24/swift-d24/"/>
    <updated>2014-10-24T20:42:41+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/24/swift-d24</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day24">Github link</a></p>

<p>今天要來建立 &ldquo;新增資料&rdquo; 的頁面</p>

<p>不過這個頁面我們也會拿來給 &ldquo;更新資料&rdquo; 的頁面使用</p>

<p>原因其實很簡單</p>

<p>兩邊要建立或編輯的資料是一樣的</p>

<p>差別只在於，當今天是編輯資料的 view call 該頁面時，</p>

<p>該頁面除了顯示編輯框外，編輯框內的文字也會預先 load 好舊的資料了</p>

<p>除此之外兩個 view 的排版一模一樣</p>

<p>所以在這邊我們就只建立一個 UpdateViewController 就可以了</p>

<p>那我們一樣建立一組 UpdateViewController.swift + UpdateViewController.xib</p>

<p>也一樣為元件建立關聯</p>

<p><img src="http://goo.gl/4AO4G0" alt="image" /></p>

<p>回到主頁</p>

<p>我們幫 Add 新增一個按鈕吧</p>

<p>在 viewDidLoad 中</p>

<pre><code class="swift">self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Add", style: UIBarButtonItemStyle.Done, target: self, action: Selector("pushToAddTODO"))
</code></pre>

<p>設定 Navigation 的右邊鍵的功能</p>

<p>並且根據 pushToAddTODO 的方法做事情</p>

<p>因此繼續下去將 pushToAddTODO 方法做一下</p>

<pre><code>    func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        addViewController.from = "add"

        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>這樣寫完後就可以執行看看了!</p>

<p>剩下的任務就是將資料寫進 fakeData 不過考慮到之後我們是使用 API</p>

<p>因此就先不特別作 ShowViewController 的資料傳遞</p>

<p>再來就做 create view 裡面的 save 按鈕!</p>

<p>接著就要到 UpdateViewController</p>

<p>幫 NavigationController 再多加一個右邊按鈕 &ldquo;Save&rdquo;</p>

<pre><code>import UIKit

class UpdateViewController: UIViewController {

    var from: String!
    @IBOutlet var textField: UITextField!

    override func viewDidLoad() {
        super.viewDidLoad()

        self.navigationItem.rightBarButtonItem = UIBarButtonItem(title: "Save", style: UIBarButtonItemStyle.Done, target: self, action: Selector("save"))
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
    }

    func save() {
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
}
</code></pre>

<p>整個程式碼都不難, 只有簡單處理 push/pop 的問題而已!</p>

<p>如果我們要加上對 ViewController 的 fakeData 做存取的話，請看以下：</p>

<p>由於需要資料傳遞，因此就必須寫 protocol</p>

<p>protocol 可簡單可複雜，今天會寫非常簡單版!</p>

<p>首先先新建一個 swift 檔案, 名為 TodoProtocol.swift</p>

<p>內容如下:</p>

<pre><code>protocol UpdateTODOlistDelegate {
    func addData(id: String, content: String)
}
</code></pre>

<p>接著到 UpdateViewController 中新建一個變數 屬於 UpdateTODOlistDelegate protocol:</p>

<pre><code>var delegate: UpdateTODOlistDelegate!
</code></pre>

<p>並且設定 save 後的行為，會呼叫 protocol 中的</p>

<p><code>addData(id: String, content: String)</code></p>

<p>將欲新增的 id, content 都丟給該方法</p>

<pre><code>func save() {
        //  "id" 在這邊是直接給死的
        delegate.addData("67", content: self.textField.text!)
        self.navigationController?.popToRootViewControllerAnimated(true)
    }
</code></pre>

<p>接著只要在主頁的程式碼中時做 protocol, 設定接到參數後的動作</p>

<p>就可以在接到參數後，將資料寫入 fakeData 了!</p>

<p>回到主頁的程式碼，class 必須先繼承 protocol，再實作</p>

<p>設定繼承後, 實作 addData, 將接到的資料寫入 fakeData:</p>

<pre><code>func addData(id: String, content: String) {
        self.fakeData.append(["id": id, "content": content])

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })
    }
</code></pre>

<p>記得將 addViewController 的 delegate 設定成 self</p>

<pre><code>func pushToAddTODO(){
        var addViewController = UpdateViewController(nibName: "UpdateViewController", bundle: nil)
        addViewController.from = "add"
        addViewController.delegate = self

        self.navigationController?.pushViewController(addViewController, animated: true)
    }
</code></pre>

<p>執行起來就可以增加資料到 fakeData 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[Swift-d23] - 實戰開發 - TODOList - Show View 2, Delete View]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/23/swift-d23/"/>
    <updated>2014-10-23T14:59:37+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/23/swift-d23</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-SwiftTodoApp/tree/Day23">Github link</a></p>

<p>延續昨天，接下來要做換頁</p>

<p>因此我們必須先新建立一個 ShowViewController, 以及他的 xib</p>

<p>接著我們在 xib 拉幾個元件: 兩個 label, 一個用來顯示目前的 index, 另一個則是顯示內容</p>

<p>拉好後，將這兩個元件設定連結到 ShowViewController.swift</p>

<p><img src="http://goo.gl/XPjBik" alt="image" /></p>

<p>另外多在 ShowViewController 中放兩個變數</p>

<pre><code>var index: Int!
var content: String!
</code></pre>

<p>回到 ViewController, 到 tableView didSelectRowAtIndexPath 中</p>

<p>因為 didSelectRowAtIndexPath 的意思就是當 cell 被選取時要做什麼事情</p>

<p>因此當 cell 被選取時，我們就要讓他跳到下一頁，並且是使用 ShowViewController 來顯示資料</p>

<p>因此修改此方法:</p>

<pre><code>    func tableView(tableView: UITableView, didSelectRowAtIndexPath indexPath: NSIndexPath) {
        var showViewController = ShowViewController(nibName: "ShowViewController", bundle: nil)
        showViewController.index = indexPath.row
        showViewController.content = fakeData[indexPath.row]["content"]

        // 回復非選取狀態
        tableView.deselectRowAtIndexPath(indexPath, animated: true)
        self.navigationController?.pushViewController(showViewController, animated: true)
    }
</code></pre>

<p>最後在 ShowViewController 中的 viewDidLoad 加入:</p>

<pre><code>        indexLabel.text = "\(index)"
        contentLabel.text = content
</code></pre>

<p>這樣一來在 ShowViewController 被建立時，顯示的 label 就會將上一個 view 設定的 index, content 的值顯示出來了</p>

<p>執行看看!</p>

<p><img src="http://goo.gl/Uib0IA" alt="image" /></p>

<p>這樣 Show 的部分就完成了!</p>

<p>接著我們回到主頁</p>

<p>要來建立將 cell 向左滑可以刪除的事件，這是 iOS 內建的事件，</p>

<p>因此建立方法也很簡單:</p>

<p>一樣是覆寫 tableView 的方法</p>

<p>要讓 tableView 可以編輯 row - canEditRowAtIndexPath</p>

<pre><code>    func tableView(tableView: UITableView, canEditRowAtIndexPath indexPath: NSIndexPath) -&gt; Bool {
        return true
    }
</code></pre>

<p>按下確認刪除後的行為 - 我們在這邊實際上是刪除 fakeData 的值</p>

<p>所以只要 App 重開後就又會回到三筆資料了</p>

<pre><code>    func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {

        self.fakeData.removeAtIndex(indexPath.row)

        dispatch_async(dispatch_get_main_queue(), {
            // must be "tableView!" not "tableView?"
            self.tableView!.reloadData()
        })

        let alert = UIAlertView()
        alert.title = "Alert"
        alert.message = "Deleted!"
        alert.addButtonWithTitle("Ok")
        alert.show()
    }
</code></pre>

<p>這樣我們就有顯示單筆以及顯示多筆還有刪除可以用了!</p>
]]></content>
  </entry>
  
</feed>
