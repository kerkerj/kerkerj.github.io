<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nodejs | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/nodejs/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-14T22:44:56+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d12] - MongoDB - Hello World! (Client-side)]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/12/api-d12/"/>
    <updated>2014-10-12T18:50:16+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/12/api-d12</id>
    <content type="html"><![CDATA[<p>今天要使用 Node.js 的 mongodb driver 來操作 DB</p>

<p>一樣先開啟虛擬機並且登入吧</p>

<p>會使用到的套件是:</p>

<pre><code class="javascript">mongodb -&gt; mongodb native driver
</code></pre>

<p>或許有人有看過 <code>mongoose</code> -> <a href="http://mongoosejs.com/">官網</a></p>

<p>算是 MongoDB 的 ORM，我們在這邊如果有時間的話再簡單了解一下，</p>

<p>現在先使用 native driver 來操作</p>

<p>我們在這邊就不裝全域套件了，裝在 API 專案裡面</p>

<p>並且使用 <code>-save</code> 來將相依性寫入 <code>package.json 裏</code></p>

<pre><code>$ cd /vagrant/API/
$ npm install mongodb -save
</code></pre>

<p>從虛擬機回到電腦的資料夾中，在虛擬機資料夾的 API 資料夾中，</p>

<p>今天我們先不和 express 搭配，因此就是純操作 node.js + mongodb module</p>

<p>新增一個 <code>mongoTest.js</code></p>

<p>我們先來連線到 MongoDB，連線的方式有很多，下面是其中一種方式，</p>

<pre><code>// 先宣告用的到的東西
var MongoClient = require('mongodb').MongoClient
    , Server = require('mongodb').Server
    , options = { auto_reconnection: true, poolSize: 10 };

// Server 設定
var mongoClient = new MongoClient(new Server('localhost', 27017, options));

// 開啟連線
mongoClient.open(function(err, mongoClient) {
    var db1 = mongoClient.db("testDB");

    if (!err) {
        console.log("Connected!");
    }

    mongoClient.close();
    console.log("Closed!");
});
</code></pre>

<p>回到虛擬機執行</p>

<pre><code>$ node mongoTest.js
Connected!
Closed!
</code></pre>

<p>接著用另外一種連接方式，介紹 CRUD 的操作:</p>

<pre><code>var mongoClient = require('mongodb').MongoClient;

mongoClient.connect('mongodb://localhost:27017/testDB', function(err, db) {
    if(err) throw err;

    // Data
    var todo1 = {todo: "Buy books", time: "2014/10/11", who: "myself"};
    var todo2 = {todo: "Buy milk", time: "2014/10/15", who: "brother"};
    var todo3 = {todo: "Wash cats", time: "2014/11/21", who: "myself"};

    var collection = db.collection('todoTest');
    var where = {todo: "Buy milk"};

    // 新增資料
    collection.insert(todo1, function(err, docs) {
        console.log(docs);
    });

    collection.insert(todo2, function(err, docs) {
        console.log(docs);
    });

    collection.insert(todo3, function(err, docs) {
        console.log(docs);
    });

    // 更新資料
    collection.update(where, { $set: { time: "2014/12/25"} }, function(err) {
        console.log(err);
    });

    // 刪除某筆資料
    collection.remove(where, function(err) {
        console.log(err);
    });

    // 查詢某筆資料
    collection.find(where).toArray(function(err, results) {
        console.dir(results);
    });

    // 查詢所有資料
    collection.find().toArray(function(err, results) {
        console.dir(results);
    });
});
</code></pre>

<p>請注意，以上操作由於 javascript async 特性的關係，</p>

<p>每個操作是會同時間送出，不同時間回送，看操作的運算時間而定</p>

<p>因此若要依順序性的話，一是使用 callback，二是使用 async.js</p>

<p>後面應該會提到 XD</p>

<p>將這些程式碼存到 js file 裏，將某些行先註解掉，執行看看就可以略知一二了，</p>

<p>可以同時搭配終端機直接到 DB 查看</p>

<p>p.s. 大家可能會覺得這樣的方式很麻煩，MongoDB 有沒有好用的 client 來管理 DB 呢</p>

<p>我推薦 RoboMongo，多平台，且可以直接輸入指令，蠻方便的，</p>

<p>那如果是用我們現在的虛擬機的方式，要如何使用 RoboMongo ？</p>

<p>首先，虛擬機的 DB 必須先開啟外部網路可以連線，</p>

<p>注意! 我們目前並沒有創立使用者帳號密碼，不需要驗證即可進入 DB，這樣的做法只限於 demo, 與虛擬機中使用</p>

<p>正式環境還是必須建立使用者帳號密碼</p>

<p>先進到虛擬機更改 db 設定:</p>

<pre><code>$ sudo nano /etc/mongod.conf
</code></pre>

<p>將 bind_ip = 0.0.0.0</p>

<p>按下 ctrl+x 選擇 Y 存檔</p>

<p>重開 mongodb</p>

<pre><code>$ sudo service mongod restart
</code></pre>

<p>若已經下載過 RoboMongo，開啟並輸入欲連線的 DB 設定：</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-06%2013.56.39.png" alt="" /></p>

<p>就可以連進去管理了!</p>

<p>再次提醒，這樣的做法只限於虛擬機及 demo 中測試</p>

<p>正式環境要嘛建立使用者帳號密碼</p>

<p>要嘛就是讓 DB 只限本機存取，請記住這件事情哦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d10] - Express - Hello World!]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/10/api-d10/"/>
    <updated>2014-10-10T01:49:55+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/10/api-d10</id>
    <content type="html"><![CDATA[<h1>Express - Hello World!</h1>

<p>今天就要來安裝主角之一的 <a href="http://expressjs.com/">Express</a> 了!</p>

<p>一樣開啟虛擬機器我應該是可以不用多說了 XD</p>

<p>先確認自己的 node 是不是 NVM 的 node 喲</p>

<h2>建立專案</h2>

<pre><code>$ cd /vagrant/
$ mkdir API
$ cd API/
$ npm init
</code></pre>

<p>自己輸入專案的相關內容吧，不知道的就直接按 enter 空白丟給他~</p>

<p>就會產生 package.json 了!</p>

<h2>安裝 Express</h2>

<pre><code>// 在專案目錄底下 (/vagrant/API/)

$ npm install express -save
</code></pre>

<p>下 <code>-save</code> 的原因是要將 express 加入 package.json 中</p>

<p>離開虛擬機，其實我們也可以在虛擬機資料夾看到剛剛建立的專案了，</p>

<p>現在開始就可以使用自己喜歡的編輯器來開啟這個專案資料夾，我個人偏好使用 Sublime Text</p>

<p>要執行專案時再回終端機即可</p>

<h2>Express Hello World!</h2>

<p>在 API 資料夾中建立一個 app.js</p>

<p>內容是:</p>

<pre><code>javascript
var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('Hello World');
});

app.listen(3000, function() {
    console.log('Listening on port %d', server.address().port);
});
</code></pre>

<p>儲存後，回到終端機，將 express 跑起來:</p>

<pre><code>vagrant@vagrant-ubuntu-trusty-64:/vagrant/API$ node app.js
Listening on port 3000
</code></pre>

<p>開啟瀏覽器，瀏覽 <code>http://192.168.33.10:3000</code> (url 視個人環境而定)</p>

<p>出現 <code>Hello World! Express!</code> 啦～～ 又一個 Hello World 啦~~</p>

<p>是不是有比 Node.js 的範例更簡潔一點呢?</p>

<p>簡單分析一下這段 code :</p>

<pre><code>// 引入 express module
var express = require('express');

// 產生一個 express instance - app
var app = express();

// Express 的重點所在! 稍後解釋
app.get('/', function(req, res){
  res.send('Hello World');
});

// 讓 express server 跑在 port 3000
app.listen(3000, function() {
    console.log('Listening on port %d', server.address().port);
});
</code></pre>

<p>以上概念基本上都和 Node.js 概念差不多</p>

<p>值得一提的是 Express 的 Routing:</p>

<pre><code>app.get('/', function(req, res){
  res.send('Hello World');
});
</code></pre>

<p>最前面有提到 HTTP 的動詞 GET, POST, PUT, DELETE &hellip;</p>

<p>在這邊就必須用上了！</p>

<p>我們可以看一下 express 的 <a href="http://expressjs.com/4x/api.html#router.VERB">API reference</a></p>

<p><code>app.get</code> 的 <code>.get</code> 就是代表 HTTP GET</p>

<p>如果後面接 <code>.post</code> 就是 HTTP POST, 等等都同樣概念</p>

<p><a href="http://expressjs.com/4x/api.html#router.VERB">API reference</a> 中提到，</p>

<pre><code>router.VERB(path, [callback...], callback)
</code></pre>

<p><code>path</code> 的意思就是要開放給 client 的路由, 透過不同的路由導向不同的動作</p>

<p>中間的 <code>[callback...]</code> 是 middleware 這個之後會再解釋</p>

<p>最後一個 callback 是用來處理 request 及 response</p>

<p>在這個例子中，client 並沒有丟參數，因此不需要對 request 作處理，</p>

<p>而 server 要回應 response</p>

<p>所以使用了 <code>res.send('Hello World');</code> 來回傳資料</p>

<p>是不是很簡單勒!</p>

<h2>專案產生器</h2>

<p>或許有人會使用 <code>express-generator</code> 來產生 expresss 專案目錄</p>

<p>雖然它很方便，一次建立好專案結構，並且安裝一些常用搭配的套件，</p>

<p>但是由於在尚未了解 express 的運作原理，</p>

<p>一開始一次建立完整我認為過快，因此先不建議這樣用，</p>

<p>當然，如果已經很熟練很了解 express 中可以使用的東西了，使用產生器當然是節省時間囉~</p>

<pre><code>$ npm install -g express-generator
$ express /tmp/foo &amp;&amp; cd /tmp/foo
</code></pre>

<p>下一篇會講解如何簡單操作 MongoDB!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d8] - Node.js - Hello World!]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/08/api-d8/"/>
    <updated>2014-10-08T13:04:20+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/08/api-d8</id>
    <content type="html"><![CDATA[<h1>Node.js - Hello World!</h1>

<p>一樣先開虛擬機哦~</p>

<p>並且開啟終端機連進 server 裡面~</p>

<p>以下是 <a href="http://nodejs.org/">Node.js</a> 官方網站的 web server 程式範例，我稍作小修改：</p>

<pre><code class="javascript">var http = require('http');

http.createServer(function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}).listen(1337, '0.0.0.0');

console.log('Server running at http://0.0.0.0:1337/');
</code></pre>

<p>我們先在虛擬機的資料夾建立一個子資料夾 &lsquo;HelloWorld&rsquo;</p>

<p>在 HelloWorld 資料夾裡面建立一個 app.js</p>

<p>內容如上，存檔。</p>

<p>使用終端機進入 server :</p>

<pre><code>$ vagrant ssh
$ cd /vagrant/HelloWorld
$ node server.js
</code></pre>

<p>到瀏覽器輸入 <a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a></p>

<p>(或者是你的 Vagrantfile 裡面設定的 private IP)</p>

<p>即可看到 Hello World 了！</p>

<p>要關掉 Server 也非常簡單，回到下指令的地方，按下 ctrl + c 即可中斷程式</p>

<h2>分析</h2>

<p>簡單分析一下此段程式：</p>

<pre><code class="javascript">var http = require('http');
</code></pre>

<p>將 http 這個模組引入，並指定給物件 http</p>

<pre><code class="javascript">http.createServer(
    ...
).listen(1337, '0.0.0.0');
</code></pre>

<p>先略過中間的 function 不看，<br/>
這段 code 的用意即是讓呼叫 http 物件中的 createServer 的方法，
.listen() 則是設定該 server 要跑在哪個 port、hostname</p>

<pre><code class="javascript">function (req, res) {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('Hello World\n');
}
</code></pre>

<p>上面的 code 則是原本在 .createServer() 裡的，
我們可以看一下 Node.js 的 API doc <a href="http://nodejs.org/api/http.html#http_http_createserver_requestlistener">關於此方法的部分</a></p>

<p>.createServer() 要帶入的東西其實是一個 requestListener，<br/>
也就是當 Server 跑起來時，我們開啟瀏覽器，輸入 127.0.0.1:1337 時，<br/>
Node.js Server 要回丟的東西，因此觀察一下此 listener:</p>

<pre><code class="javascript">function (req, res) {
    ...
}
</code></pre>

<p>function 中帶入參數的是 req, res，意即 request, response，<br/>
request 即是 server 接收到 client 端的訊息，<br/>
response 則是 server 要回丟給 client 的訊息，<br/>
由於在此範例中，我們只是要回丟給 client 端一個 hello world 的訊息，
因此，我們不處理 client 送給 server 的 request，
我們只需處理要回丟給 client 的訊息，</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
res.end('Hello World\n');
</code></pre>

<p>寫網頁的開發者應該對一些關鍵字例如 Content-type, text/plain 不陌生，<br/>
第一行代表回傳給使用者的訊息中，HTTP HEAD 的設定是 http status code 200,
並且 Content-type 設定為 text/plain</p>

<pre><code class="javascript">res.writeHead(200, {'Content-Type': 'text/plain'});
</code></pre>

<p>那麼，以下這行 code 的意思即是，此次要回送給使用者的訊息到這裡結束，以 &ldquo;Hello World&rdquo; 作結尾</p>

<pre><code class="javascript">res.end('Hello World\n');
</code></pre>

<p>因此整段 code 看下來，就是一個非常簡單的 http server，</p>

<p><a href="http://192.168.33.10:1337/">http://192.168.33.10:1337/</a> 總是會回傳 Hello World</p>

<p>今天就完成了我們的 Hello World 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Event-driven I/O Models and Coroutine Notes]]></title>
    <link href="http://kerkerj.github.io/blog/2014/08/18/event-driven-i-slash-o-models-and-coroutine/"/>
    <updated>2014-08-18T23:19:51+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/08/18/event-driven-i-slash-o-models-and-coroutine</id>
    <content type="html"><![CDATA[<h2>Event-driven I/O model</h2>

<p>首先，聽到 Event-driven 是從 <a href="http://nodejs.org/">Node.js</a> 得知，</p>

<blockquote><p>Node.js® is a platform built on <a href="http://code.google.com/p/v8/">Chrome&rsquo;s JavaScript runtime</a> for easily building fast, scalable network applications.</p>

<p>Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.</p></blockquote>

<p>其實剛聽到這詞會有點陌生，我們可以先從 Victor 所寫的文章開始讀起:
<a href="http://blog.ez2learn.com/2010/07/17/talk-about-coroutine-and-gevent/">淺談coroutine與gevent</a></p>

<p>裡面提到了幾種網路模型：</p>

<blockquote><ol>
<li>阻塞式單一行程</li>
<li>阻塞式多行程</li>
<li>阻塞式多行程多執行序</li>
<li>非阻塞式事件驅動</li>
<li>非阻塞式 coroutine</li>
</ol>
</blockquote>

<p>以下是各語言 event-driven 的 model<br/>
(Node.js 就不列出了，本身就是 event-driven 設計)</p>

<pre><code>Event-driven model:
* Ruby  -&gt; [Eventmachine](http://rubyeventmachine.com/)  
            -&gt; [Celluloid::IO](https://github.com/celluloid/celluloid-io)   
            -&gt; [Thin Server](http://code.macournoyer.com/thin)   
* Python    -&gt; [Twisted](https://twistedmatrix.com/trac/)  
            -&gt; [Tornado](http://www.tornadoweb.org/en/stable)   
* Perl   -&gt; [Perl Object Environment (POE)](http://poe.perl.org)    
* PHP       -&gt; [REACT](http://reactphp.org) 
</code></pre>

<p>以 Ruby 建構 API Service 的話，可以使用 Sinatra + Eventmachine + thin proxy + Nginx 的 Solution:<br/>
<a href="http://recipes.sinatrarb.com/p/embed/event-machine">Embedding Sinatra within EventMachine</a></p>

<p>延伸閱讀: <br/>
<a href="https://www.igvita.com/2008/05/27/ruby-eventmachine-the-speed-demon/">2008 - Eventmachine and Reactor pattern</a> <br/>
<a href="http://developwithstyle.com/articles/2012/05/23/lessons-learnt-from-building-a-rest-based-api/">2012 - Lessons Learnt From Building a REST API</a><br/>
<a href="https://docs.google.com/document/d/1dU-juYN25FMXdp6Ju62KAIT_0tuuZAPEgZkj-aT6kPQ/edit#heading=h.lafes4uxj2b0">年份未知 - 針對各 framework 進行評測 Event Driven I/O Web Application Server Analysis</a><br/>
<a href="http://blog.sina.com.cn/s/blog_704b6af70100py9n.html">Twisted 教程</a></p>

<h4>Reactor 模型</h4>

<p>Node.js 處理 concurrency 是 Reactor mode<br/>
Ruby 的 Goliath framework 也是 Reactor mode<br/>
Golang, Erlang 是 CSP (communicating sequential process)</p>

<p>現在比較流行的是 event-driven 的 Reactor mode, e.g. Node.js, Goliath<br/>
但是 Node.js 比較令人詬病的是 code 難維護，太多層層的 callback 會擾亂邏輯<br/>
畢竟線性處理比較符合人類思維 <br/>
而 Ruby 使用 Fiber 以避免寫出過多的 callback<br/>
Python 的 Twisted 也已經存在好一陣子，穩定發展中</p>

<p>不過以 Node.js 典型的應用的確是 proxy, API server<br/>
因此我們可以參考 Node.js 的特性，使用其他語言來達到同樣的效果<br/>
那就是 event-driven</p>

<h2>Coroutine Programming</h2>

<pre><code>* Golang - goroutine (native) 
* Python - [gevent](http://www.gevent.org/)  
* Ruby - Fiber (native)   
* Lua   
</code></pre>

<p>延伸閱讀:<br/>
<a href="http://www.bigfastblog.com/">Ruby 的 eventmachine 相關討論</a><br/>
<a href="http://www.blogjava.net/killme2008/archive/2010/03/11/315158.html">Ruby Fiber 指南</a><br/>
<a href="http://electronic-blue.herokuapp.com/blog/2012/06/coroutine-an-introduction/">2012 - Lua - Coroutine introduction</a><br/>
<a href="https://www.igvita.com/2009/05/13/fibers-cooperative-scheduling-in-ruby/">2009 - Fibers &amp; Cooperative Scheduling in Ruby</a><br/>
<a href="http://www.blogjava.net/killme2008/archive/2010/03/02/314264.html">2010 - Lua、LuaJIT Coroutine和Ruby Fiber的切換效率對比</a></p>

<hr />

<p>建構 API Service 考慮到的除了 Server 以外，<br/>
語言的特性通常也必須考慮進去，例如<br/>
sync v.s. async<br/>
coroutine v.s. non-coroutine<br/>
但通常以當前需求而言，其實也不需要 over-design<br/>
只要選擇拿手的，能夠快速方便的開發出雛形，<br/>
我想等到真的快要 10000 per/second request 時，再來煩惱更進一步的架構吧</p>
]]></content>
  </entry>
  
</feed>
