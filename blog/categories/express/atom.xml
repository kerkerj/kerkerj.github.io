<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Express | kerkerj]]></title>
  <link href="http://kerkerj.github.io/blog/categories/express/atom.xml" rel="self"/>
  <link href="http://kerkerj.github.io/"/>
  <updated>2014-10-27T23:12:36+08:00</updated>
  <id>http://kerkerj.github.io/</id>
  <author>
    <name><![CDATA[kerkerj]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[API-d27] - 實戰開發 - Log 處理 及 Config (Db, Apikey)]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/27/api-d27/"/>
    <updated>2014-10-27T23:00:00+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/27/api-d27</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day27">Github 參考</a></p>

<h2>log 處理</h2>

<p>今天要來談談 log 的處理，</p>

<p>身為一台自走 (?) node.js API server</p>

<p>也應該要記錄一下 request 的 log 呀！</p>

<p>不然哪天出問題了都不知道是哪個 request 把 server 搞掛了!</p>

<p>因此我們就要加入 log 的 middleware</p>

<p>node.js 的 log 套件也蠻多的, 例如 <code>winston</code></p>

<p>不過我們今天要用的是 <code>log4js</code></p>

<p>會選擇他其實也只是因為之前寫 <code>java</code> 有用過 <code>log4j</code></p>

<p><code>log4js</code> 的設定感覺起來比較相似</p>

<p>所以就使用它了!</p>

<p>再來我們就安裝一下 <code>log4js</code> 吧</p>

<pre><code class="javascript">$ npm install log4js -save  
</code></pre>

<p>並在 <code>app.js</code> 中 require 進去</p>

<pre><code>var log4js = require('log4js');
</code></pre>

<p>接著在 <code>app.js</code> 的前面區段加入以下程式碼:</p>

<pre><code>log4js.configure({
    appenders: [
        { type: 'console' }, //控制台輸出
        {
            type: 'file', //文件輸出
            filename: 'logs/access.log',
            maxLogSize: 20000000, // 20 MB
            backups: 10,
            category: 'normal'
        }
    ],
    replaceConsole: true
});

var logger = log4js.getLogger('normal');
logger.setLevel('INFO');

app.use(log4js.connectLogger(logger, {level: 'auto', format:':method :url'}));
</code></pre>

<p>其實註解已經可以看出一些端倪了</p>

<p>使用 <code>log4js</code> 可以輸出 log 檔案，並且會按照設定的檔案大小來寫入</p>

<p>如果達到 20MB 就會換一個新的檔案寫入，原本的還保留著，不過最多只會保留 10 份</p>

<p>接著就設定 log level, 以及想要 log 的資訊</p>

<p>詳細資訊就可以再多查詢一下</p>

<p>此時我們將 server run 起來吧!</p>

<p>並且對 server 戳幾個 request, 就會發現 log 檔案被建立起來了!</p>

<p>(該程式碼加在 token 檢查前或檢查後是有差異的，加在 token 檢查後面，token error 的話則不會被記錄到 log 裡面)</p>

<p>打開 log 檔看看，就會發現有 log 被寫入囉!</p>

<h2>config (db, apikey)</h2>

<p>有些重要的設定檔其實我們並不希望寫在程式碼裡，這時候 config 的設定很有用</p>

<p>建立設定檔有很多種方式，比方說直接寫一個 json 檔案，或是 xml 檔案</p>

<p>今天我們就用最簡單的 js 檔案的方式來建立 config 檔</p>

<p>我們在 config 資料夾裡新增一個 config.js</p>

<p>我們以下面的程式碼當作例子:</p>

<pre><code>module.exports = {
    "base_url": "http://localhost:3000",
    "test_token": "55665566",
    "db": {
        "production": "mongodb://192.168.33.10:27017/TODOs",
        "development": "mongodb://192.168.33.10:27017/DEV_TODOs",
        "test": "mongodb://192.168.33.10:27017/TEST_TODOs"
    }
};
</code></pre>

<p>要怎麼使用裡面的內容呢?</p>

<p>假設我們要將 db 的連結改成用 config 的方式連結的話:</p>

<pre><code>var config = require('./config/config');

// Set DB
mongoose.connect(config.db.development);
</code></pre>

<p>只要先將 config require 進來，然後就直接使用它就好了!</p>

<p>這樣就可以幫助我們將一些重要的設定從程式碼中抽離出來了!</p>

<p>今天就這樣啦!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d26] - 實戰開發 - API-key]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/26/api-d26/"/>
    <updated>2014-10-26T23:04:04+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/26/api-d26</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day26">Github 參考</a></p>

<p>假設今天我們的 API 上線了，可能就會面臨到一些問題，</p>

<p>例如說，任何人都可以存取我們的 API</p>

<p>當然我們不希望任何人都可以存取，</p>

<p>因此我們必須加一點驗證機制在裡面，</p>

<p>其中一種做法是使用 Oauth token</p>

<p>在拿 API 資料前，先向 Oauth server 要一個 token</p>

<p>Oauth Server 認可身份後即會核發一個 token 給 client 端</p>

<p>該 token 具有時效性，6 mins ~ 30 min 不等，看怎麼實作</p>

<p>接著 client 端就拿該組 token 以及 API url 對 resources server 丟 request</p>

<p>其實我們現在在做的 API server 就是一個 resources server</p>

<p>因為我們提供資源</p>

<p>而 resources server 就會先認 token，</p>

<p>確保該 token 的時效性以及正確性，以及該 token 可存取的資源範圍</p>

<p>確認無誤後再回送正確的資料</p>

<p>不過在這邊我們並沒有要實作 Oauth Server</p>

<p>單純以一個 resources server 而言，只要認 token 是否正確</p>

<p>因此我們在這邊用 API-Key 實作即可，簡單的服務只要不被猜到就好</p>

<p>程式碼如下，記得加在 router 前面</p>

<p>app.js:</p>

<pre><code class="javascript">// Set Header Check
app.use( function(req, res, next) {
    var api_key = req.get('API-Key');

    if (api_key != "55665566") {
        res.status(401).send({ error: "Unauthorized"});
    }
    else {
        next();
    }
});
</code></pre>

<p>一樣是 middleware 的概念</p>

<p>不過是會預先作處理</p>

<p>我們接收到 request 後，分析它的 header 中是否有 <code>API-Key</code> 這個欄位</p>

<p>若有的話，確認他的值是否為 <code>55665566</code></p>

<p>若不是的話，回傳 401 Unauthorized</p>

<p>若正確則繼續走下一個 middleware</p>

<p>這樣就可以做一道簡單的防線了</p>

<p>若加了這道防線</p>

<p>在使用 POSTMAN 做 request 時，必須加入自定 header</p>

<p>沒加入的話:</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%204.11.59.png" alt="image" /></p>

<p>有加入的話:</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%204.12.18.png" alt="image" /></p>

<p>是不是很簡單呢!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-day25] - 實戰開發 - 處理 404 & 500]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/25/api-day25/"/>
    <updated>2014-10-25T21:46:35+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/25/api-day25</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day25">Github 參考</a></p>

<p>不知道大家在用 POSTMAN 對前幾天寫的 API 丟 request 有沒有遇過類似下面的情況:</p>

<pre><code class="javascript">Cannot GET /user/kerkerj/todoss
</code></pre>

<p>通常是丟錯網址時會出現的，或是 code 沒寫好會出現 500 error</p>

<p>這些情況是有辦法接到的，今天我們希望能夠接到後，將 message 轉成 json 格式吐回給 client</p>

<p>因此程式碼如下</p>

<p>app.js</p>

<pre><code class="javascript">// catch 404 and forward to error handler
app.use(function(req, res, next) {
    var err = new Error('Not Found');
    err.status = 404;
    res.status(404).jsonp({error: "Not Found"});
    next();
});

// catch 500
app.use(function(err, req, res, next) {
            res.status(err.status || 500).json({error: err.message});
});
</code></pre>

<p>基本上這兩段 code 的意思就是加入了兩個 middleware</p>

<p>如果進來的 request 是屬於 404 or 500 就會回傳 json 格式</p>

<p>並且依錯誤碼不同而回傳不同的訊息</p>

<p>試著將 server 跑起來</p>

<p>亂丟 request 看看</p>

<p>原本應該會是</p>

<pre><code>Cannot GET /user/kerkerj/todoss
</code></pre>

<p>就會變成了 json</p>

<pre><code>{
    "error": "Not Found"
}
</code></pre>

<p>這樣一來, client 程式也就能夠統一接收 json 回傳，而不會因為莫名的字串導致解析錯誤而 crash 了!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d24] - 實戰開發 - 刪除 TODO Task API With Mongoose]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/24/api-d24/"/>
    <updated>2014-10-24T20:42:36+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/24/api-d24</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day24">Github 參考</a></p>

<p>還記得昨天說要偷懶一下嗎 XD</p>

<p>因為刪除真的很簡單!</p>

<p>我們前面走過了新增、修改、讀取了</p>

<p>刪除？哪有什麼困難的呢! XD</p>

<p>直接看 code 吧!</p>

<p>routes/users.js:</p>

<pre><code class="javascript">// Delete a todo task
router.delete('/:user_id/todos/:todo_id', function(req, res) {
    var user_id = req.params.user_id;
    var todo_id = req.params.todo_id;

    TODO.remove(
        { _id: todo_id, user_id: user_id },
        function (err) {
            if (err) {
                res.status(400).json(
                    { error: "delete data error"}
                );
            } else {
                res.status(201).json(
                    { success: "true" }
                );
            }
        }
    );
});
</code></pre>

<p>非常的簡單!</p>

<p>先抓到 user_id, todo_id 後</p>

<p>使用 .remove 的方法，下 WHERE 條件，並在 callback 作處理</p>

<p>就完成了!</p>

<p>試試看吧!</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%203.39.09.png" alt="image" /></p>

<p>是不是非常的簡單呢！</p>

<p>我們已經完成 CRUD API 操作了！</p>

<p>接下來幾天會稍作一些細節上的處理!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[API-d23] - 實戰開發 - 修改 TODO Task API With Mongoose]]></title>
    <link href="http://kerkerj.github.io/blog/2014/10/23/api-d23/"/>
    <updated>2014-10-23T14:59:33+08:00</updated>
    <id>http://kerkerj.github.io/blog/2014/10/23/api-d23</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/kerkerj/ithome-RestfulAPIDemo/tree/Day23">Github 參考</a></p>

<p>接上篇，我們已經可以拿到 todo list 了</p>

<p>也可以拿到特定的 todo task</p>

<p>再來我們就可以編輯特定的 todo task 了對吧?</p>

<p>不囉唆直接進入程式碼</p>

<p>routes/users.js</p>

<pre><code class="javascript">// Update a todo task
router.put('/:user_id/todos/:todo_id', function(req, res) {
    var user_id = req.params.user_id;
    var todo_id = req.params.todo_id;
    var data = req.body;

    TODO.update(
        { _id: todo_id, user_id: user_id },
        { $set: { content: data.content } },
        function (err, num, raw, results) {
            if (err) {
                res.status(400).json(
                    { error: "update data error" }
                );
            } else {
                TODO.find({ _id: todo_id, user_id: user_id }, function (err, results) {
                    res.status(201).json(
                        results[0]
                    );
                });
            }
        }
    );
});
</code></pre>

<p>這次拿資料要拿三組: user_id, todo_id, 以及 data from req.body</p>

<pre><code>var user_id = req.params.user_id;
var todo_id = req.params.todo_id;
var data = req.body;
</code></pre>

<p>body 的資料很簡單，就是欲修改的 content 的資料:</p>

<pre><code>{ "content": "想修改的資料" }
</code></pre>

<p>再來，除了是使用 .update 方法以及同樣要下 WHERE 參數外， .update 方法還多了一個參數:</p>

<pre><code>{ _id: todo_id, user_id: user_id },
{ $set: { content: data.content } },
</code></pre>

<p>$set 的意思等同於 SQL 語法中的 SET</p>

<p>如果沒有加 $set 變成下面這樣:</p>

<pre><code>{ _id: todo_id, user_id: user_id },
{ content: data.content } ,
</code></pre>

<p>整個資料就會被洗掉，變成只有 <code>{ content: data.content }</code></p>

<p>因此有沒有加 $set 差很多哦</p>

<p>後面一樣是 callback 的處理</p>

<p>都寫好後，實際開 POSTMAN 試試看吧!</p>

<p>記得要使用 <code>PUT</code> 來丟 request</p>

<p>例子如下，我把原本的 buy milk 改成 buy milk and banana</p>

<p><img src="https://dl.dropboxusercontent.com/u/12400343/images/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202014-10-13%203.31.57.png" alt="image" /></p>

<p>這樣離完成 API 就不遠啦!</p>

<p>明天就稍微休息一下吧 XD</p>
]]></content>
  </entry>
  
</feed>
